category: Data Enrichment & Threat Intelligence
commonfields:
  id: URLhaus
  version: -1
configuration:
- defaultvalue: https://urlhaus-api.abuse.ch/v1/
  display: Server URL (e.g. https://192.168.0.1)
  name: url
  required: false
  type: 0
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "true"
  display: Create relationships
  name: create_relationships
  required: false
  type: 8
- additionalinfo: Maximal value is 1000.
  defaultvalue: "10"
  display: Maximum number of relationships to fetch per indicator
  name: max_num_of_relationships
  required: false
  type: 0
- defaultvalue: "1"
  display: Blacklists appearances threshold
  hidden: true
  name: threshold
  required: false
  type: 0
- display: Compromised (is malicious)
  hidden: true
  name: compromised_is_malicious
  required: false
  type: 8
- additionalinfo: Determines how many times a command should be retried before raising
    an error.
  defaultvalue: "3"
  display: Number of retries
  name: retry
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.0.15
    packID: URLHaus
    packName: URLhaus
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: URLhaus has the goal of sharing malicious URLs that are being used for
  malware distribution.
detaileddescription: |-
  ## How DBot Score is Calculated

  ### URL

  Determined by the status of the URL.

  | **Status** | **DBotScore** |
  | --- | --- |
  | online | Malicious |
  | offline | Suspicious |
  | unknown | Unknown |

  ### Domain

  Determined by the blacklist spamhaus_dbl/surbl of the Domain.

  | **Status**                                                | **DBotScore** |
  |-----------------------------------------------------------| --- |
  | spammer_domain/ phishing_domain/ botnet_cc_domain/ listed | Malicious |
  | not listed                                                | Unknown |
  | In any other case                                                       | Benign |

  ### File

  Score is Malicious.



  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/ur-lhaus)
display: URLhaus
image: data:image/png;base64,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
name: URLhaus
script:
  commands:
  - arguments:
    - default: true
      description: A comma-separated list of URLs to query.
      isArray: true
      name: url
      required: true
    description: Retrieves URL information from URLhaus.
    name: url
    outputs:
    - contextPath: URL.Data
      description: The URL.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: Vendor that reported the URL as malicious.
      type: string
    - contextPath: URL.Malicious.Description
      description: Description of the malicious URL.
      type: string
    - contextPath: URL.Tags
      description: A list of tags associated with the queried malware URL.
      type: string
    - contextPath: URL.Relationships.EntityA
      description: The source of the relationship.
      type: String
    - contextPath: URL.Relationships.EntityB
      description: The destination of the relationship.
      type: String
    - contextPath: URL.Relationships.Relationship
      description: The name of the relationship.
      type: String
    - contextPath: URL.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: String
    - contextPath: URL.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: String
    - contextPath: URLhaus.URL.ID
      description: Unique identifier of the URLhaus database entry.
      type: String
    - contextPath: URLhaus.URL.Status
      description: The current status of the URL.
      type: String
    - contextPath: URLhaus.URL.Host
      description: The extracted host of the malware URL (IP address or domain name/FQDN).
      type: String
    - contextPath: URLhaus.URL.DateAdded
      description: Date the URL was added to URLhaus.
      type: date
    - contextPath: URLhaus.URL.Threat
      description: The threat corresponding to this malware URL.
      type: String
    - contextPath: URLhaus.URL.Blacklist.Name
      description: Name of the block list.
      type: String
    - contextPath: URLhaus.URL.Tags
      description: A list of tags associated with the queried malware URL.
      type: String
    - contextPath: URLhaus.URL.Payload.Name
      description: Payload file name.
      type: String
    - contextPath: URLhaus.URL.Payload.Type
      description: Payload file type.
      type: String
    - contextPath: URLhaus.URL.Payload.MD5
      description: MD5 hash of the HTTP response body (payload).
      type: String
    - contextPath: URLhaus.URL.Payload.VT.Result
      description: VirusTotal results for the payload.
      type: Number
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: URLhaus.URL.Blacklist.Status
      description: Status of the URL in the block list.
      type: String
    - contextPath: URLhaus.URL.Payload.VT.Link
      description: Link to the VirusTotal report.
      type: String
  - arguments:
    - default: true
      description: A comma-separated list of domains to query.
      isArray: true
      name: domain
      required: true
    description: Retrieves domain information from URLhaus.
    name: domain
    outputs:
    - contextPath: Domain.Name
      description: The domain name, for example, google.com.
      type: String
    - contextPath: Domain.Tags
      description: A list of tags associated with the queried malware domain.
      type: string
    - contextPath: Domain.Relationships.EntityA
      description: The source of the relationship.
      type: String
    - contextPath: Domain.Relationships.EntityB
      description: The destination of the relationship.
      type: String
    - contextPath: Domain.Relationships.Relationship
      description: The name of the relationship.
      type: String
    - contextPath: Domain.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: String
    - contextPath: Domain.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: URLhaus.Domain.FirstSeen
      description: Date that the IP address was seen for the first time (UTC).
      type: Date
    - contextPath: URLhaus.Domain.Blacklist.Name
      description: The status of the domain in different block lists.
      type: String
    - contextPath: URLhaus.Domain.URL
      description: URLs observed on this domain.
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: Vendor that reported the domain as malicious.
      type: String
    - contextPath: Domain.Malicious.Description
      description: Description of the malicious domain.
      type: String
    - contextPath: URLhaus.Domain.Blacklist.Status
      description: Status of the domain in the block list.
      type: String
  - arguments:
    - default: true
      description: A comma-separated list of MD5 or SHA256 hashes of the file to query.
      isArray: true
      name: file
      required: true
    description: Retrieves file information from URLhaus.
    name: file
    outputs:
    - contextPath: File.Size
      description: File size (in bytes).
      type: Number
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: String
    - contextPath: File.SSDeep
      description: SSDeep of the file.
      type: String
    - contextPath: File.Type
      description: Type of the file.
      type: String
    - contextPath: File.Relationships.EntityA
      description: The source of the relationship.
      type: String
    - contextPath: File.Relationships.EntityB
      description: The destination of the relationship.
      type: String
    - contextPath: File.Relationships.Relationship
      description: The name of the relationship.
      type: String
    - contextPath: File.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: String
    - contextPath: File.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: String
    - contextPath: URLhaus.File.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: URLhaus.File.SHA256
      description: SHA256 hash of the file.
      type: String
    - contextPath: URLhaus.File.Type
      description: 'File type guessed by URLhaus, for example: .exe, .doc.'
      type: String
    - contextPath: URLhaus.File.Size
      description: File size (in bytes).
      type: Number
    - contextPath: URLhaus.File.Signature
      description: Malware family.
      type: String
    - contextPath: URLhaus.File.FirstSeen
      description: Date and time (UTC) that URLhaus first saw this file (payload).
      type: Date
    - contextPath: URLhaus.File.LastSeen
      description: Date and time (UTC) that URLhaus last saw this file (payload).
      type: Date
    - contextPath: URLhaus.File.DownloadLink
      description: Location (URL) where you can download a copy of this file.
      type: String
    - contextPath: URLhaus.File.VirusTotal.Percent
      description: 'AV detection (percentage), for example: 24.14.'
      type: Number
    - contextPath: URLhaus.File.VirusTotal.Link
      description: Link to the VirusTotal report.
      type: String
    - contextPath: URLhaus.File.URL
      description: A list of malware URLs associated with this payload (max. 100).
      type: Unknown
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
  - arguments:
    - default: true
      description: SHA256 hash of the file to download.
      name: file
      required: true
    description: Downloads a malware sample from URLhaus.
    execution: true
    name: urlhaus-download-sample
    outputs:
    - contextPath: File.Size
      description: File size.
      type: number
    - contextPath: File.SHA1
      description: SHA1 hash of the file.
      type: string
    - contextPath: File.SHA256
      description: SHA256 hash of the file.
      type: string
    - contextPath: File.Name
      description: File name.
      type: string
    - contextPath: File.SSDeep
      description: SSDeep hash of the file.
      type: string
    - contextPath: File.EntryID
      description: File entry ID.
      type: string
    - contextPath: File.Info
      description: File information.
      type: string
    - contextPath: File.Type
      description: File type.
      type: string
    - contextPath: File.MD5
      description: MD5 hash of the file.
      type: string
    - contextPath: File.Extension
      description: File extension.
      type: string
  dockerimage: demisto/python3:3.10.4.29342
  runonce: false
  script: |
    register_module_line('URLhaus', 'start', __line__())
    from typing import Tuple


    ''' IMPORTS '''
    import traceback
    import requests
    import zipfile
    import io
    import re
    from datetime import datetime as dt

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # disable-secrets-detection-start
    # Whether compromised websites are considered malicious or not. See the blacklists output in
    # https://urlhaus-api.abuse.ch/
    # disable-secrets-detection-end
    COMPROMISED_IS_MALICIOUS = demisto.params().get('compromised_is_malicious', False)

    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
    }

    ''' HELPER FUNCTIONS '''


    def http_request(method, command, api_url, use_ssl, data=None):
        retry = int(demisto.params().get('retry', 3))
        try_num = 0

        while try_num < retry:
            try_num += 1
            url = f'{api_url}/{command}/'
            res = requests.request(method,
                                   url,
                                   verify=use_ssl,
                                   data=data,
                                   headers=HEADERS)

            if res.status_code == 200:
                return res

        raise Exception(f'Error in API call {url} [{res.status_code}] - {res.reason}')


    def reformat_date(date):
        try:
            return dt.strptime(date.rstrip(' UTC'), '%Y-%m-%d %H:%M:%S').strftime('%Y-%m-%dT%H:%M:%S')
        except Exception:
            return 'Unknown'


    def extract_zipped_buffer(buffer):
        with io.BytesIO() as bio:
            bio.write(buffer)
            with zipfile.ZipFile(bio) as z:
                return z.read(z.namelist()[0])


    def query_url_information(url, api_url, use_ssl):
        return http_request('POST', 'url', api_url, use_ssl, f'url={url}')


    def query_host_information(host, api_url, use_ssl):
        return http_request('POST', 'host', api_url, use_ssl, f'host={host}')


    def query_payload_information(hash_type, api_url, use_ssl, hash):
        return http_request('POST', 'payload', api_url, use_ssl, f'{hash_type}_hash={hash}')


    def download_malware_sample(sha256, api_url, use_ssl):
        return http_request('GET', f'download/{sha256}', api_url=api_url, use_ssl=use_ssl)


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module(**kwargs):
        """
        Performs basic get request to get item samples
        """
        http_request('POST', 'url', kwargs.get('api_url'), kwargs.get('use_ssl'))


    def url_calculate_score(status: str) -> Tuple[int, str]:
        """
             Calculate DBot Score for the url command using url status.

             Args:
                 status (str): A URL status.

             Returns:
                 dbot_score,description (tuple): The DBot Score and the description associated with it.
         """

        status_dict = {'online': (Common.DBotScore.BAD, "The URL is active (online) and currently serving a payload"),
                       'offline': (Common.DBotScore.SUSPICIOUS, "The URL is inadctive (offline) and serving no payload"),
                       'unknown': (Common.DBotScore.NONE, "The URL status could not be determined")}
        if status_dict.get(status):
            return status_dict[status]
        raise Exception("Got bad url status")


    def domain_calculate_score(blacklist: dict) -> Tuple[int, str]:
        """
             Calculate DBot Score for the domain command using blacklist.

             Args:
                 blacklist (dict): Containing spamhaus_dbl and surbl.

             Returns:
                 dbot_score,description (tuple): The DBot Score and the description associated with it.
         """
        spamhaus_dbl = blacklist.get('spamhaus_dbl', '')
        surbl = blacklist.get('surbl', '')

        if spamhaus_dbl:
            if spamhaus_dbl == 'spammer_domain':
                return Common.DBotScore.BAD, "The queried Domain is a known spammer domain"
            if spamhaus_dbl == 'phishing_domain':
                return Common.DBotScore.BAD, "The queried Domain is a known phishing domain"
            if spamhaus_dbl == 'botnet_cc_domain':
                return Common.DBotScore.BAD, "The queried Domain is a known botnet C&C domain"
        if surbl:
            if surbl == 'listed':
                return Common.DBotScore.BAD, "The queried Domain is listed on SURBL"
        if spamhaus_dbl:
            if spamhaus_dbl == 'not listed':
                return Common.DBotScore.NONE, "The queried Domain is not listed on Spamhaus DBL"
        if surbl:
            if surbl == 'not listed':
                return Common.DBotScore.NONE, "The queried Domain is not listed on SURBL"
        return Common.DBotScore.GOOD, "There is no information about Domain in the blacklist"


    def file_calculate_score() -> Tuple[int, str]:
        """
             Calculate DBot Score for the file command (always malicious).

             Args:
                -

             Returns:
                 dbot_score,description (tuple): The DBot Score and the description associated with it.
         """
        return Common.DBotScore.BAD, 'This file is malicious'


    def determine_host_ioc_type(host: str) -> str:
        """
         Determine the host ioc type.

         Args:
             host (str): The host.

         Returns:
             type (str): The type of the host.
         """
        return 'ip' if is_ip_valid(host) else 'domain'


    def url_create_relationships(uri: str, host: str, files: List[dict], create_relationships: bool,
                                 max_num_of_relationships: int) -> List[EntityRelationship]:
        """
            Returns a list of relationships if create_relationships is true (limited to max_num_of_relationships).

            Args:
                uri (str): The queried URL.
                host (str): A host associated with the URL.
                files (list): Files associated with the URL.
                create_relationships (bool): Indicator for create relationships table.
                max_num_of_relationships (int): Indicator for how many relationships to display.

            Returns:
                relationships (list): The EntityRelationship objects representing the URL relationships.
        """
        relationships = []
        if create_relationships and max_num_of_relationships is not None:
            if host:
                parsed_host = determine_host_ioc_type(host)
                if parsed_host == 'domain':
                    relationships.append(EntityRelationship(
                        name=EntityRelationship.Relationships.HOSTED_ON, entity_a=uri,
                        entity_a_type=FeedIndicatorType.URL,
                        entity_b=host, entity_b_type=FeedIndicatorType.Domain,
                        reverse_name=EntityRelationship.Relationships.HOSTS))
                if parsed_host == 'ip':
                    relationships.append(EntityRelationship(
                        name=EntityRelationship.Relationships.RELATED_TO, entity_a=uri, entity_a_type=FeedIndicatorType.URL,
                        entity_b=host, entity_b_type=FeedIndicatorType.IP,
                        reverse_name=EntityRelationship.Relationships.RELATED_TO))
            if files:
                for file in files:
                    if len(relationships) >= max_num_of_relationships:
                        break

                    file_sh256 = file.get('SHA256')
                    if file_sh256:
                        relationships.append(EntityRelationship(
                            name=EntityRelationship.Relationships.RELATED_TO,
                            entity_a=uri,
                            entity_a_type=FeedIndicatorType.URL,
                            entity_b=file_sh256, entity_b_type=FeedIndicatorType.File,
                            reverse_name=EntityRelationship.Relationships.RELATED_TO))
        return relationships


    def url_create_tags(urlhaus_data: dict) -> List[str]:
        """
            Create url tags.

            Args:
                urlhaus_data (dict): The data retrieved from URLHaus db.

            Returns:
                tags (list): a list of tags to add.
        """
        tags = urlhaus_data.get('Tags', [])
        if urlhaus_data.get('Threat'):
            tags.append(urlhaus_data.get('Threat'))
        return tags


    def url_create_payloads(url_information: dict) -> List[dict]:
        """
            Returns a list of payloads.

            Args:
                url_information (dict): The data retrieved from URLHaus db.

            Returns:
                payloads (list): list of payloads associated with the URL.
        """
        payloads = []
        for payload in url_information.get('payloads') or []:
            vt_data = payload.get('virustotal', None)
            vt_information = None
            if vt_data:
                vt_information = {
                    'Result': float(vt_data.get('percent', 0)),
                    'Link': vt_data.get('link', '')
                }
            payloads.append({
                'Name': payload.get('filename', 'unknown'),
                'Type': payload.get('file_type', ''),
                'MD5': payload.get('response_md5', ''),
                'SHA256': payload.get('response_sha256', ''),
                'VT': vt_information,
            })
        return payloads


    def url_create_blacklist(url_information: dict) -> List[dict]:
        """
            Create blacklist for url command.

            Args:
                url_information(dict).

            Returns:
                Blacklist(list).
        """
        blacklist_information = []
        blacklists = url_information.get('blacklists', {})
        for bl_name, bl_status in blacklists.items():
            blacklist_information.append({'Name': bl_name,
                                          'Status': bl_status})
        return blacklist_information


    def build_context_url_ok_status(url_information: dict, uri: str, params: dict) -> CommandResults:
        """
             Build the output context if the status is ok.

             Args:
                url_information (dict): The data retrieved from URLHaus db.
                uri (str): The queried URL.
                params (dict): The integration params.

             Returns:
                 result (CommandResults): The CommandResults object representing the url command results.
         """
        blacklist_information = url_create_blacklist(url_information)
        date_added = reformat_date(url_information.get('date_added'))
        payloads = url_create_payloads(url_information)
        urlhaus_data = {
            'ID': url_information.get('id', ''),
            'Status': url_information.get('url_status', ''),
            'Host': url_information.get('host', ''),
            'DateAdded': date_added,
            'Threat': url_information.get('threat', ''),
            'Blacklist': blacklist_information,
            'Tags': url_information.get('tags', []),
            'Payload': payloads
        }

        # DBot score calculation
        score, description = url_calculate_score(url_information.get('url_status', {}))
        dbot_score = Common.DBotScore(
            indicator=uri,
            integration_name='URLhaus',
            indicator_type=DBotScoreType.URL,
            reliability=params.get('reliability'),
            score=score,
            malicious_description=description
        )
        relationships = url_create_relationships(uri, url_information.get('host', ''), payloads,
                                                 params.get('create_relationships', True),
                                                 params.get('max_num_of_relationships', 10))
        url_indicator = Common.URL(url=uri, dbot_score=dbot_score, tags=url_create_tags(urlhaus_data),
                                   relationships=relationships)
        human_readable = tableToMarkdown(f'URLhaus reputation for {uri}',
                                         {
                                             'URLhaus link': url_information.get('urlhaus_reference', 'None'),
                                             'Description': description,
                                             'URLhaus ID': urlhaus_data['ID'],
                                             'Status': urlhaus_data['Status'],
                                             'Threat': url_information.get('threat', ''),
                                             'Date added': date_added
                                         })

        return CommandResults(
            readable_output=human_readable,
            outputs_prefix='URLhaus.URL',
            outputs_key_field='ID',
            outputs=urlhaus_data,
            raw_response=url_information,
            indicator=url_indicator,
            relationships=relationships)


    def process_query_info(url_information: dict, uri: str, params: dict) -> CommandResults:
        """
             Process the response.

             Args:
                url_information (dict): The data retrieved from URLHaus db.
                uri (str): The queried URL.
                params (dict): The integration params.

             Returns:
                 result (CommandResults): The CommandResults object representing the url command results.
        """
        if url_information['query_status'] == 'ok':
            return build_context_url_ok_status(url_information, uri, params)

        elif url_information['query_status'] == 'no_results' or url_information['query_status'] == 'invalid_url':

            if re.match(urlRegex, uri):
                return create_indicator_result_with_dbotscore_unknown(indicator=uri,
                                                                      indicator_type=DBotScoreType.URL,
                                                                      reliability=params.get('reliability'))
            human_readable = f'## URLhaus reputation for {uri}\n' \
                             f'Invalid URL!'
            return CommandResults(
                readable_output=human_readable,
                raw_response=url_information,
            )
        else:
            raise DemistoException(f'Query results = {url_information["query_status"]}', res=url_information)


    def run_url_command(url: str, params: dict) -> CommandResults:
        """
             Query the url_information from URLHaus db.

             Args:
                params (dict): The integration params.
                url (str): The queried URL.

             Returns:
                 result (CommandResults): The CommandResults object representing the url command resultsgit .
        """
        try:
            url_information = query_url_information(url, params.get('api_url'), params.get('use_ssl')).json()
        except UnicodeEncodeError:
            return CommandResults(
                readable_output='Service Does not support special characters.',
            )
        return process_query_info(url_information, url, params)


    def url_command(params: dict):
        """
            Split urls and call run_url_command on each of them.

             Args:
                params (dict): The integration params.
        """
        urls = demisto.args().get('url', '')
        for url in argToList(urls):
            return_results(results=run_url_command(url, params))


    def domain_create_relationships(urls: List[dict], domain: str, create_relationships: bool,
                                    max_num_of_relationships: int) -> List[EntityRelationship]:
        """
            Returns a list of relationships if create_relationships is true (limited to max_num_of_relationships).

            Args:
                domain (str): The queried Domain.
                urls (list): Urls associated with the Domain.
                create_relationships (bool): Indicator for create relationships table.
                max_num_of_relationships (int): Indicator for how many relationships to display.

            Returns:
                relationships (list): The EntityRelationship objects representing the Domain relationships.
        """
        relationships: list = []
        if create_relationships and max_num_of_relationships is not None:
            for url in urls:
                if len(relationships) >= max_num_of_relationships:
                    break
                relationships.append(EntityRelationship(
                    name=EntityRelationship.Relationships.HOSTS, entity_a=domain,
                    entity_a_type=FeedIndicatorType.Domain,
                    entity_b=url.get('url'), entity_b_type=FeedIndicatorType.URL,
                    reverse_name=EntityRelationship.Relationships.HOSTED_ON))
        return relationships


    def domain_add_tags(bl_status: str, tags: List[str]) -> None:
        """
            Create tags associated to the domain.

            Args:
                bl_status (str): The Blacklist status associated with the Domain.
                tags (list): A list of tags to return.

        """
        if bl_status:
            tag_to_add = bl_status.replace('_domain', '') if bl_status.endswith('domain') else \
                bl_status if bl_status.startswith('abused') else ''
            if tag_to_add:
                tags.append(tag_to_add)


    def run_domain_command(domain: str, params: dict) -> CommandResults:
        """
             Query the domain_information from URLHaus db.

             Args:
                domain (str): Domain to query.
                params (dict): The integration params.

             Returns:
                 result (CommandResults): The CommandResults object representing the domain command results.
        """

        domain_information = query_host_information(domain, params.get('api_url'), params.get('use_ssl')).json()

        tags: list = []
        if domain_information['query_status'] == 'ok':
            # URLHaus output
            blacklist_information = []
            blacklists = domain_information.get('blacklists', {})
            for bl_name, bl_status in blacklists.items():
                blacklist_information.append({'Name': bl_name,
                                              'Status': bl_status})
                domain_add_tags(bl_status, tags)
            first_seen = reformat_date(domain_information.get('firstseen'))

            urlhaus_data = {
                'FirstSeen': first_seen,
                'Blacklist': blacklists,
                'URL': domain_information.get('urls', [])
            }

            # DBot score calculation
            score, description = domain_calculate_score(domain_information.get('blacklists', {}))
            dbot_score = Common.DBotScore(
                indicator=domain,
                integration_name='URLhaus',
                indicator_type=DBotScoreType.DOMAIN,
                reliability=params.get('reliability'),
                score=score,
                malicious_description=description
            )
            relationships = domain_create_relationships(urlhaus_data.get('URL', ''), domain,
                                                        params.get('create_relationships', True),
                                                        params.get('max_num_of_relationships', False))
            domain_indicator = Common.Domain(domain=domain, dbot_score=dbot_score, tags=tags,
                                             relationships=relationships)

            human_readable = tableToMarkdown(f'URLhaus reputation for {domain}',
                                             {
                                                 'URLhaus link': domain_information.get('urlhaus_reference', 'None'),
                                                 'Description': description,
                                                 'First seen': first_seen,
                                             })
            return CommandResults(
                readable_output=human_readable,
                outputs_prefix='URLhaus.Domain',
                outputs=urlhaus_data,
                raw_response=domain_information,
                indicator=domain_indicator,
                relationships=relationships)
        elif domain_information['query_status'] == 'no_results':
            return create_indicator_result_with_dbotscore_unknown(indicator=domain,
                                                                  indicator_type=DBotScoreType.DOMAIN,
                                                                  reliability=params.get('reliability'))

        elif domain_information['query_status'] == 'invalid_host':
            human_readable = f'## URLhaus reputation for {domain}\n' \
                             f'Invalid domain!'
            return CommandResults(
                readable_output=human_readable,
                raw_response=domain_information)
        else:
            raise DemistoException(f'Query results = {domain_information["query_status"]}', res=domain_information)


    def domain_command(params: dict):
        """
            Split domains and call run_domain_command on each of them.

             Args:
                params (dict): The integration params.

        """
        domains = demisto.args().get('domain', '')
        for domain in argToList(domains):
            return_results(results=run_domain_command(domain, params))


    def file_create_relationships(urls: List[dict], sig: str, file: str, create_relationships: bool,
                                  max_num_of_relationships: int) -> List[EntityRelationship]:
        """
            Returns a list of relationships if create_relationships is true (limited to max_num_of_relationships).

            Args:
                urls (list): Urls associated with the Domain.
                sig (str): The signature of the File.
                file (str): The queried File.
                create_relationships (bool): Indicator for create relationships table.
                max_num_of_relationships (int): Indicator for how many relationships to display.

            Returns:
                relationships (list): The EntityRelationship objects representing the File relationships.
        """
        relationships = []
        if create_relationships and max_num_of_relationships is not None:
            if sig:
                relationships.append(EntityRelationship(
                    name=EntityRelationship.Relationships.INDICATOR_OF, entity_a=file,
                    entity_a_type=FeedIndicatorType.File,
                    entity_b=sig, entity_b_type=ThreatIntel.ObjectsNames.MALWARE,
                    reverse_name=EntityRelationship.Relationships.INDICATED_BY))
            for url in urls:
                if len(relationships) >= max_num_of_relationships:
                    break
                relationships.append(EntityRelationship(
                    name=EntityRelationship.Relationships.RELATED_TO, entity_a=file,
                    entity_a_type=FeedIndicatorType.File,
                    entity_b=url.get('url'), entity_b_type=FeedIndicatorType.URL,
                    reverse_name=EntityRelationship.Relationships.RELATED_TO))
        return relationships


    def run_file_command(hash: str, params: dict) -> CommandResults:
        """
                 Query the file_information from URLHaus db.

                 Args:
                    hash (str): file to query.
                    params (dict): The integration params.

                 Returns:
                     result (CommandResults): The CommandResults object representing the file command results.
            """
        if len(hash) == 32:
            hash_type = 'md5'
        elif len(hash) == 64:
            hash_type = 'sha256'
        else:
            return_error('Only accepting MD5 (32 bytes) or SHA256 (64 bytes) hash types')

        file_information = query_payload_information(hash_type, params.get('api_url'), params.get('use_ssl'),
                                                     hash).json()

        if file_information['query_status'] == 'ok' and file_information['md5_hash']:
            # URLhaus output
            first_seen = reformat_date(file_information.get('firstseen'))
            last_seen = reformat_date(file_information.get('lastseen'))

            urlhaus_data = {
                'MD5': file_information.get('md5_hash', ''),
                'SHA256': file_information.get('sha256_hash', ''),
                'Type': file_information.get('file_type', ''),
                'Size': int(file_information.get('file_size', '')),
                'Signature': file_information.get('signature', ''),
                'FirstSeen': first_seen,
                'LastSeen': last_seen,
                'DownloadLink': file_information.get('urlhaus_download', ''),
                'URL': file_information.get('urls', [])
            }

            virus_total_data = file_information.get('virustotal')
            if virus_total_data:
                urlhaus_data['VirusTotal'] = {
                    'Percent': float(file_information.get('virustotal', {'percent': 0})['percent']),
                    'Link': file_information.get('virustotal', {'link': ''})['link']
                }

            score, description = file_calculate_score()
            dbot_score = Common.DBotScore(
                indicator=hash,
                integration_name='URLhaus',
                indicator_type=DBotScoreType.FILE,
                reliability=params.get('reliability'),
                score=score,
                malicious_description=description
            )

            relationships = file_create_relationships(urlhaus_data['URL'], urlhaus_data.get('Signature', ''), hash,
                                                      params.get('create_relationships', True),
                                                      params.get('max_num_of_relationships', 10))

            file_indicator = Common.File(sha256=hash, dbot_score=dbot_score, relationships=relationships,
                                         ssdeep=file_information.get('ssdeep'), file_type=file_information.get('file_type'))

            human_readable = tableToMarkdown(f'URLhaus reputation for {hash_type.upper()} : {hash}',
                                             {
                                                 'URLhaus link': urlhaus_data.get('DownloadLink', ''),
                                                 'Signature': urlhaus_data.get('Signature', ''),
                                                 'MD5': urlhaus_data.get('MD5', ''),
                                                 'SHA256': urlhaus_data.get('SHA256', ''),
                                                 'First seen': first_seen,
                                                 'Last seen': last_seen,
                                                 'SSDeep': file_information.get('ssdeep'),
                                                 'Type': file_information.get('file_type')
                                             })
            return CommandResults(
                readable_output=human_readable,
                outputs_prefix='URLhaus.File',
                outputs=urlhaus_data,
                raw_response=file_information,
                indicator=file_indicator,
                relationships=relationships)

        elif (file_information['query_status'] == 'ok' and not file_information['md5_hash']) or \
                file_information['query_status'] == 'no_results':
            return create_indicator_result_with_dbotscore_unknown(indicator=hash,
                                                                  indicator_type=DBotScoreType.FILE,
                                                                  reliability=params.get('reliability'))

        elif file_information['query_status'] in ['invalid_md5', 'invalid_sha256']:
            human_readable = f'## URLhaus reputation for {hash_type.upper()} : {hash}\n' \
                             f'Invalid {file_information["query_status"].lstrip("invalid_").upper()}!'
            return CommandResults(
                readable_output=human_readable,
                raw_response=file_information)
        else:
            raise DemistoException(f'Query results = {file_information["query_status"]}', res=file_information)


    def file_command(params: dict):
        """
            Split domains and call run_domain_command on each of them.

             Args:
                params (dict): The integration params.

        """
        files = demisto.args().get('file', '')
        for file in argToList(files):
            return_results(results=run_file_command(file, params))


    def urlhaus_download_sample_command(**kwargs):
        """
        The response can be either the zipped sample (content-type = application/zip), or JSON (content-type = text/html)
        containing the query status.
        """
        file_sha256 = demisto.args()['file']
        res = download_malware_sample(file_sha256, kwargs.get('api_url'), kwargs.get('use_ssl'))

        try:
            if len(res.content) == 0:
                demisto.results({
                    'Type': entryTypes['note'],
                    'HumanReadable': f'No results for SHA256: {file_sha256}',
                    'HumanReadableFormat': formats['markdown']
                })
            elif res.headers['content-type'] in ['text/html', 'application/json'] and \
                    res.json()['query_status'] == 'not_found':
                demisto.results({
                    'Type': entryTypes['note'],
                    'ContentsFormat': formats['json'],
                    'Contents': res.json(),
                    'HumanReadable': f'No results for SHA256: {file_sha256}',
                    'HumanReadableFormat': formats['markdown']
                })
            elif res.headers['content-type'] == 'application/zip':
                demisto.results(fileResult(file_sha256, extract_zipped_buffer(res.content)))
            else:
                raise Exception
                # Handle like an exception
        except Exception:
            demisto.results({
                'Type': entryTypes['error'],
                'ContentsFormat': formats['text'],
                'Contents': str(res.content)
            })


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is %s' % (demisto.command()))


    def main():
        try:
            demisto_params = demisto.params()
            command = demisto.command()

            params = {
                'api_url': demisto_params['url'].rstrip('/'),
                'use_ssl': not demisto_params.get('insecure', False),
                'threshold': int(demisto_params.get('threshold', 1)),
                'create_relationships': demisto_params.get('create_relationships', True),
                'max_num_of_relationships': min(1000, int(demisto_params.get('max_num_of_relationships', 10))),
            }

            reliability = demisto_params.get('integrationReliability', DBotScoreReliability.C)

            if DBotScoreReliability.is_valid_type(reliability):
                params['reliability'] = DBotScoreReliability.get_dbot_score_reliability_from_str(reliability)
            else:
                Exception('Please provide a valid value for the Source Reliability parameter.')

            # Remove proxy if not set to true in params
            handle_proxy()

            if command == 'test-module':
                # This is the call made when pressing the integration test button.
                test_module(**params)
                demisto.results('ok')
            elif command == 'url':
                url_command(params)
            elif command == 'domain':
                domain_command(params)
            elif command == 'file':
                file_command(params)
            elif command == 'urlhaus-download-sample':
                urlhaus_download_sample_command(**params)

        # Log exceptions
        except Exception as exc:
            demisto.debug(traceback.format_exc())
            return_error(f'Failed to execute command "{command}".\nError: {exc}', error=exc)


    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()

    register_module_line('URLhaus', 'end', __line__())
  subtype: python3
  type: python
system: true
