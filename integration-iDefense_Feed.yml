category: Data Enrichment & Threat Intelligence
commonfields:
  id: iDefense Feed
  version: -1
configuration:
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- display: ""
  displaypassword: API Token
  hiddenusername: true
  name: api_token
  required: true
  type: 9
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation
  defaultvalue: Bad
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data
  defaultvalue: A - Completely reliable
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- defaultvalue: indicatorType
  display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- defaultvalue: "20160"
  display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "240"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: Incremental feeds pull only new or modified indicators that have
    been sent from the integration. As the determination if the indicator is new or
    modified happens on the 3rd-party vendor's side, and only indicators that are
    new or modified are sent to Cortex XSOAR, all indicators coming from these feeds
    are labeled new or modified.
  defaultvalue: "true"
  display: Incremental Feed
  name: feedIncremental
  required: false
  type: 8
- additionalinfo: How far back in time to go when performing the first fetch
  defaultvalue: 14 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
- additionalinfo: Which indicator types to fetch
  defaultvalue: IP,Domain,URL
  display: Indicator Type
  name: indicator_type
  options:
  - IP
  - Domain
  - URL
  required: true
  type: 16
- additionalinfo: Severity of the indicator. The value to start fetching indicators
    from.
  defaultvalue: "1"
  display: Indicator Severity
  name: severity
  options:
  - "1"
  - "2"
  - "3"
  - "4"
  - "5"
  required: false
  type: 15
- additionalinfo: Threat Type denotes the type of threats the indicator has been associated
    with.
  display: Threat Type
  name: threat_type
  options:
  - Vulnerability
  - Cyber Crime
  - Cyber Espionage
  - Hacktivism
  required: false
  type: 16
- additionalinfo: Confidence about the indicator details. The value of confidence
    to fetch indicators from. The value between 0-100
  display: Confidence
  name: confidence_from
  required: false
  type: 0
- additionalinfo: A malware family is a classification of malicious files and tools
    based on certain behaviors and static properties
  display: Malware Family
  name: malware_family
  required: false
  type: 0
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 3.2.4
    packID: iDefense
    packName: Accenture CTI
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Fetches indicators from a ACTI feed. You can filter returned indicators
  by indicator type, indicator severity, threat type, confidence, and malware family
  (each of these are an integration parameter).
detaileddescription: "### Partner Contributed Integration\n#### Integration Author:
  Accenture\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email**: [CTI.AcctManagement@accenture.com](mailto:CTI.AcctManagement@accenture.com)\n-
  **URL**: [https://www.accenture.com/us-en/services/security/cyber-defense](https://www.accenture.com/us-en/services/security/cyber-defense)\n***\nFetch
  indicators from a Accenture CTI feed. You can apply filters to the feed to focus
  which indicators you want to ingest, for example, indicator severity, confidence,
  threat type and malware family. By default, the feed fetches three indicator types:
  IP, Domain and URL. \n\n## Get Your API Key\n This feed requires that you have an
  ACTI API key. To get your API key refer to the **Obtain API token** section in the
  [Accenture CTI documentation](https://intelgraph.idefense.com/#/docs/view#page-section-2-0).\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/i-defense-feed)"
display: ACTI Feed (Partner Contribution)
image: data:image/png;base64,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
name: iDefense Feed
script:
  commands:
  - arguments:
    - defaultValue: "50"
      description: The maximum number of results to return. The default value is 50.
      name: limit
    description: Gets the feed indicators.
    name: idefense-get-indicators
  dockerimage: demisto/jmespath:1.0.0.23980
  feed: true
  runonce: false
  script: |
    register_module_line('iDefense Feed', 'start', __line__())
    from typing import Dict, Union


    ### GENERATED CODE ###: from JSONFeedApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('JSONFeedApiModule', 'start', __line__(), wrapper=-3)


    ''' IMPORTS '''
    import urllib3
    import jmespath
    from typing import List, Dict, Union, Optional, Callable, Tuple

    # disable insecure warnings
    urllib3.disable_warnings()


    class Client:
        def __init__(self, url: str = '', credentials: dict = None,
                     feed_name_to_config: Dict[str, dict] = None, source_name: str = 'JSON',
                     extractor: str = '', indicator: str = 'indicator',
                     insecure: bool = False, cert_file: str = None, key_file: str = None, headers: Union[dict, str] = None,
                     tlp_color: Optional[str] = None, data: Union[str, dict] = None, **_):
            """
            Implements class for miners of JSON feeds over http/https.
            :param url: URL of the feed.
            :param credentials: username and password used for basic authentication.
             Can be also used as API key header and value by specifying _header in the username field.
            :param extractor: JMESPath expression for extracting the indicators from
            :param indicator: the JSON attribute to use as indicator. Default: indicator
            :param source_name: feed source name
            If None no additional attributes will be extracted.
            :param insecure: if *False* feed HTTPS server certificate will be verified
            Hidden parameters:
            :param: cert_file: client certificate
            :param: key_file: private key of the client certificate
            :param: headers: Header parameters are optional to specify a user-agent or an api-token.
                Support also a multiline string where each line contains a header of the format 'Name: Value'
                Example: headers = {'user-agent': 'my-app/0.0.1'} or "Authorization: Bearer"
                (curl -H "Authorization: Bearer " "https://api-url.com/api/v1/iocs?first_seen_since=2016-1-1")
            :param tlp_color: Traffic Light Protocol color.
            :param data: Data to post. If not specified will do a GET request. May also be passed as dict as
                supported by requests. If passed as a string will set content-type to
                application/x-www-form-urlencoded if not specified in the headers.

             Example:
                Example feed config:
                'AMAZON': {
                    'url': 'https://ip-ranges.amazonaws.com/ip-ranges.json',
                    'extractor': "prefixes[?service=='AMAZON']",
                    'indicator': 'ip_prefix',
                }
            """

            self.source_name = source_name or 'JSON'
            if feed_name_to_config:
                self.feed_name_to_config = feed_name_to_config
            else:
                self.feed_name_to_config = {
                    self.source_name: {
                        'url': url,
                        'indicator': indicator or 'indicator',
                        'extractor': extractor or '@',
                    }}

            # Request related attributes
            self.url = url
            self.verify = not insecure
            self.auth: Optional[tuple] = None
            self.headers = self.parse_headers(headers)

            if credentials:
                username = credentials.get('identifier', '')
                if username.startswith('_header:'):
                    header_name = username.split(':')[1]
                    header_value = credentials.get('password', '')
                    self.headers[header_name] = header_value
                else:
                    password = credentials.get('password', '')
                    if username is not None and password is not None:
                        self.auth = (username, password)

            self.cert = (cert_file, key_file) if cert_file and key_file else None
            self.tlp_color = tlp_color
            self.post_data = data

            if isinstance(self.post_data, str):
                content_type_header = 'Content-Type'
                if content_type_header.lower() not in [k.lower() for k in self.headers.keys()]:
                    self.headers[content_type_header] = 'application/x-www-form-urlencoded'

        @staticmethod
        def parse_headers(headers: Optional[Union[dict, str]]) -> dict:
            """Parse headers if passed as a string. Support a multiline string where each line contains a header
            of the format 'Name: Value'

            Args:
                headers (Optional[Union[dict, str]]): either dict or string to parse

            Returns:
                dict: returns a headers dict or None
            """
            if not headers:
                return {}
            if isinstance(headers, str):
                res = {}
                for line in headers.splitlines():
                    if line.strip():  # ignore empty lines
                        key_val = line.split(':', 1)
                        res[key_val[0].strip()] = key_val[1].strip()
                return res
            else:
                return headers

        def build_iterator(self, feed: dict, feed_name: str, **kwargs) -> Tuple[List, bool]:
            url = feed.get('url', self.url)

            if is_demisto_version_ge('6.5.0'):
                # Set the If-None-Match and If-Modified-Since headers
                # if we have etag or last_modified values in the context, with server version higher than 6.5.0.
                last_run = demisto.getLastRun()
                etag = demisto.get(last_run, f'{feed_name}.etag')
                last_modified = demisto.get(last_run, f'{feed_name}.last_modified')

                if etag:
                    self.headers['If-None-Match'] = etag

                if last_modified:
                    self.headers['If-Modified-Since'] = last_modified

            result = []
            if not self.post_data:
                r = requests.get(
                    url=url,
                    verify=self.verify,
                    auth=self.auth,
                    cert=self.cert,
                    headers=self.headers,
                    **kwargs
                )
            else:
                r = requests.post(
                    url=url,
                    data=self.post_data,
                    verify=self.verify,
                    auth=self.auth,
                    cert=self.cert,
                    headers=self.headers,
                    **kwargs
                )

            try:
                r.raise_for_status()
                if r.content:
                    data = r.json()
                    result = jmespath.search(expression=feed.get('extractor'), data=data)

            except ValueError as VE:
                raise ValueError(f'Could not parse returned data to Json. \n\nError massage: {VE}')
            if is_demisto_version_ge('6.5.0'):
                return result, get_no_update_value(r, feed_name)
            return result, True


    def get_no_update_value(response: requests.Response, feed_name: str) -> bool:
        """
        detect if the feed response has been modified according to the headers etag and last_modified.
        For more information, see this:
        https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
        https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
        Args:
            response: (requests.Response) The feed response.
            feed_name: (str) the name of the feed.
        Returns:
            boolean with the value for noUpdate argument.
            The value should be False if the response was modified.
        """

        # HTTP status code 304 (Not Modified) set noUpdate to True.
        if response.status_code == 304:
            demisto.debug('No new indicators fetched, createIndicators will be executed with noUpdate=True.')
            return True

        etag = response.headers.get('ETag')
        last_modified = response.headers.get('Last-Modified')

        if not etag and not last_modified:
            demisto.debug('Last-Modified and Etag headers are not exists,'
                          'createIndicators will be executed with noUpdate=False.')
            return False

        last_run = demisto.getLastRun()
        last_run[feed_name] = {
            'last_modified': last_modified,
            'etag': etag
        }
        demisto.setLastRun(last_run)

        demisto.debug('New indicators fetched - the Last-Modified value has been updated,'
                      ' createIndicators will be executed with noUpdate=False.')
        return False


    def test_module(client: Client, limit) -> str:
        for feed_name, feed in client.feed_name_to_config.items():
            custom_build_iterator = feed.get('custom_build_iterator')
            if custom_build_iterator:
                custom_build_iterator(client, feed, limit)
            else:
                client.build_iterator(feed, feed_name)
        return 'ok'


    def fetch_indicators_command(client: Client, indicator_type: str, feedTags: list, auto_detect: bool,
                                 create_relationships: bool = False, limit: int = 0, **kwargs) -> Tuple[List[dict], bool]:
        """
        Fetches the indicators from client.
        :param client: Client of a JSON Feed
        :param indicator_type: the default indicator type
        :param feedTags: the indicator tags
        :param auto_detect: a boolean indicates if we should automatically detect the indicator_type
        :param limit: given only when get-indicators command is running. function will return number indicators as the limit
        :param create_relationships: whether to add connected indicators
        """
        indicators: List[dict] = []
        feeds_results = {}
        no_update = False
        for feed_name, feed in client.feed_name_to_config.items():
            custom_build_iterator = feed.get('custom_build_iterator')
            if custom_build_iterator:
                indicators_from_feed = custom_build_iterator(client, feed, limit, **kwargs)
                if not isinstance(indicators_from_feed, list):
                    raise Exception("Custom function to handle with pagination must return a list type")
                feeds_results[feed_name] = indicators_from_feed
            else:
                feeds_results[feed_name], no_update = client.build_iterator(feed, feed_name, **kwargs)

        for service_name, items in feeds_results.items():
            feed_config = client.feed_name_to_config.get(service_name, {})
            indicator_field = str(feed_config.get('indicator') if feed_config.get('indicator') else 'indicator')
            indicator_type = str(feed_config.get('indicator_type', indicator_type))
            use_prefix_flat = bool(feed_config.get('flat_json_with_prefix', False))
            mapping_function = feed_config.get('mapping_function', indicator_mapping)
            handle_indicator_function = feed_config.get('handle_indicator_function', handle_indicator)
            create_relationships_function = feed_config.get('create_relations_function')

            for item in items:
                if isinstance(item, str):
                    item = {indicator_field: item}

                indicators.extend(
                    handle_indicator_function(client, item, feed_config, service_name, indicator_type, indicator_field,
                                              use_prefix_flat, feedTags, auto_detect, mapping_function,
                                              create_relationships, create_relationships_function))

                if limit and len(indicators) >= limit:  # We have a limitation only when get-indicators command is
                    # called, and then we return for each service_name "limit" of indicators
                    break
        return indicators, no_update


    def indicator_mapping(mapping: Dict, indicator: Dict, attributes: Dict):
        for map_key in mapping:
            if map_key in attributes:
                fields = mapping[map_key].split(".")
                if len(fields) > 1:
                    if indicator['fields'].get(fields[0]):
                        indicator['fields'][fields[0]][0].update({fields[1]: attributes.get(map_key)})
                    else:
                        indicator['fields'][fields[0]] = [{fields[1]: attributes.get(map_key)}]
                else:
                    indicator['fields'][mapping[map_key]] = attributes.get(map_key)  # type: ignore


    def handle_indicator(client: Client, item: Dict, feed_config: Dict, service_name: str,
                         indicator_type: str, indicator_field: str, use_prefix_flat: bool,
                         feedTags: list, auto_detect: bool, mapping_function: Callable = indicator_mapping,
                         create_relationships: bool = False, relationships_func: Callable = None) -> List[dict]:
        indicator_list = []
        mapping = feed_config.get('mapping')
        take_value_from_flatten = False
        indicator_value = item.get(indicator_field)
        if not indicator_value:
            take_value_from_flatten = True
        current_indicator_type = determine_indicator_type(indicator_type, auto_detect, indicator_value)

        if not current_indicator_type:
            demisto.debug(f'Could not determine indicator type for value: {indicator_value} from field: {indicator_field}.'
                          f' Skipping item: {item}')
            return []

        indicator = {
            'type': current_indicator_type,
            'fields': {
                'tags': feedTags,
            }
        }

        if client.tlp_color:
            indicator['fields']['trafficlightprotocol'] = client.tlp_color

        attributes = {'source_name': service_name, 'type': current_indicator_type}
        attributes.update(extract_all_fields_from_indicator(item, indicator_field,
                                                            flat_with_prefix=use_prefix_flat))

        if take_value_from_flatten:
            indicator_value = attributes.get(indicator_field)
        indicator['value'] = indicator_value
        attributes['value'] = indicator_value

        if mapping:
            mapping_function(mapping, indicator, attributes)

        if create_relationships and relationships_func and feed_config.get('relation_name'):
            indicator['relationships'] = relationships_func(feed_config, mapping, attributes)

        if feed_config.get('rawjson_include_indicator_type'):
            item['_indicator_type'] = current_indicator_type

        indicator['rawJSON'] = item

        indicator_list.append(indicator)

        return indicator_list


    def determine_indicator_type(indicator_type, auto_detect, value):
        """
        Detect the indicator type of the given value.
        Args:
            indicator_type: (str) Given indicator type.
            auto_detect: (bool) True whether auto detection of the indicator type is wanted.
            value: (str) The value which we'd like to get indicator type of.
        Returns:
            Str which stands for the indicator type after detection.
        """
        if auto_detect:
            indicator_type = auto_detect_indicator_type(value)
        return indicator_type


    def extract_all_fields_from_indicator(indicator: Dict, indicator_key: str, flat_with_prefix: bool = False) -> Dict:
        """Flattens the JSON object to create one dictionary of values
        Args:
            indicator(dict): JSON object that holds indicator full data.
            indicator_key(str): The key that holds the indicator value.
            flat_with_prefix(bool): Indicates whether should add the inner json path as part of the keys in the flatten json
        Returns:
            dict. A dictionary of the fields in the JSON object.
        """
        fields = {}  # type: dict

        def insert_value_to_fields(key, value):
            if key in fields:
                if not isinstance(fields[key], list):
                    fields[key] = [fields[key]]
                fields[key].append(value)
            else:
                fields[key] = value

        def extract(json_element, prefix_field="", use_prefix=False):
            if isinstance(json_element, dict):
                for key, value in json_element.items():
                    if value and isinstance(value, dict):
                        if use_prefix:
                            extract(value, prefix_field=f"{prefix_field}_{key}" if prefix_field else key,
                                    use_prefix=use_prefix)
                        else:
                            extract(value)
                    elif key != indicator_key:
                        if use_prefix:
                            insert_value_to_fields(f"{prefix_field}_{key}" if prefix_field else key, value)
                        else:
                            insert_value_to_fields(key, value)
            elif json_element and indicator_key not in json_element:
                for key, value in json_element:
                    insert_value_to_fields(key, value)

        extract(indicator, use_prefix=flat_with_prefix)

        return fields


    def feed_main(params, feed_name, prefix):
        handle_proxy()
        client = Client(**params)
        indicator_type = params.get('indicator_type')
        auto_detect = params.get('auto_detect_type')
        feedTags = argToList(params.get('feedTags'))
        limit = int(demisto.args().get('limit', 10))
        command = demisto.command()
        if prefix and not prefix.endswith('-'):
            prefix += '-'
        if command != 'fetch-indicators':
            demisto.info(f'Command being called is {demisto.command()}')
        try:
            if command == 'test-module':
                return_results(test_module(client, limit))

            elif command == 'fetch-indicators':
                create_relationships = params.get('create_relationships')
                indicators, no_update = fetch_indicators_command(client, indicator_type, feedTags, auto_detect,
                                                                 create_relationships)

                # check if the version is higher than 6.5.0 so we can use noUpdate parameter
                if is_demisto_version_ge('6.5.0'):
                    if not indicators:
                        demisto.createIndicators(indicators, noUpdate=no_update)
                    else:
                        for b in batch(indicators, batch_size=2000):
                            demisto.createIndicators(b, noUpdate=no_update)

                else:
                    # call createIndicators without noUpdate arg
                    if not indicators:
                        demisto.createIndicators(indicators)
                    else:
                        for b in batch(indicators, batch_size=2000):
                            demisto.createIndicators(b)

            elif command == f'{prefix}get-indicators':
                # dummy command for testing
                create_relationships = params.get('create_relationships')
                indicators, _ = fetch_indicators_command(client, indicator_type, feedTags, auto_detect, create_relationships, limit)
                hr = tableToMarkdown('Indicators', indicators, headers=['value', 'type', 'rawJSON'])
                return_results(CommandResults(readable_output=hr, raw_response=indicators))

        except Exception as err:
            err_msg = f'Error in {feed_name} integration [{err}]'
            return_error(err_msg)

    register_module_line('JSONFeedApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###


    def custom_build_iterator(client: Client, feed: Dict, limit, **kwargs) -> List:
        """
        Implement the http_request with API that works with pagination and filtering. Uses the integration context to
        save last fetch time to each indicator type
        Args:
            client: Client manage all http requests
            feed: dictionary holds all data needed to the specific service (Services- IP, Domain, URL)
            limit: maximum number of indicators to fetch

        Returns:
            list of indicators returned from api. Each indicator is represented in dictionary
        """
        fetch_time = demisto.params().get('fetch_time', '14 days')
        params: dict = feed.get('filters', {})
        current_indicator_type = feed.get('indicator_type', '')
        start_date, end_date = parse_date_range(fetch_time, utc=True)
        integration_context = get_integration_context()
        last_fetch = integration_context.get(f'{current_indicator_type}_fetch_time')
        if last_fetch:
            start_date = last_fetch
        page_number = 1
        params['end_date'] = end_date
        params['start_date'] = start_date
        params['page_size'] = 200

        if not limit:
            limit = 20000  # This limit was added to make sure we do not hit a timeout on the fetch
            integration_context[f'{current_indicator_type}_fetch_time'] = str(params['end_date'])
            set_integration_context(integration_context)

        more_indicators = True
        result: list = []

        while more_indicators:
            params['page'] = page_number
            demisto.debug(f"Initiating API call to ACTI with url: {feed.get('url', client.url)} ,with parameters: "
                          f"{params} and page number: {page_number} ")
            try:

                r = requests.get(
                    url=feed.get('url', client.url),
                    verify=client.verify,
                    auth=client.auth,
                    cert=client.cert,
                    headers=client.headers,
                    params=params,
                    **kwargs
                )

                r.raise_for_status()
                data = r.json()
                if data.get('total_size'):
                    result.extend(jmespath.search(expression=feed.get('extractor'), data=data))
                more_indicators = data.get('more')
                page_number += 1
                if len(result) >= limit:
                    break

            except ValueError as VE:
                raise ValueError(f'Could not parse returned data to Json. \n\nError massage: {VE}')
            except TypeError as TE:
                raise TypeError(f'Error massage: {TE}\n\n Try To check extractor value')
            except ConnectionError as exception:
                # Get originating Exception in Exception chain
                error_class = str(exception.__class__)
                err_type = f"""<{error_class[error_class.find("'") + 1: error_class.rfind("'")]}>"""
                err_msg = 'Verify that the server URL parameter' \
                          ' is correct and that you have access to the server from your host.' \
                          '\nError Type: {}\nError Number: [{}]\nMessage: {}\n' \
                    .format(err_type, exception.errno, exception.strerror)
                raise DemistoException(err_msg, exception)

        demisto.debug(f"Received in total {len(result)} indicators from ACTI Feed")
        return result


    def create_fetch_configuration(indicators_type: list, filters: dict, params: dict) -> Dict[str, dict]:
        mapping_by_indicator_type = {
            'IP': {
                'last_seen_as': 'malwaretypes',
                'threat_types': 'primarymotivation',
                'malware_family': 'malwarefamily',
                'severity': 'sourceoriginalseverity'},
            'Domain': {
                'last_seen_as': 'malwaretypes',
                'threat_types': 'primarymotivation',
                'malware_family': 'malwarefamily',
                'severity': 'sourceoriginalseverity'},
            'URL': {
                'last_seen_as': 'malwaretypes',
                'threat_types': 'primarymotivation',
                'malware_family': 'malwarefamily',
                'severity': 'sourceoriginalseverity'}
        }

        url_by_type = {"IP": 'https://api.intelgraph.idefense.com/rest/threatindicator/v0/ip',
                       "Domain": 'https://api.intelgraph.idefense.com/rest/threatindicator/v0/domain',
                       "URL": 'https://api.intelgraph.idefense.com/rest/threatindicator/v0/url'}

        common_conf = {'extractor': 'results',
                       'indicator': 'display_text',
                       'insecure': params.get('insecure', False),
                       'custom_build_iterator': custom_build_iterator,
                       'filters': filters}

        indicators_configuration = {}

        for ind in indicators_type:
            indicators_configuration[ind] = dict(common_conf)
            indicators_configuration[ind].update({'url': url_by_type[ind]})
            indicators_configuration[ind].update({'indicator_type': ind})
            indicators_configuration[ind].update({'mapping': mapping_by_indicator_type[ind]})

        return indicators_configuration


    def build_feed_filters(params: dict) -> Dict[str, Optional[Union[str, list]]]:
        filters = {'severity.from': params.get('severity'),
                   'threat_types.values': params.get('threat_type'),
                   'confidence.from': params.get('confidence_from'),
                   'malware_family.values': params.get('malware_family', '').split(',')
                   if params.get('malware_family') else None}

        return {k: v for k, v in filters.items() if v is not None}


    def main():
        params = {k: v for k, v in demisto.params().items() if v is not None}
        parameters = demisto.params()
        filters: Dict[str, Optional[Union[str, list]]] = build_feed_filters(params)
        indicators_type: list = argToList(params.get('indicator_type', []))
        params['feed_name_to_config'] = create_fetch_configuration(indicators_type, filters, params)

        params['headers'] = {"Content-Type": "application/json",
                             'auth-token': parameters.get('api_token').get("password")}

        feed_main(params, 'iDefense Feed', 'idefense')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('iDefense Feed', 'end', __line__())
  subtype: python3
  type: python
system: true
