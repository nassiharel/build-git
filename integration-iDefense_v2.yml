category: Data Enrichment & Threat Intelligence
commonfields:
  id: iDefense_v2
  version: -1
configuration:
- defaultvalue: https://api.intelgraph.idefense.com/
  display: URL
  name: url
  required: true
  type: 0
- display: ""
  displaypassword: API Token
  hiddenusername: true
  name: api_token
  required: true
  type: 9
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: B - Usually reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: use_proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 3.2.4
    packID: iDefense
    packName: Accenture CTI
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: ACTI provides intelligence regarding security threats and vulnerabilities.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: Accenture
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [CTI.AcctManagement@accenture.com](mailto:CTI.AcctManagement@accenture.com)
  - **URL**: [https://www.accenture.com/us-en/services/security/cyber-defense](https://www.accenture.com/us-en/services/security/cyber-defense)
  ***
  Accenture CTI
  -
  To get the Accenture CTI API token, see the ACTI documentation at <https://intelgraph.idefense.com/#/docs/view#page-section-2-0> under the "Obtain API token" section.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/i-defense-v2)
display: Accenture CTI (Partner Contribution)
image: data:image/png;base64,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
name: iDefense_v2
script:
  commands:
  - arguments:
    - default: true
      description: IP address to check.
      isArray: true
      name: ip
    description: Checks the reputation of the given IP address.
    name: ip
    outputs:
    - contextPath: IP.Address
      description: The IP address that was checked.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: String
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason the vendor made that decision.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor that was used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: String
  - arguments:
    - default: true
      description: The domain to check.
      isArray: true
      name: domain
    description: Checks the reputation of the given domain.
    name: domain
    outputs:
    - contextPath: Domain.Name
      description: The name of the domain that was checked.
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: String
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason the vendor made that decision.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
  - arguments:
    - default: true
      description: The URL to check (must start with "http://").
      isArray: true
      name: url
    description: Checks the reputation of the given URL.
    name: url
    outputs:
    - contextPath: URL.Data
      description: The URL that was checked.
      type: String
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: String
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason the vendor made that decision.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
  - arguments:
    - description: Unique User ID.
      name: uuid
      required: true
    description: Get specific indicator reputation
    name: idefense-get-ioc-by-uuid
    outputs:
    - contextPath: IP.Address
      description: The IP address.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: String
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason the vendor made that decision.
      type: String
    - contextPath: Domain.Name
      description: The domain name.
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: String
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason the vendor made that decision.
      type: String
    - contextPath: URL.Data
      description: The URL.
      type: String
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: String
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason the vendor made that decision.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Reliability
      description: Reliability of the source providing the intelligence data.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
  dockerimage: demisto/python3:3.10.1.25933
  runonce: false
  script: |
    register_module_line('iDefense_v2', 'start', __line__())
    from typing import Union


    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    '''CONSTANTS'''
    DATE_FORMAT = '%Y-%m-%d %H:%M:%S'
    IDEFENSE_URL_TEMPLATE = "https://intelgraph.idefense.com/#/node/{0}/view/{1}"

    ENDPOINTS = {
        'threatindicator': '/rest/threatindicator',
        'document': '/rest/document',
        'fundamental': '/rest/fundamental/v0'
    }


    class Client(BaseClient):
        def __init__(self, input_url: str, api_key: str, verify_certificate: bool, proxy: bool, endpoint="/rest/threatindicator/v0"):
            base_url = urljoin(input_url, endpoint)
            headers = {
                "Content-Type": "application/json",
                'auth-token': api_key
            }
            super(Client, self).__init__(base_url=base_url,
                                         verify=verify_certificate,
                                         headers=headers,
                                         proxy=proxy)

        def threat_indicator_search(self, url_suffix: str, data: dict = {}) -> dict:
            return self._http_request(method='GET', url_suffix=url_suffix, params=data)


    def _validate_args(indicator_type: str, values: list) -> None:
        """
        Args:
            indicator_type: IP or URL
            values: list of values

        Returns: Raise error if value do not match to his corresponding regex

        """
        for value in values:
            if indicator_type == 'IP':
                if not re.match(ipv4Regex, value):
                    raise DemistoException("Received wrong IP value. Please check values again.")
            elif indicator_type == 'URL':
                if not re.match(urlRegex, value):
                    raise DemistoException("Received wrong URL value. Please check values again.")


    def _calculate_dbot_score(severity: int) -> int:
        """
        Calculates Dbot score according to table:
        Dbot Score   | severity
         0           | 0
         1           | 1,2
         2           | 3,4
         3           | 5,6,7
        Args:
            severity: value from 1 to 5, determined by iDefense threat indicator

        Returns:
            Calculated score
        """
        dbot_score = Common.DBotScore.NONE

        if severity > 4:
            dbot_score = Common.DBotScore.BAD
        elif severity > 2:
            dbot_score = Common.DBotScore.SUSPICIOUS
        elif severity > 0:
            dbot_score = Common.DBotScore.GOOD

        return dbot_score


    def _extract_analysis_info(res: dict, dbot_score_type: str, reliability: DBotScoreReliability) -> List[dict]:
        """
        Extract context data from http-response and create corresponding DBotScore.
        If response is empty, return empty context and a none for DBotScore object
        Args:
            res: response from http request
            indicator_value: value of indicator given as calling the command
            dbot_score_type: DBotScoreType

        Returns:
            analysis_info: dictionary contains the indicator details returned
            dbot: DBotScore regarding the specific indicator
        """

        analysis_results = []
        if res.get('total_size'):
            results_array = res.get('results', [])
            if len(results_array):
                for result_content in results_array:
                    indicator_value = result_content.get('key', '')
                    dbot_score: int = _calculate_dbot_score(result_content.get('severity', 0))
                    desc = 'Match found in iDefense database'
                    dbot = Common.DBotScore(indicator_value, dbot_score_type, 'iDefense', dbot_score, desc, reliability)
                    last_published = result_content.get('last_published', '')
                    last_published_format = parse_date_string(last_published, DATE_FORMAT)
                    last_seen = result_content.get('last_seen', '')
                    last_seen_format = parse_date_string(last_seen, DATE_FORMAT)
                    analysis_info = {
                        'Name': result_content.get('display_text', ''),
                        'DbotReputation': dbot_score,
                        'Confidence': result_content.get('confidence', 0),
                        'ThreatTypes': result_content.get('threat_types', ''),
                        'TypeOfUse': result_content.get('last_seen_as', ''),
                        'LastPublished': str(last_published_format),
                        'LastSeen': str(last_seen_format)
                    }
                    analysis_results.append({'analysis_info': analysis_info, 'dbot': dbot})

        return analysis_results


    def _check_returned_results(res: dict) -> List[str]:
        """
        Checks which indicator value founded on iDefense database.
        Args:
            res: api response

        Returns: list of indicator values that returned from api request

        """
        returned_values = []
        if res.get('total_size'):
            results_array = res.get('results', [])
            if len(results_array):
                for result_content in results_array:
                    returned_values.append(result_content.get('key', ''))
        return returned_values


    def _check_no_match_values(all_inputs: list, res: list) -> List[str]:
        """

        Args:
            all_inputs: all indicator values received from the user
            res: list of all indicator values that returned from api request

        Returns: Which indicator has no match on iDefense database

        """
        complete_values = []

        for val in all_inputs:
            if val not in res:
                complete_values.append(val)

        return complete_values


    def test_module(client: Client) -> str:
        """
        Perform basic request to check if the connection to service was successful
        Args:
            client: iDefense client

        Returns:
            'ok' if the response is ok, else will raise an error

        """

        try:
            client.threat_indicator_search(url_suffix='/v0')
            return 'ok'
        except Exception as e:
            raise DemistoException(f"Error in API call - check the input parameters and the API Key. Error: {e}.")


    def ip_command(client: Client, args: dict, reliability: DBotScoreReliability, doc_search_client: Client) -> List[CommandResults]:
        """

        Args:
            client: iDefense client
            args: arguments obtained with the command representing the indicator value to search
            reliability: reliability of the source

        Returns: CommandResults containing the indicator, the response and a readable output

        """
        ips: list = argToList(args.get('ip'))
        _validate_args("IP", ips)
        res = client.threat_indicator_search(url_suffix='/v0/ip', data={'key.values': ips})
        analysis_results = _extract_analysis_info(res, DBotScoreType.IP, reliability)
        returned_ips = _check_returned_results(res)
        no_match_values = _check_no_match_values(ips, returned_ips)
        command_results = []

        for analysis_result in analysis_results:
            analysis_info: dict = analysis_result.get('analysis_info', {})
            analysis_info = _enrich_analysis_result_with_intelligence(analysis_info, doc_search_client)
            dbot = analysis_result.get('dbot')

            readable_output = tableToMarkdown('Results', analysis_info)
            indicator = Common.IP(analysis_info.get('Name', ''), dbot)
            command_results.append(CommandResults(indicator=indicator,
                                                  raw_response=res,
                                                  readable_output=readable_output))

        for val in no_match_values:
            desc = "No results were found on iDefense database"
            dbot = Common.DBotScore(val, DBotScoreType.IP, 'iDefense', 0, desc)
            indicator = Common.IP(val, dbot)
            readable_output = f"No results were found for ip {val}"
            command_results.append(CommandResults(indicator=indicator, readable_output=readable_output))

        return command_results


    def url_command(client: Client, args: dict, reliability: DBotScoreReliability, doc_search_client: Client) -> List[CommandResults]:
        urls: list = argToList(args.get('url'))
        _validate_args("URL", urls)

        res = client.threat_indicator_search(url_suffix='/v0/url', data={'key.values': urls})
        analysis_results = _extract_analysis_info(res, DBotScoreType.URL, reliability)
        returned_urls = _check_returned_results(res)
        no_match_values = _check_no_match_values(urls, returned_urls)
        command_results = []

        for analysis_result in analysis_results:
            analysis_info: dict = analysis_result.get('analysis_info', {})
            analysis_info = _enrich_analysis_result_with_intelligence(analysis_info, doc_search_client)
            dbot = analysis_result.get('dbot')

            readable_output = tableToMarkdown('Results', analysis_info)
            indicator = Common.URL(analysis_info.get('Name', ''), dbot)

            command_results.append(CommandResults(indicator=indicator,
                                                  raw_response=res,
                                                  readable_output=readable_output))

        for val in no_match_values:
            desc = "No results were found"
            dbot = Common.DBotScore(val, DBotScoreType.URL, 'iDefense', 0, desc, reliability)
            indicator = Common.URL(val, dbot)
            readable_output = f"No results were found for url {val}"
            command_results.append(CommandResults(indicator=indicator, readable_output=readable_output))

        return command_results


    def domain_command(client: Client, args: dict, reliability: DBotScoreReliability, doc_search_client) -> List[CommandResults]:

        domains: list = argToList(args.get('domain'))

        res = client.threat_indicator_search(url_suffix='/v0/domain', data={'key.values': domains})
        analysis_results = _extract_analysis_info(res, DBotScoreType.DOMAIN, reliability)
        returned_domains = _check_returned_results(res)
        no_match_values = _check_no_match_values(domains, returned_domains)
        command_results = []

        for analysis_result in analysis_results:
            analysis_info: dict = analysis_result.get('analysis_info', {})
            analysis_info = _enrich_analysis_result_with_intelligence(analysis_info, doc_search_client)
            dbot = analysis_result.get('dbot')

            readable_output = tableToMarkdown('Results', analysis_info)
            indicator = Common.Domain(analysis_info.get('Name', ''), dbot)

            command_results.append(CommandResults(indicator=indicator,
                                                  raw_response=res,
                                                  readable_output=readable_output))

        for val in no_match_values:
            desc = "No results were found"
            dbot = Common.DBotScore(val, DBotScoreType.DOMAIN, 'iDefense', 0, desc, reliability)
            indicator = Common.Domain(val, dbot)
            readable_output = f"No results were found for Domain {val}"
            command_results.append(CommandResults(indicator=indicator, readable_output=readable_output))

        return command_results


    def uuid_command(client: Client, args: dict, reliability: DBotScoreReliability, doc_search_client: Client) -> CommandResults:
        """
        Search for indicator with the given uuid. When response return, checks which indicator found.
        Args:
            client: iDefense client
            args: arguments obtained with the command representing the value to search

        Returns:
            CommandResults containing the indicator, the response and a readable output
        """
        uuid: str = str(args.get('uuid'))
        res = {}
        try:
            res = client.threat_indicator_search(url_suffix=f'/v0/{uuid}')
        except Exception as e:
            if 'Failed to parse json object from response' in e.args[0]:
                return_results(CommandResults(indicator=None,
                                              raw_response={},
                                              readable_output=f"No results were found for uuid: {uuid}"))
            else:
                raise e

        indicator: Optional[Union[Common.IP, Common.Domain, Common.URL]] = None
        analysis_info = {}
        if len(res):
            dbot_score = _calculate_dbot_score(res.get('severity', 0))
            desc = 'Match found in IDefense database'
            indicator_value = res.get('key', '')
            indicator_type = res.get('type', '')
            # Create indicator by the uuid type returned
            if indicator_type.lower() == 'ip':
                dbot = Common.DBotScore(indicator_value, DBotScoreType.IP, 'iDefense', dbot_score, desc, reliability)
                indicator = Common.IP(indicator_value, dbot)
            elif indicator_type.lower() == 'domain':
                dbot = Common.DBotScore(indicator_value, DBotScoreType.DOMAIN, 'iDefense', dbot_score, desc, reliability)
                indicator = Common.Domain(indicator_value, dbot)
            elif indicator_type.lower() == 'url':
                dbot = Common.DBotScore(indicator_value, DBotScoreType.URL, 'iDefense', dbot_score, desc, reliability)
                indicator = Common.URL(indicator_value, dbot)
            last_published = res.get('last_published', '')
            last_published_format = parse_date_string(last_published, DATE_FORMAT)
            last_seen = res.get('last_seen', '')
            last_seen_format = parse_date_string(last_seen, DATE_FORMAT)
            analysis_info = {
                'Name': res.get('display_text', ''),
                'DbotReputation': dbot_score,
                'Confidence': res.get('confidence', 0),
                'ThreatTypes': res.get('threat_types', ''),
                'TypeOfUse': res.get('last_seen_as', ''),
                'LastPublished': str(last_published_format),
                'LastSeen': str(last_seen_format)
            }
            analysis_info = _enrich_analysis_result_with_intelligence(analysis_info, doc_search_client)

        return CommandResults(indicator=indicator,
                              raw_response=res,
                              readable_output=tableToMarkdown('Results', analysis_info))


    def _enrich_analysis_result_with_intelligence(analysis_info, doc_search_client, indicatorTypeHash: bool = False):
        """

        Adds Intelligence reports and Intelligence alerts information to analysis result for the indicator using given doc search client                                        # noqa: E501

        Args:
            analysis_result obtained from _extract_analysis_info function call
            client: ACTI Document search contoller client

        Returns:
            analysis_result enriched with intelligence alert and intelligence report information if available for the indicator

        """

        indicator = analysis_info['MD5'] if indicatorTypeHash else analysis_info['Name']
        demisto.debug(f"getting ia for indicator {indicator}")

        alerts, reports = _get_ia_for_indicator(indicator, doc_search_client)

        if alerts is not None:
            analysis_info['Intelligence Alerts'] = alerts if len(
                alerts) > 0 else 'No Intelligence Alert has been linked to this indicator'
        if reports is not None:
            analysis_info['Intelligence Reports'] = reports if len(
                reports) > 0 else 'No Intelligence Report has been linked to this indicator'

        return analysis_info


    def _get_ia_for_indicator(indicator: str, doc_search_client: Client):
        """
        Perform document controller api call with given doc search client to get
        Intelligence Alerts and Intelligence Reports for given indicator

        Args:
            client: ACTI Document search contoller client

        Returns:
            intelligence alert and intelligence report dictionaries if api has response else None

        """

        res = {}
        intelligence_alerts, intelligence_reports = None, None

        try:
            res = doc_search_client.threat_indicator_search(
                url_suffix='/v0', data={'type.values': ['intelligence_alert', 'intelligence_report'], 'links.display_text.query': indicator})                                                                       # noqa: E501

            alerts = {item['title']: item['uuid'] for item in res.get('results', []) if item['type'] == 'intelligence_alert'}
            reports = {item['title']: item['uuid'] for item in res.get('results', []) if item['type'] == 'intelligence_report'}
            intelligence_alerts = {title: IDEFENSE_URL_TEMPLATE.format('intelligence_alert', uuid) for title, uuid in alerts.items()}
            intelligence_reports = {title: IDEFENSE_URL_TEMPLATE.format(
                'intelligence_report', uuid) for title, uuid in reports.items()}

        except Exception as e:
            if 'Error in API call [403]' in e.args[0]:
                return_results(f"Intelligence Alert & Intelligence Report enrichment (if present) is not possible! As your API token is not eligible to access Document API.\n Error: {str(e)}")                                               # noqa: E501
                demisto.debug(e.args[0])
            else:
                raise e

        return intelligence_alerts, intelligence_reports


    def main():
        params = demisto.params()
        api_key = params.get('api_token')
        if isinstance(api_key, dict):  # integration version >=3.2.0
            api_key = api_key.get('password')
        base_url = urljoin(params.get('url', ''))
        reliability = params.get('integrationReliability', 'B - Usually reliable')

        if DBotScoreReliability.is_valid_type(reliability):
            reliability = DBotScoreReliability.get_dbot_score_reliability_from_str(reliability)
        else:
            Exception("IDefense error: Please provide a valid value for the Source Reliability parameter")

        commands = {
            'url': url_command,
            'ip': ip_command,
            'domain': domain_command,
            'idefense-get-ioc-by-uuid': uuid_command
        }
        verify_certificate = not params.get('insecure', False)
        proxy = params.get('use_proxy', False)

        try:
            command = demisto.command()
            client = Client(base_url, api_key, verify_certificate, proxy, endpoint=ENDPOINTS['threatindicator'])
            document_search_client = Client(base_url, api_key, verify_certificate, proxy, endpoint=ENDPOINTS['document'])
            demisto.debug(f'Command being called is {command}')
            if command == 'test-module':
                return_results(test_module(client))
            elif command in commands:
                return_results(commands[command](client, demisto.args(), reliability, document_search_client))

        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('iDefense_v2', 'end', __line__())
  subtype: python3
  type: python
system: true
