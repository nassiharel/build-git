args:
- description: A1000 classification report
  name: a1000_classification_report
  required: true
- description: A1000 full report
  name: a1000_full_report
  required: true
comment: Calculates A1000 final classification based on A1000 classification and A1000
  full reports.
commonfields:
  id: A1000FinalClassification
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 2.0.5
    packID: ReversingLabs_A1000
    packName: ReversingLabs A1000
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
dockerimage: demisto/python3:3.10.4.30607
enabled: true
engineinfo: {}
mainengineinfo: {}
name: A1000FinalClassification
outputs:
- contextPath: File.SHA256
  description: The SHA256 hash of the file.
  type: String
- contextPath: File.SHA1
  description: The SHA1 hash of the file.
  type: String
- contextPath: File.SHA512
  description: The SHA512 hash of the file.
  type: String
- contextPath: File.Name
  description: The name of the file.
  type: String
- contextPath: File.EntryID
  description: The Entry ID.
  type: String
- contextPath: File.Info
  description: Information about the file.
  type: String
- contextPath: File.Type
  description: The type of the file.
  type: String
- contextPath: File.MD5
  description: MD5 hash of the file.
  type: String
- contextPath: DBotScore.Score
  description: The actual score.
  type: Number
- contextPath: DBotScore.Type
  description: The indicator type.
  type: String
- contextPath: DBotScore.Indicator
  description: The indicator that was tested.
  type: String
- contextPath: DBotScore.Vendor
  description: The vendor used to calculate the score.
  type: String
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('A1000FinalClassification', 'start', __line__())




  import traceback

  RELIABILITY = 'C - Fairly reliable'


  def classification_to_score(classification):
      score_dict = {
          "UNKNOWN": 0,
          "KNOWN": 1,
          "SUSPICIOUS": 2,
          "MALICIOUS": 3
      }
      return score_dict.get(classification, 0)


  def overall_classification_command(args: Dict[str, Any]) -> CommandResults:
      a1000_classification_report = args.get('a1000_classification_report')
      a1000_full_report = args.get('a1000_full_report')

      if not a1000_classification_report:
          raise ValueError('A1000 classification report not specified')
      if not a1000_full_report:
          raise ValueError('A1000 full report not specified')

      cloud_classification = a1000_classification_report.get('threat_status', 'nema cloud').upper()
      a1000_results = a1000_full_report.get('results')
      a1000_result = a1000_results[0] if a1000_results else {}
      a1000_classification = a1000_result.get('threat_status', 'nema a1000').upper()

      if a1000_classification_report.get('sha1') != a1000_result.get('sha1'):
          return CommandResults(readable_output="Hash mismatch!")

      if a1000_classification == "UNKNOWN":
          overall_classification = cloud_classification
      else:
          classification_compare_score = {"MALICIOUS": 3,
                                          "SUSPICIOUS": 2,
                                          "KNOWN": 1}

          if classification_compare_score[cloud_classification] > classification_compare_score[a1000_classification]:
              overall_classification = cloud_classification
          else:
              overall_classification = a1000_classification

      markdown = f"### ReversingLabs A1000 overall classification for sha1: {a1000_classification_report.get('sha1')}:" \
                 f"\n **Threat status:** {overall_classification}\n"

      if overall_classification == "UNKNOWN":
          markdown += "**NOTE:** The file is not yet classified because this is the first time TiCloud has seen the" \
                      " file OR the file is still being analyzed. Please check the classification result later."

      d_bot_score = classification_to_score(overall_classification)
      dbot_score = Common.DBotScore(
          indicator=a1000_classification_report.get('sha1'),
          indicator_type=DBotScoreType.FILE,
          integration_name='ReversingLabs A1000',
          score=d_bot_score,
          malicious_description=overall_classification,
          reliability=RELIABILITY
      )

      common_file = Common.File(
          md5=a1000_classification_report.get('md5'),
          sha1=a1000_classification_report.get('sha1'),
          sha256=a1000_classification_report.get('sha256'),
          dbot_score=dbot_score
      )

      command_results = CommandResults(
          outputs_prefix='ReversingLabs',
          indicator=common_file,
          readable_output=markdown
      )
      return command_results


  def main():
      try:
          results = overall_classification_command(demisto.args())
          return_results(results)
      except Exception as ex:
          demisto.error(traceback.format_exc())  # print the traceback
          return_error(f'Failed to execute A1000FinalClassification. Error: {str(ex)}')


  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()

  register_module_line('A1000FinalClassification', 'end', __line__())
scripttarget: 0
subtype: python3
system: true
tags: []
type: python
