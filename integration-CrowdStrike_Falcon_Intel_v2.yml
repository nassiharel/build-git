category: Data Enrichment & Threat Intelligence
commonfields:
  id: CrowdStrike Falcon Intel v2
  version: -1
configuration:
- defaultvalue: https://api.crowdstrike.com/
  display: Server URL (e.g., https://example.net)
  name: server_url
  required: true
  type: 0
- display: Client ID
  displaypassword: Client Secret
  name: credentials
  required: true
  type: 9
- defaultvalue: high
  display: Indicator Threshold. Minimum malicious confidence from Falcon Intel to
    consider the indicator malicious.
  name: threshold
  options:
  - low
  - medium
  - high
  required: false
  type: 15
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: integrationReliability
  options:
  - A+ - 3rd party enrichment
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.0.18
    packID: CrowdStrikeIntel
    packName: CrowdStrike Falcon Intel
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: CrowdStrike Threat intelligence service integration helps organizations
  defend themselves against adversary activity by investigating incidents, and accelerating
  alert triage and response.
detaileddescription: |-
  ## CrowdStrike Falcon Intel
  To create a Client ID and Client Secret (the password for the integration), see [CrowdStrike Falcon API Client and keys](https://falcon.crowdstrike.com/support/api-clients-and-keys).
  For Cortex XSOAR versions < 6.0 the password parameter is the Client Secret.



  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/crowd-strike-falcon-intel-v2)
display: CrowdStrike Falcon Intel v2
image: data:image/png;base64,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
name: CrowdStrike Falcon Intel v2
script:
  commands:
  - arguments:
    - default: true
      description: A comma-separated list of file hashes (MD5/SHA1/SHA256) to check.
      isArray: true
      name: file
      required: true
    description: Checks the file reputation.
    name: file
    outputs:
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.Malicious.Vendor
      description: The vendor that reported the file as malicious.
      type: String
    - contextPath: File.Malicious.Description
      description: A description explaining why the file was determined to be malicious.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: FalconIntel.Indicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Value
      description: The value of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.LastUpdate
      description: The last time the indicator was updated.
      type: Date
    - contextPath: FalconIntel.Indicator.PublishDate
      description: The time the indicator was published.
      type: Date
    - contextPath: FalconIntel.Indicator.MaliciousConfidence
      description: The confidence level by which an indicator is considered to be
        malicious.
      type: String
    - contextPath: FalconIntel.Indicator.Reports
      description: The report ID for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.Actors
      description: Actors for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.MalwareFamilies
      description: A list of malware families that an indicator has been associated.
        An indicator may be associated with more than one malware family.
      type: String
    - contextPath: FalconIntel.Indicator.KillChains
      description: The point in the kill chain at which an indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.DomainTypes
      description: The domain type of domain indicators.
      type: String
    - contextPath: FalconIntel.Indicator.IPAddressTypes
      description: The address type of IP Address indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Relations.Indicator
      description: Related indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Labels
      description: Additional labels.
      type: String
  - arguments:
    - default: true
      description: A comma-separated list of URLs to check.
      isArray: true
      name: url
      required: true
    description: Checks the URL reputation.
    name: url
    outputs:
    - contextPath: URL.Data
      description: The URL.
      type: String
    - contextPath: URL.Malicious.Vendor
      description: The vendor reporting the URL as malicious.
      type: String
    - contextPath: URL.Malicious.Description
      description: A description of the malicious URL.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: FalconIntel.Indicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Value
      description: The value of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.LastUpdate
      description: The last time the indicator was updated.
      type: Date
    - contextPath: FalconIntel.Indicator.PublishDate
      description: The time the indicator was published.
      type: Date
    - contextPath: FalconIntel.Indicator.MaliciousConfidence
      description: The confidence level by which an indicator is considered to be
        malicious.
      type: String
    - contextPath: FalconIntel.Indicator.Reports
      description: The report ID for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.Actors
      description: Actors for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.MalwareFamilies
      description: A list of malware families that an indicator has been associated.
        An indicator may be associated with more than one malware family.
      type: String
    - contextPath: FalconIntel.Indicator.KillChains
      description: The point in the kill chain at which an indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.DomainTypes
      description: The domain type of domain indicators.
      type: String
    - contextPath: FalconIntel.Indicator.IPAddressTypes
      description: The address type of IP address indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Relations.Indicator
      description: Related indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The the type of indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Labels
      description: Additional labels.
      type: String
  - arguments:
    - default: true
      description: A comma-separated list of domains to check.
      isArray: true
      name: domain
      required: true
    description: Checks the domain reputation.
    name: domain
    outputs:
    - contextPath: Domain.Name
      description: The domain name. For example, "google.com".
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: The vendor reporting the domain as malicious.
      type: String
    - contextPath: Domain.Malicious.Description
      description: A description explaining why the domain was reported as malicious.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: FalconIntel.Indicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Value
      description: The value of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.LastUpdate
      description: The last time the indicator was updated.
      type: Date
    - contextPath: FalconIntel.Indicator.PublishDate
      description: The time the indicator was published.
      type: Date
    - contextPath: FalconIntel.Indicator.MaliciousConfidence
      description: The confidence level by which an indicator is considered to be
        malicious.
      type: String
    - contextPath: FalconIntel.Indicator.Reports
      description: The report ID for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.Actors
      description: Actors for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.MalwareFamilies
      description: A list of malware families that an indicator has been associated.
        An indicator may be associated with more than one malware family.
      type: String
    - contextPath: FalconIntel.Indicator.KillChains
      description: The point in the kill chain at which an indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.DomainTypes
      description: The domain type of domain indicators.
      type: String
    - contextPath: FalconIntel.Indicator.IPAddressTypes
      description: The address type of IP address indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Relations.Indicator
      description: Related indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Labels
      description: Additional labels.
      type: String
  - arguments:
    - default: true
      description: A comma-separated list of IP addresses to check.
      isArray: true
      name: ip
      required: true
    description: Checks the IP reputation.
    name: ip
    outputs:
    - contextPath: IP.Address
      description: The IP address.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: The vendor reporting the IP address as malicious.
      type: String
    - contextPath: IP.Malicious.Description
      description: A description explaining why the IP address was reported as malicious.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The type of the indicator.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: FalconIntel.Indicator.ID
      description: The indicator ID.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The indicator type.
      type: String
    - contextPath: FalconIntel.Indicator.Value
      description: The value of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.LastUpdate
      description: The last time the indicator was updated.
      type: Date
    - contextPath: FalconIntel.Indicator.PublishDate
      description: The time the indicator was published.
      type: Date
    - contextPath: FalconIntel.Indicator.MaliciousConfidence
      description: The confidence level by which an indicator is considered to be
        malicious.
      type: String
    - contextPath: FalconIntel.Indicator.Reports
      description: The report ID for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.Actors
      description: Actors for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.MalwareFamilies
      description: A list of malware families that an indicator has been associated.
        An indicator may be associated with more than one malware family.
      type: String
    - contextPath: FalconIntel.Indicator.KillChains
      description: The point in the kill chain at which an indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.DomainTypes
      description: The domain type of domain indicators.
      type: String
    - contextPath: FalconIntel.Indicator.IPAddressTypes
      description: The address type of IP address indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Relations.Indicator
      description: Related indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Labels
      description: Additional labels.
      type: String
  - arguments:
    - description: Search based on a query written in FQL (Falcon Query Language,
        See https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-fql
        for more information)..
      name: query
    - description: Search across all fields in an actor object.
      name: free_search
    - description: Search based on an actor's name.
      name: name
    - description: Search based on a description.
      name: description
    - description: 'Search from the created date. Supported formats: ISO 8601 (for
        example, 2020-07-28T10:00:00Z) and time period (for example, 24 hours).'
      name: created_date
    - description: 'Search up to the last modified date. Supported formats: ISO 8601
        (for example, 2020-07-28T10:00:00Z) and time period (for example, 24 hours).'
      name: max_last_modified_date
    - description: 'Search from the last activity date. Supported formats: ISO 8601
        (for example, 2020-07-28T10:00:00Z) and time period (for example, 24 hours).'
      name: min_last_activity_date
    - description: 'Search up to the last activity date. Supported formats: ISO 8601
        (for example, 2020-07-28T10:00:00Z) and time period (for example, 24 hours).'
      name: max_last_activity_date
    - description: Search by origins, separated by ",".
      isArray: true
      name: origins
    - description: Search by target countries, separated by ",".
      isArray: true
      name: target_countries
    - description: Search by target industries, separated by ",".
      isArray: true
      name: target_industries
    - description: Search by motivations, separated by ",".
      isArray: true
      name: motivations
    - description: The page of the results to retrieve. It is 0 based.
      name: offset
    - default: true
      defaultValue: "10"
      description: The maximum number of actors to retrieve. The default is 10.
      name: limit
    - auto: PREDEFINED
      description: Sort by field and direction. Select a pre-defined value and direction.
        For example, for ascending list of names, "name|asc", for descending list
        of names, "name|desc".
      name: sort
      predefined:
      - name|asc
      - name|desc
      - target_countries|asc
      - target_countries|desc
      - target_industries|asc
      - target_industries|desc
      - type|asc
      - type|desc
      - created_date|asc
      - created_date|desc
      - last_activity_date|asc
      - last_activity_date|desc
      - last_modified_date|asc
      - last_modified_date|desc
    - description: Search by 'slug' or short descriptive name. For example, "anchor-panda"
      name: slug
    description: Search known actors based on the given parameters.
    name: cs-actors
    outputs:
    - contextPath: FalconIntel.Actor.ImageURL
      description: The URL of the actor image.
      type: String
    - contextPath: FalconIntel.Actor.Name
      description: The name of the actor.
      type: String
    - contextPath: FalconIntel.Actor.ID
      description: The ID of the actor.
      type: String
    - contextPath: FalconIntel.Actor.URL
      description: The URL of the actor.
      type: String
    - contextPath: FalconIntel.Actor.Slug
      description: The slug name of the actor.
      type: String
    - contextPath: FalconIntel.Actor.ShortDescription
      description: The short description of the actor.
      type: String
    - contextPath: FalconIntel.Actor.FirstActivityDate
      description: The first activity date of the actor.
      type: Date
    - contextPath: FalconIntel.Actor.LastActivityDate
      description: The last activity date of the actor.
      type: Date
    - contextPath: FalconIntel.Actor.Active
      description: The active status of the actor.
      type: Boolean
    - contextPath: FalconIntel.Actor.KnowsAs
      description: Nicknames that the actor is known as.
      type: String
    - contextPath: FalconIntel.Actor.TargetIndustries
      description: A list of targeted industries associated with this actor.
      type: String
    - contextPath: FalconIntel.Actor.TargetCountries
      description: A list of targeted countries associated with this actor.
      type: String
    - contextPath: FalconIntel.Actor.Origins
      description: The actor's country of origin. For example, Afghanistan.
      type: String
    - contextPath: FalconIntel.Actor.Motivations
      description: The actor's motivations. For example, Criminal.
      type: String
    - contextPath: FalconIntel.Actor.Capability
      description: The actor's capability. For example, Average.
      type: String
    - contextPath: FalconIntel.Actor.Group
      description: The the group of the actor. For example, panda gang.
      type: String
    - contextPath: FalconIntel.Actor.Region
      description: The region of the actor. For example, Eastern Europe.
      type: String
    - contextPath: FalconIntel.Actor.KillChains
      description: Kill chain fields.
      type: String
  - arguments:
    - description: Search based on a query written in FQL (Falcon Query Language,
        See https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-fql
        for more information)..
      name: query
    - auto: PREDEFINED
      description: The indicator type. Add a pre-defined value, such as email_address,
        hash_ion, password, etc.
      name: type
      predefined:
      - binary_string
      - compile_time
      - device_name
      - domain
      - email_address
      - email_subject
      - event_name
      - file_mapping
      - file_name
      - file_path
      - hash_ion
      - hash_md5
      - hash_sha1
      - hash_sha256
      - ip_address
      - ip_address_block
      - mutex_name
      - password
      - persona_name
      - phone_number
      - port
      - registry
      - semaphore_name
      - service_name
      - url
      - user_agent
      - username
      - x509_seria
      - x509_subject
    - auto: PREDEFINED
      description: Indicates a confidence level by which an indicator is considered
        to be malicious. Can be "high", "medium", "low", or "unverified".
      name: malicious_confidence
      predefined:
      - high
      - medium
      - low
      - unverified
    - description: Used to paginate the response. You can then use limit to set the
        number of results for the next page.
      name: offset
    - description: 'The date the indicator was last updated. Supported formats: ISO
        8601 (for example, 2020-07-28T10:00:00Z) and time period (for example, 24
        hours).'
      name: last_updated_date
    - description: The value for the given indicator type.
      name: indicator
    - auto: PREDEFINED
      description: Sort by field and direction. Select a pre-defined value and direction.
        For example, for ascending list of IDs, "id|asc", for descending list of IDs,
        "id|desc".
      name: sort
      predefined:
      - id|asc
      - id|desc
      - indicator|asc
      - indicator|desc
      - type|asc
      - type|desc
      - published_date|asc
      - published_date|desc
      - last_updated|asc
      - last_updated|desc
    - description: 'The indicator''s ID, in the following format: <type>_<indicator>.'
      name: id
    - default: true
      defaultValue: "10"
      description: The maximum number of indicators to retrieve. The default is 10.
      name: limit
    description: Search known indicators based on the given parameters.
    name: cs-indicators
    outputs:
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.Malicious.Vendor
      description: The vendor that reported the file as malicious.
      type: String
    - contextPath: File.Malicious.Description
      description: A description explaining why the file was determined to be malicious.
      type: String
    - contextPath: File.Reports
      description: For malicious files, the associated reports describing the hash.
      type: String
    - contextPath: File.Actors
      description: For malicious files, the associated actors.
      type: String
    - contextPath: File.MalwareFamilies
      description: For malicious files, the associated malware family.
      type: String
    - contextPath: File.KillChains
      description: For malicious files, the associated kill chain.
      type: String
    - contextPath: URL.Data
      description: The URL
      type: String
    - contextPath: URL.Malicious.Vendor
      description: The vendor reporting the URL as malicious.
      type: String
    - contextPath: URL.Malicious.Description
      description: A description of the malicious URL.
      type: String
    - contextPath: URL.Reports
      description: For malicious URL, the associated reports describing the URL.
      type: String
    - contextPath: URL.Actors
      description: For malicious URL, the associated actors.
      type: String
    - contextPath: URL.MalwareFamilies
      description: For malicious URL, the associated malware family.
      type: String
    - contextPath: URL.KillChains
      description: For malicious URL, the associated kill chain.
      type: String
    - contextPath: Domain.Name
      description: The domain name. For example, "google.com".
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: The vendor reporting the domain as malicious.
      type: String
    - contextPath: Domain.Malicious.Description
      description: A description explaining why the domain was reported as malicious.
      type: String
    - contextPath: Domain.Reports
      description: For a malicious domain, the associated reports describing the domain.
      type: String
    - contextPath: Domain.Actors
      description: For a malicious domain, the associated actors.
      type: String
    - contextPath: Domain.MalwareFamilies
      description: For a malicious domain, the associated malware family.
      type: String
    - contextPath: Domain.KillChains
      description: For a malicious domain, the associated kill chain.
      type: String
    - contextPath: IP.Address
      description: The IP address.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: The vendor reporting the IP address as malicious.
      type: String
    - contextPath: IP.Malicious.Description
      description: A description explaining why the IP address was reported as malicious.
      type: String
    - contextPath: IP.Reports
      description: For a malicious IP address, the associated reports describing the
        IP address.
      type: String
    - contextPath: IP.Actors
      description: For a malicious IP address, the associated actors.
      type: String
    - contextPath: IP.MalwareFamilies
      description: For a malicious IP address, the associated malware family
      type: String
    - contextPath: IP.KillChains
      description: For a malicious IP address, the associated kill chain.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator tested.
      type: String
    - contextPath: DBotScore.Type
      description: The type of the indicator.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: FalconIntel.Indicator.ID
      description: The ID of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Value
      description: The value of the indicator.
      type: String
    - contextPath: FalconIntel.Indicator.LastUpdate
      description: The last time the indicator was updated.
      type: Date
    - contextPath: FalconIntel.Indicator.PublishDate
      description: The time the indicator was published.
      type: Date
    - contextPath: FalconIntel.Indicator.MaliciousConfidence
      description: The confidence level by which an indicator is considered to be
        malicious.
      type: String
    - contextPath: FalconIntel.Indicator.Reports
      description: The report ID for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.Actors
      description: Actors for which the indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.MalwareFamilies
      description: A list of malware families that an indicator has been associated.
        An indicator may be associated with more than one malware family.
      type: String
    - contextPath: FalconIntel.Indicator.KillChains
      description: The point in the kill chain at which an indicator is associated.
      type: String
    - contextPath: FalconIntel.Indicator.DomainTypes
      description: The domain type of domain indicators.
      type: String
    - contextPath: FalconIntel.Indicator.IPAddressTypes
      description: The address type of IP address indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Relations.Indicator
      description: Related indicators.
      type: String
    - contextPath: FalconIntel.Indicator.Type
      description: The type of indicator.
      type: String
    - contextPath: FalconIntel.Indicator.Labels
      description: Additional labels.
      type: String
  - arguments:
    - description: Search based on a query written in FQL (Falcon Query Language,
        See https://falcon.crowdstrike.com/support/documentation/45/falcon-query-language-fql
        for more information).
      name: query
    - description: Search across all fields in a report object.
      name: free_search
    - description: Search for keywords across report names (for example, the report’s
        title).
      name: name
    - description: Search for a report related to particular actors. Actors should
        be comma separated. For example, actor1,actor2, etc.
      isArray: true
      name: actors
    - description: Search reports by targeted country/countries.
      isArray: true
      name: target_countries
    - description: Search reports by targeted industry/industries.
      isArray: true
      name: target_industries
    - description: Search by motivation.
      isArray: true
      name: motivations
    - description: Search by report 'slug' or short descriptive name.
      name: slug
    - description: Search the body of the report.
      name: description
    - auto: PREDEFINED
      description: The type of object for which to search. Can be "intelligence report",
        "alert", "periodic report", or "tipper".
      name: type
      predefined:
      - intelligence report
      - alert
      - periodic report
      - tipper
    - auto: PREDEFINED
      description: The report sub-type to search. Can be "weekly", "monthly", "quarterly",
        or "annual".
      name: sub_type
      predefined:
      - weekly
      - monthly
      - quarterly
      - annual
    - description: Tags associated with a report (managed internally by CrowdStrike).
      name: tags
    - description: 'Search for reports created on a certain date. Supported formats:
        ISO 8601 (for example, 2020-07-28T10:00:00Z) and time period (for example,
        24 hours).'
      name: created_date
    - description: 'Search for reports modified on or before a certain date. Supported
        formats: ISO 8601 (for example, 2020-07-28T10:00:00Z) and time period (for
        example, 24 hours).'
      name: max_last_modified_date
    - description: Used to paginate the response. You can then use limit to set the
        number of results for the next page.
      name: offset
    - default: true
      defaultValue: "10"
      description: The maximum number of reports to retrieve. The default is 10.
      name: limit
    - auto: PREDEFINED
      description: Sort by field and direction. Select a pre-defined value and direction.
        For example, for ascending list of types, "type|asc", for descending list
        of types, "types|desc".
      name: sort
      predefined:
      - id|asc
      - id|desc
      - name|asc
      - name|desc
      - type|asc
      - type|desc
      - target_countries|asc
      - target_countries|desc
      - target_industries|asc
      - target_industries|desc
      - created_date|asc
      - created_date|desc
      - last_modified_date|asc
      - last_modified_date|desc
    description: Queries CrowdStrike intelligence publications.
    name: cs-reports
    outputs:
    - contextPath: FalconIntel.Report.ID
      description: The ID of the report.
      type: String
    - contextPath: FalconIntel.Report.URL
      description: The URL of the report.
      type: String
    - contextPath: FalconIntel.Report.Name
      description: The name of the report.
      type: String
    - contextPath: FalconIntel.Report.Type
      description: The type of report.
      type: String
    - contextPath: FalconIntel.Report.SubType
      description: The sub type of the report.
      type: String
    - contextPath: FalconIntel.Report.Slug
      description: The slug name of the report.
      type: String
    - contextPath: FalconIntel.Report.CreatedDate
      description: The date the report was created.
      type: Date
    - contextPath: FalconIntel.Report.LastModifiedSate
      description: The date the report was last modified.
      type: Date
    - contextPath: FalconIntel.Report.ShortDescription
      description: The short description of the report.
      type: String
    - contextPath: FalconIntel.Report.TargetIndustries
      description: Targeted industries included in the report. For example, aerospace.
      type: String
    - contextPath: FalconIntel.Report.TargetCountries
      description: Targeted countries included in the report. For example, afghanistan.
      type: String
    - contextPath: FalconIntel.Report.Motivations
      description: Motivations included in the report. For example, criminal.
      type: String
    - contextPath: FalconIntel.Report.Tags
      description: The report's tags. For example, intel_feed.
      type: String
  dockerimage: demisto/python3:3.10.5.31928
  runonce: false
  script: |
    register_module_line('CrowdStrike Falcon Intel v2', 'start', __line__())



    from datetime import datetime, timezone
    from typing import Union, Any, Dict
    from dateparser import parse

    import urllib3
    import traceback

    # Disable insecure warnings
    urllib3.disable_warnings()

    ''' GLOBAL VARIABLES '''

    MALICIOUS_DICTIONARY: Dict[Any, int] = {
        'low': Common.DBotScore.GOOD,
        'medium': Common.DBotScore.SUSPICIOUS,
        'high': Common.DBotScore.BAD
    }

    MALICIOUS_THRESHOLD = MALICIOUS_DICTIONARY.get(demisto.params().get('threshold', 'high'))

    ''' CLIENT '''


    class Client:
        """
        The integration's client
        """

        def __init__(self, params: Dict[str, str], reliability: Optional[DBotScoreReliability] = None):
            self.cs_client: CrowdStrikeClient = CrowdStrikeClient(params=params)
            self.reliability = reliability
            self.query_params: Dict[str, str] = {'offset': 'offset', 'limit': 'limit', 'sort': 'sort', 'free_search': 'q'}
            self.date_params: Dict[str, Dict[str, str]] = {
                'created_date': {'operator': '', 'api_key': 'created_date'},
                'last_updated_date': {'operator': '', 'api_key': 'last_updated'},
                'max_last_modified_date': {'operator': '<=', 'api_key': 'last_modified_date'},
                'min_last_activity_date': {'operator': '>=', 'api_key': 'first_activity_date'},
                'max_last_activity_date': {'operator': '<=', 'api_key': 'last_activity_date'},
            }

        def build_request_params(self, args: Dict[str, Any]) -> Dict[str, Any]:
            """
            Build the params dict for the request
            :param args: Cortex XSOAR args
            :return: The params dict
            """
            params: Dict[str, Any] = {key: args.get(arg) for arg, key in self.query_params.items()}
            query = args.get('query')
            params['filter'] = query if query else self.build_filter_query(args)
            return assign_params(**params)

        def build_filter_query(self, args: Dict[str, str]) -> str:
            """
            Builds the filter query in Falcon Query Language (FQL)
            :param args: Cortex XSOAR args
            :return: The query
            """
            filter_query: str = str()

            for key in args:
                if key not in self.query_params:
                    if key not in self.date_params:
                        values: List[str] = argToList(args[key], ',')
                        for value in values:
                            filter_query += f"{key}:'{value}'+"
                    else:
                        operator: Optional[str] = self.date_params.get(key, {}).get('operator')
                        api_key: Optional[str] = self.date_params.get(key, {}).get('api_key')
                        # Parsing date argument of ISO format or free language into datetime object,
                        # replacing TZ with UTC, taking its timestamp format and rounding it up.
                        parsed_date = parse(args[key])
                        assert parsed_date is not None
                        filter_query += f"{api_key}:" \
                                        f"{operator}{int(parsed_date.replace(tzinfo=timezone.utc).timestamp())}+"

            if filter_query.endswith('+'):
                filter_query = filter_query[:-1]

            return filter_query

        def get_indicator(self, indicator_value: str) -> Dict[str, Any]:
            # crowdstrike do not allow passing single quotes - so we encode them
            # we are not encoding the entire indicator value, as the other reserved chars (such as + and &) are allowed
            indicator_value = indicator_value.replace("'", "%27")
            args: Dict[str, Any] = {
                'indicator': indicator_value,
                'limit': 1
            }
            params: Dict[str, Any] = self.build_request_params(args)
            return self.cs_client.http_request(method='GET', url_suffix='intel/combined/indicators/v1', params=params)

        def cs_actors(self, args: Dict[str, str]) -> Dict[str, Any]:
            params: Dict[str, Any] = self.build_request_params(args)
            return self.cs_client.http_request(method='GET', url_suffix='intel/combined/actors/v1', params=params)

        def cs_indicators(self, args: Dict[str, str]) -> Dict[str, Any]:
            params: Dict[str, Any] = self.build_request_params(args)
            return self.cs_client.http_request(method='GET', url_suffix='intel/combined/indicators/v1', params=params)

        def cs_reports(self, args: Dict[str, str]) -> Dict[str, Any]:
            params: Dict[str, Any] = self.build_request_params(args)
            return self.cs_client.http_request(method='GET', url_suffix='intel/combined/reports/v1', params=params)


    ''' HELPER FUNCTIONS '''


    def get_dbot_score_type(indicator_type: str) -> Union[Exception, DBotScoreType, str]:
        """
        Returns the dbot score type
        :param indicator_type: The indicator type
        :return: The dbot score type
        """
        if indicator_type == 'ip':
            return DBotScoreType.IP
        elif indicator_type == 'domain':
            return DBotScoreType.DOMAIN
        elif indicator_type == 'file' or indicator_type == 'hash':
            return DBotScoreType.FILE
        elif indicator_type == 'url':
            return DBotScoreType.URL
        else:
            raise DemistoException('Indicator type is not supported.')


    def get_score_from_resource(r: Dict[str, Any]) -> int:
        """
        Calculates the DBotScore for the resource
        :param r: The resource
        :return: The DBotScore
        """
        malicious_confidence: int = MALICIOUS_DICTIONARY.get(r.get('malicious_confidence'), 0)
        if malicious_confidence == 3 or MALICIOUS_THRESHOLD == 1:
            score = 3
        elif malicious_confidence == 2 or MALICIOUS_THRESHOLD == 2:
            score = 2
        else:
            score = 1
        return score


    def get_indicator_hash_type(indicator_value: str) -> Union[str, Exception]:
        """
        Calculates the type of the hash
        :param indicator_value: The hash value
        :return: The hash type
        """
        length: int = len(indicator_value)
        if length == 32:
            return 'hash_md5'
        elif length == 40:
            return 'hash_sha1'
        elif length == 64:
            return 'hash_sha256'
        else:
            raise DemistoException(f'Invalid hash. Hash length is: {length}. Please provide either MD5 (32 length)'
                                   f', SHA1 (40 length) or SHA256 (64 length) hash.')


    def get_indicator_object(indicator_value: Any, indicator_type: str, dbot_score: Common.DBotScore) \
            -> Union[Common.IP, Common.URL, Common.File, Common.Domain, None]:
        """
        Returns the corresponding indicator common object
        :param indicator_value: The indicator value
        :param indicator_type: The indicator value
        :param dbot_score: The indicator DBotScore
        :return: The indicator common object
        """
        if indicator_type == 'ip':
            return Common.IP(
                ip=indicator_value,
                dbot_score=dbot_score
            )
        elif indicator_type == 'url':
            return Common.URL(
                url=indicator_value,
                dbot_score=dbot_score
            )
        elif indicator_type == 'hash':
            hash_type: Union[str, Exception] = get_indicator_hash_type(indicator_value)
            if hash_type == 'hash_md5':
                return Common.File(
                    md5=indicator_value,
                    dbot_score=dbot_score
                )
            elif hash_type == 'hash_sha1':
                return Common.File(
                    sha1=indicator_value,
                    dbot_score=dbot_score
                )
            else:
                return Common.File(
                    sha256=indicator_value,
                    dbot_score=dbot_score
                )
        elif indicator_type == 'domain':
            return Common.Domain(
                domain=indicator_value,
                dbot_score=dbot_score
            )
        else:
            return None


    def should_filter_resource_by_type(resource, indicator_type, indicator_value):
        """
        checks if a resource should be filtered by his type.
        :param resource: The resource object
        :param indicator_type: The indicator type
        :param indicator_value: The indicator value
        :return: True if the resource should be filtered (don't match the indicator type) or False otherwise.
        """
        # indicator type was not filtered using the query due to a bug in the CrowdStrike API.
        if indicator_type == 'hash':
            filter_type = get_indicator_hash_type(indicator_value)
        elif indicator_type == 'ip':
            filter_type = 'ip_address'
        else:
            filter_type = indicator_type

        return resource.get('type') != filter_type


    def build_indicator(indicator_value: str, indicator_type: str, title: str, client: Client) -> List[CommandResults]:
        """
        Builds an indicator entry
        :param indicator_value: The indicator value
        :param indicator_type: The indicator type
        :param title: The title to show to the user
        :param client: The integration's client
        :return: The indicator entry
        """
        res: Dict[str, Any] = client.get_indicator(indicator_value)
        resources: List[Any] = res.get('resources', [])
        results: List[CommandResults] = []

        if resources:
            for r in resources:
                if should_filter_resource_by_type(r, indicator_type, indicator_value):
                    continue
                output = get_indicator_outputs(r)
                score = get_score_from_resource(r)
                dbot_score = Common.DBotScore(
                    indicator=indicator_value,
                    indicator_type=get_dbot_score_type(indicator_type),
                    integration_name='CrowdStrike Falcon Intel v2',
                    malicious_description='High confidence',
                    score=score,
                    reliability=client.reliability
                )
                indicator = get_indicator_object(indicator_value, indicator_type, dbot_score)
                results.append(CommandResults(
                    outputs=output,
                    outputs_prefix='FalconIntel.Indicator',
                    outputs_key_field='ID',
                    indicator=indicator,
                    readable_output=tableToMarkdown(name=title, t=output, headerTransform=pascalToSpace),
                    raw_response=res
                ))

        else:
            results.append(create_indicator_result_with_dbotscore_unknown(indicator=indicator_value,
                                                                          indicator_type=DBotScoreType.FILE
                                                                          if indicator_type == 'hash' else indicator_type))

        return results


    def get_values(items_list: List[Any], return_type: str = 'str', keys: Union[str, List[Any]] = 'value') \
            -> Union[str, List[Union[str, Dict]]]:
        """
        Returns the values of list's items
        :param items_list: The items list
        :param return_type: Whether to return string or list
        :param keys: The key to get the data
        :return: The values list
        """
        new_list: List[Any] = list()
        if isinstance(keys, str):
            new_list = [item.get(keys) for item in items_list]
        elif isinstance(keys, list):
            new_list = [{underscoreToCamelCase(f): item.get(f) for f in item if f in keys} for item in items_list]
        if return_type == 'list':
            return new_list
        return ', '.join(str(item) for item in new_list)


    def get_indicator_outputs(resource: Dict[str, Any]) -> Dict[str, Any]:
        """
        Build the output and extra context of an indicator
        :param resource: The indicator's object
        :return: The indicator's human readable
        """
        output: Dict[str, Any] = dict()

        if resource:
            indicator_id = resource.get('id')
            indicator_value = resource.get('indicator')
            indicator_type = resource.get('type')
            last_update = resource.get('last_update')
            publish_date = resource.get('publish_date')
            malicious_confidence = resource.get('malicious_confidence')
            reports = resource.get('reports')
            actors = resource.get('actors')
            malware_families = resource.get('malware_families')
            kill_chains = resource.get('kill_chains')
            domain_types = resource.get('domain_types')
            ip_address_types = resource.get('ip_address_types')
            relations: List[Any] = resource.get('relations', [])[:10]
            labels: List[Any] = resource.get('labels', [])[:10]

            output = assign_params(**{
                'ID': indicator_id,
                'Type': indicator_type,
                'Value': indicator_value,
                'LastUpdate': datetime.fromtimestamp(last_update, timezone.utc).isoformat() if last_update
                else None,
                'PublishDate': datetime.fromtimestamp(publish_date, timezone.utc).isoformat() if publish_date
                else None,
                'MaliciousConfidence': malicious_confidence,
                'Reports': reports,
                'Actors': actors,
                'MalwareFamilies': malware_families,
                'KillChains': kill_chains,
                'DomainTypes': domain_types,
                'IPAddressTypes': ip_address_types,
                'Relations': [f'{item.get("Type")}: {item.get("Indicator")}' for item in  # type: ignore
                              get_values(relations, return_type='list', keys=['indicator', 'type'])],
                'Labels': get_values(labels, return_type='list', keys='name')
            })

        return output


    ''' COMMANDS '''


    def run_test_module(client: Client) -> Union[str, Exception]:
        """
        If a client is successfully constructed then an access token was successfully created,
        therefore the username and password are valid and a connection was made.
        On top of the above, this function validates the http request to indicators endpoint.
        :param client: the client object with an access token
        :return: ok if got a valid access token and not all the quota is used at the moment
        """
        client.cs_client.http_request('GET', 'intel/combined/indicators/v1', params={'limit': 1})
        return 'ok'


    def file_command(files: List, client: Client) -> List[CommandResults]:
        results: List[CommandResults] = []
        for file in files:
            results += build_indicator(file, 'hash', 'Falcon Intel file reputation:\n', client)
        return results


    def ip_command(ips: List, client: Client) -> List[CommandResults]:
        results: List[CommandResults] = []
        for ip in ips:
            results += build_indicator(ip, 'ip', 'Falcon Intel IP reputation:\n', client)
        return results


    def url_command(urls: List, client: Client) -> List[CommandResults]:
        results: List[CommandResults] = []
        for url in urls:
            results += build_indicator(url, 'url', 'Falcon Intel URL reputation:\n', client)
        return results


    def domain_command(domains: List, client: Client) -> List[CommandResults]:
        results: List[CommandResults] = []
        for domain in domains:
            results += build_indicator(domain, 'domain', 'Falcon Intel domain reputation:\n', client)
        return results


    def cs_actors_command(client: Client, args: Dict[str, str]) -> CommandResults:
        res: Dict[str, Any] = client.cs_actors(args)
        resources: List[Any] = res.get('resources', [])
        outputs: List[Dict[str, Any]] = list()
        md_outputs: List[Dict[str, Any]] = list()
        md: str = str()
        title: str = 'Falcon Intel Actor search:'

        if resources:
            for r in resources:
                image_url = r.get('image', {}).get('url')
                name = r.get('name')
                actor_id = r.get('id')
                url = r.get('url')
                slug = r.get('slug')
                short_description = r.get('short_description')
                first_activity_date = r.get('first_activity_date')
                last_activity_date = r.get('last_activity_date')
                active = r.get('active')
                known_as = r.get('known_as')
                target_industries = r.get('target_industries', [])
                target_countries = r.get('target_countries', [])
                origins = r.get('origins', [])
                motivations = r.get('motivations', [])
                capability = r.get('capability', {}).get('value')
                group = r.get('group')
                region = r.get('region', {}).get('value')
                kill_chain = r.get('kill_chain')

                output: Dict[str, Any] = assign_params(**{
                    'ImageURL': image_url,
                    'Name': name,
                    'ID': actor_id,
                    'URL': url,
                    'Slug': slug,
                    'ShortDescription': short_description,
                    'FirstActivityDate': datetime.fromtimestamp(first_activity_date, timezone.utc).isoformat()
                    if first_activity_date else None,
                    'LastActivityDate': datetime.fromtimestamp(last_activity_date, timezone.utc).isoformat()
                    if last_activity_date else None,
                    'Active': active,
                    'KnownAs': known_as,
                    'TargetIndustries': get_values(target_industries, return_type='list'),
                    'TargetCountries': get_values(target_countries, return_type='list'),
                    'Origins': get_values(origins, return_type='list'),
                    'Motivations': get_values(motivations, return_type='list'),
                    'Capability': capability,
                    'Group': group,
                    'Region': region,
                    'KillChains': kill_chain
                })
                outputs.append(output)

                md_output: Dict[str, Any] = output
                for key in ('URL', 'ImageURL'):
                    if key in md_output:
                        value = md_output[key]
                        md_output[key] = f'[{value}]({value})'

                md_outputs.append(md_output)
        else:
            md = 'No actors found.'

        results: CommandResults = CommandResults(
            outputs=outputs,
            outputs_key_field='ID',
            outputs_prefix='FalconIntel.Actor',
            readable_output=md if md else tableToMarkdown(name=title, t=md_outputs, headerTransform=pascalToSpace),
            raw_response=res
        )

        return results


    def cs_indicators_command(client: Client, args: Dict[str, str]) -> List[CommandResults]:
        res: Dict[str, Any] = client.cs_indicators(args)
        resources: List[Any] = res.get('resources', [])
        results: List[CommandResults] = []
        title: str = 'Falcon Intel Indicator search:'

        if resources:
            for r in resources:
                output = get_indicator_outputs(r)
                indicator_value = output.get('Value')
                indicator_type = output.get('Type')
                indicator: Optional[Common.Indicator] = None

                if indicator_type in ('hash_md5', 'hash_sha256', 'hash_sha1', 'ip_address', 'url', 'domain'):
                    if indicator_type in ('hash_md5', 'hash_sha1', 'hash_sha256'):
                        indicator_type = 'hash'
                    elif indicator_type == 'ip_address':
                        indicator_type = 'ip'
                    score = get_score_from_resource(r)
                    dbot_score = Common.DBotScore(
                        indicator=indicator_value,
                        indicator_type=get_dbot_score_type(indicator_type),
                        integration_name='CrowdStrike Falcon Intel v2',
                        malicious_description='High confidence',
                        score=score,
                        reliability=client.reliability
                    )
                    indicator = get_indicator_object(indicator_value, indicator_type, dbot_score)
                results.append(CommandResults(
                    outputs=output,
                    outputs_prefix='FalconIntel.Indicator',
                    outputs_key_field='ID',
                    readable_output=tableToMarkdown(name=title, t=output, headerTransform=pascalToSpace),
                    raw_response=res,
                    indicator=indicator
                ))
        else:
            results.append(CommandResults(
                readable_output='No indicators found.'
            ))

        return results


    def cs_reports_command(client: Client, args: Dict[str, str]) -> CommandResults:
        res: Dict[str, Any] = client.cs_reports(args)
        resources: List[Any] = res.get('resources', [])
        outputs: List[Dict[str, Any]] = list()
        md_outputs: List[Dict[str, Any]] = list()
        md: str = str()
        title: str = 'Falcon Intel Report search:'

        if resources:
            for r in resources:
                report_id: int = r.get('id')
                url: str = r.get('url')
                name: str = r.get('name')
                report_type: str = r.get('type', {}).get('name')
                sub_type: str = r.get('sub_type', {}).get('name')
                slug: str = r.get('slug')
                created_date: int = r.get('created_date')
                last_modified_date: int = r.get('last_modified_date')
                short_description: str = r.get('short_description')
                target_industries: List[Any] = r.get('target_industries', [])
                target_countries: List[Any] = r.get('target_countries', [])
                motivations: List[Any] = r.get('motivations', [])
                tags: List[Any] = r.get('tags', [])
                actors: List[Any] = r.get('actors', [])

                output: Dict[str, Any] = assign_params(**{
                    'ID': report_id,
                    'URL': url,
                    'Name': name,
                    'Type': report_type,
                    'SubType': sub_type,
                    'Slug': slug,
                    'CreatedDate': datetime.fromtimestamp(created_date, timezone.utc).isoformat()
                    if created_date else None,
                    'LastModifiedSate': datetime.fromtimestamp(last_modified_date, timezone.utc).isoformat()
                    if last_modified_date else None,
                    'ShortDescription': short_description,
                    'TargetIndustries': get_values(target_industries, return_type='list'),
                    'TargetCountries': get_values(target_countries, return_type='list'),
                    'Motivations': get_values(motivations, return_type='list'),
                    'Tags': get_values(tags, return_type='list'),
                    'Actors': get_values(actors, return_type='list', keys='name')
                })
                outputs.append(output)

                md_output: Dict[str, Any] = output
                if 'URL' in md_output:
                    value = md_output['URL']
                    md_output['URL'] = f'[{value}]({value})'

                md_outputs.append(md_output)

        else:
            md = 'No reports found.'

        results: CommandResults = CommandResults(
            outputs_prefix='FalconIntel.Report',
            outputs=outputs,
            outputs_key_field='ID',
            readable_output=md if md else tableToMarkdown(name=title, t=outputs, headerTransform=pascalToSpace),
            raw_response=res
        )

        return results


    def main():
        params: Dict[str, str] = demisto.params()

        reliability = params.get('integrationReliability', 'C - Fairly reliable')
        reliability = DBotScoreReliability.get_dbot_score_reliability_from_str(reliability) if \
            DBotScoreReliability.is_valid_type(reliability) else None

        args: Dict[str, str] = demisto.args()
        results: Union[CommandResults, List[CommandResults]]
        try:
            command: str = demisto.command()
            LOG(f'Command being called in CrowdStrike Falcon Intel v2 is: {command}')
            client: Client = Client(params=params, reliability=reliability)
            if command == 'test-module':
                result: Union[str, Exception] = run_test_module(client)
                return_results(result)
            elif command == 'file':
                results = file_command(argToList(args['file']), client)
                return_results(results)
            elif command == 'ip':
                results = ip_command(argToList(args['ip']), client)
                return_results(results)
            elif command == 'url':
                results = url_command(argToList(args['url']), client)
                return_results(results)
            elif command == 'domain':
                results = domain_command(argToList(args['domain']), client)
                return_results(results)
            elif command == 'cs-actors':
                results = cs_actors_command(client, args)
                return_results(results)
            elif command == 'cs-indicators':
                results = cs_indicators_command(client, args)
                return_results(results)
            elif command == 'cs-reports':
                results = cs_reports_command(client, args)
                return_results(results)
            else:
                raise NotImplementedError(f'{command} command is not an existing CrowdStrike Falcon Intel v2 integration')
        except Exception as err:
            return_error(f'Unexpected error:\n{str(err)}', error=traceback.format_exc())



    ### GENERATED CODE ###: from CrowdStrikeApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('CrowdStrikeApiModule', 'start', __line__(), wrapper=-3)


    from datetime import timedelta
    import dateparser

    TOKEN_LIFE_TIME = timedelta(minutes=28)


    class CrowdStrikeClient(BaseClient):

        def __init__(self, params):
            """
            CrowdStrike Client class that implements OAuth2 authentication.
            Args:
                params: Demisto params
            """
            credentials = params.get('credentials', {})
            self._client_id = credentials.get('identifier')
            self._client_secret = credentials.get('password')
            super().__init__(base_url=params.get('server_url', 'https://api.crowdstrike.com/'),
                             verify=not params.get('insecure', False), ok_codes=tuple(),
                             proxy=params.get('proxy', False))  # type: ignore[misc]
            self._token = self._get_token()
            self._headers = {'Authorization': 'bearer ' + self._token}

        @staticmethod
        def _error_handler(res: requests.Response):
            """
            Converting the errors of the API to a string, in case there are no error, return an empty string
            :param res: the request's response
            :return: None
            """
            err_msg = 'Error in API call [{}] - {}\n'.format(res.status_code, res.reason)
            try:
                # Try to parse json error response
                error_entry = res.json()
                errors = error_entry.get('errors', [])
                err_msg += '\n'.join(f"{error.get('code')}: {error.get('message')}" for  # pylint: disable=no-member
                                     error in errors)
                if 'Failed to issue access token - Not Authorized' in err_msg:
                    err_msg = err_msg.replace('Failed to issue access token - Not Authorized',
                                              'Client Secret is invalid.')
                elif 'Failed to generate access token for clientID' in err_msg:
                    err_msg = err_msg.replace('Failed to generate access token for clientID=', 'Client ID (')
                    if err_msg.endswith('.'):
                        err_msg = err_msg[:-1]
                    err_msg += ') is invalid.'
                raise DemistoException(err_msg)
            except ValueError:
                err_msg += '\n{}'.format(res.text)
                raise DemistoException(err_msg)

        def http_request(self, method, url_suffix, full_url=None, headers=None, json_data=None, params=None, data=None,
                         files=None, timeout=10, ok_codes=None, return_empty_response=False, auth=None):
            """A wrapper for requests lib to send our requests and handle requests and responses better.

            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.

            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.

            :type full_url: ``str``
            :param full_url:
                Bypasses the use of self._base_url + url_suffix. This is useful if you need to
                make a request to an address outside of the scope of the integration
                API.

            :type headers: ``dict``
            :param headers: Headers to send in the request. If None, will use self._headers.

            :type params: ``dict``
            :param params: URL parameters to specify the query.

            :type data: ``dict``
            :param data: The data to send in a 'POST' request.

            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.

            :type files: ``dict``
            :param files: The file data to send in a 'POST' request.

            :type timeout: ``float`` or ``tuple``
            :param timeout:
                The amount of time (in seconds) that a request will wait for a client to
                establish a connection to a remote machine before a timeout occurs.
                can be only float (Connection Timeout) or a tuple (Connection Timeout, Read Timeout).

            :type ok_codes: ``tuple``
            :param ok_codes:
                The request codes to accept as OK, for example: (200, 201, 204). If you specify
                "None", will use self._ok_codes.

            :type return_empty_response: ``bool``
            :param return_empty_response: Indicates whether we are expecting empty response (like 204) or not.

            :return: Depends on the resp_type parameter
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """
            return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                         json_data=json_data, params=params, data=data, files=files, timeout=timeout,
                                         ok_codes=ok_codes, return_empty_response=return_empty_response, auth=auth,
                                         error_handler=self._error_handler)

        def _get_token(self, force_gen_new_token=False):
            """
                Retrieves the token from the server if it's expired and updates the global HEADERS to include it

                :param force_gen_new_token: If set to True will generate a new token regardless of time passed

                :rtype: ``str``
                :return: Token
            """
            now = datetime.now()
            ctx = get_integration_context()
            if not ctx or force_gen_new_token:
                # new token is needed
                auth_token = self._generate_token()
            else:
                time_passed = now - dateparser.parse(ctx.get('generation_time'))
                if time_passed < TOKEN_LIFE_TIME:
                    # token hasn't expired
                    return ctx.get('auth_token')
                else:
                    # token expired
                    auth_token = self._generate_token()

            set_integration_context({'auth_token': auth_token, 'generation_time': now.strftime("%Y-%m-%dT%H:%M:%S")})
            return auth_token

        def _generate_token(self) -> str:
            """Generate an Access token using the user name and password
            :return: valid token
            """
            body = {
                'client_id': self._client_id,
                'client_secret': self._client_secret
            }
            token_res = self.http_request('POST', '/oauth2/token', data=body, auth=(self._client_id, self._client_secret))
            return token_res.get('access_token')

        def check_quota_status(self) -> dict:
            """Checking the status of the quota
            :return: http response
            """
            url_suffix = "/falconx/entities/submissions/v1?ids="
            return self.http_request('GET', url_suffix)

    register_module_line('CrowdStrikeApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    if __name__ in ('__main__', 'builtin', 'builtins'):
        main()

    register_module_line('CrowdStrike Falcon Intel v2', 'end', __line__())
  subtype: python3
  type: python
system: true
