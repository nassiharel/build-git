category: Data Enrichment & Threat Intelligence
commonfields:
  id: ThreatExchange v2
  version: -1
configuration:
- display: App ID
  name: app_id
  required: true
  type: 9
- additionalinfo: If the percentage of 'Malicious' reported statuses is above this
    threshold the indicator will be defined as malicious, otherwise suspicious
  defaultvalue: "50"
  display: Malicious Threshold
  name: malicious_threshold
  required: false
  type: 0
- additionalinfo: If the number of 'Suspicious' reported statuses is above this threshold
    the indicator will be defined as suspicious
  defaultvalue: "1"
  display: Suspicious Threshold
  name: suspicious_threshold
  required: false
  type: 0
- additionalinfo: If the percentage of 'Non Malicious' reported statuses is above
    this threshold the indicator will be defined as good, otherwise unknown
  defaultvalue: "50"
  display: Non Malicious Threshold
  name: non_malicious_threshold
  required: false
  type: 0
- additionalinfo: Reliability of the source providing the intelligence data
  defaultvalue: C - Fairly reliable
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 2.0.9
    packID: ThreatExchange
    packName: ThreatExchange
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: "null"
description: Receive threat intelligence about applications, IP addresses, URLs, and
  hashes. A service by Facebook.
detaileddescription: "## Authenticate via an Access Token\nThe ThreatExchange APIs
  perform authentication via access tokens consisting of App ID and App Secret.\nIn
  order to get your App ID and App Secret, Facebook must first confirm your app's
  access to ThreatExchange.\nAfter Facebook notifies you that your App can access
  ThreatExchange, go to the App's **Settings** - **Basic** - and copy your App ID
  and App Secret.\nWhen configuring ThreatExchange v2 on Cortex XSOAR, set the copied
  values in the ***App ID*** and ***App Secret*** fields.\nFor more information see
  [the ThreatExchange API Overview](https://developers.facebook.com/docs/threat-exchange/api/v10.0)\n\nFor
  Cortex XSOAR versions 6.0 and below, the App Secret should be set in the ***password***
  field. \n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/threat-exchange-v2)"
display: ThreatExchange v2
image: data:image/png;base64,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
name: ThreatExchange v2
script:
  commands:
  - arguments:
    - default: true
      description: Hash of the file to query. Supports MD5, SHA1, and SHA256 hashes.
      isArray: true
      name: file
      required: true
    - defaultValue: "20"
      description: The maximum number of results per page. The maximum is 1000.
      name: limit
    - description: 'A comma-separated list of headers to display in human-readable
        format. For example: header1,header2,header3.'
      name: headers
    - description: 'The start timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: since
    - description: 'The end timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: until
    description: Checks the file reputation of the given hash.
    name: file
    outputs:
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: File.Malicious.Vendor
      description: For malicious files, the vendor that made the decision.
      type: String
    - contextPath: File.Malicious.Description
      description: For malicious files, the reason that the vendor made the decision.
      type: String
    - contextPath: File.Malicious.Score
      description: For malicious files, the score from the vendor.
      type: Number
    - contextPath: ThreatExchange.File.share_level
      description: A designation of how the indicator may be shared, based on the
        US-CERT's Traffic Light Protocol.
      type: String
    - contextPath: ThreatExchange.File.privacy_type
      description: The level of privacy applied to the descriptor. Also known as "visibility".
      type: String
    - contextPath: ThreatExchange.File.status
      description: If the indicator is known to be malicious.
      type: String
    - contextPath: ThreatExchange.File.review_status
      description: Describes how the indicator was vetted.
      type: String
    - contextPath: ThreatExchange.File.id
      description: Unique identifier of the threat descriptor. Automatically assigned
        at create time, and non-editable.
      type: String
    - contextPath: ThreatExchange.File.description
      description: A short summary of the indicator and threat.
      type: String
    - contextPath: ThreatExchange.File.added_on
      description: The datetime this descriptor was first uploaded. Automatically
        computed; not directly editable.
      type: Date
    - contextPath: ThreatExchange.File.sha1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: ThreatExchange.File.sha256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: ThreatExchange.File.sample_size_compressed
      description: The size of the compressed sample.
      type: Number
    - contextPath: ThreatExchange.File.ssdeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: ThreatExchange.File.sample_type
      description: The MIME type of the sample.
      type: String
    - contextPath: ThreatExchange.File.sample_size
      description: The size of the sample.
      type: Number
    - contextPath: ThreatExchange.File.sha3_384
      description: The SHA3-384 hash of the file.
      type: String
    - contextPath: ThreatExchange.File.victim_count
      description: A count of known victims infected and/or spreading the malware.
      type: Number
    - contextPath: ThreatExchange.File.password
      description: The password required to decompress the sample.
      type: String
    - contextPath: ThreatExchange.File.md5
      description: The MD5 hash of the file.
      type: String
  - arguments:
    - default: true
      description: IP address to check.
      isArray: true
      name: ip
      required: true
    - description: 'A comma-separated list of headers to display in human-readable
        format. For example: header1,header2,header3.'
      name: headers
    - description: 'The start timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: since
    - description: 'The end timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: until
    - description: The maximum number of results per page. The maximum is 1000.
      name: limit
    description: Checks the reputation of the given IP address.
    name: ip
    outputs:
    - contextPath: IP.Address
      description: The IP address found.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: For malicious IP addresses, the vendor that made the decision.
      type: String
    - contextPath: IP.Malicious.Description
      description: For malicious IP addresses, the reason that the vendor made the
        decision.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: IP.Malicious.Score
      description: For malicious IP addresses, the score from the vendor.
      type: Number
    - contextPath: ThreatExchange.IP.share_level
      description: A designation of how the indicator may be shared, based on the
        US-CERT's Traffic Light Protocol.
      type: String
    - contextPath: ThreatExchange.IP.confidence
      description: A rating, from 0-100, on how confident the publisher is of the
        threat indicator's status. 0 is least confident. 100 is most confident.
      type: Number
    - contextPath: ThreatExchange.IP.indicator.id
      description: The ID of the threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.IP.indicator.indicator
      description: The threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.IP.indicator.type
      description: The type of the threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.IP.privacy_type
      description: The level of privacy applied to the descriptor. Also known as "visibility".
      type: String
    - contextPath: ThreatExchange.IP.last_updated
      description: Datetime the threat descriptor was last updated. Automatically
        computed; not directly editable.
      type: Date
    - contextPath: ThreatExchange.IP.status
      description: If the indicator is known to be malicious.
      type: String
    - contextPath: ThreatExchange.IP.owner.email
      description: The email of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.IP.owner.id
      description: The ID of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.IP.owner.name
      description: The name of the ThreatExchange member that submitted the descriptor.
        Non-editable
      type: String
    - contextPath: ThreatExchange.IP.raw_indicator
      description: A raw, unsanitized string of the indicator being described.
      type: String
    - contextPath: ThreatExchange.IP.review_status
      description: Describes how the indicator was vetted.
      type: String
    - contextPath: ThreatExchange.IP.type
      description: The type of indicator.
      type: String
    - contextPath: ThreatExchange.IP.id
      description: Unique identifier of the threat descriptor. Automatically assigned
        at create time, and non-editable.
      type: String
    - contextPath: ThreatExchange.IP.description
      description: A short summary of the indicator and threat.
      type: String
    - contextPath: ThreatExchange.IP.severity
      description: Severity of the threat associated with the indicator.
      type: String
    - contextPath: ThreatExchange.IP.added_on
      description: The datetime this descriptor was first uploaded. Automatically
        computed; not directly editable.
      type: Date
  - arguments:
    - default: true
      description: URL to be checked.
      isArray: true
      name: url
      required: true
    - defaultValue: "20"
      description: The maximum number of results per page. The maximum is 1000.
      name: limit
    - description: 'A comma-separated list of headers to display in human-readable
        format. For example: header1,header2,header3.'
      name: headers
    - description: 'The start timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: since
    - description: 'The end timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: until
    description: Checks the URL reputation.
    name: url
    outputs:
    - contextPath: URL.Data
      description: The URL found.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: URL.Malicious.Vendor
      description: For malicious URLs, the vendor that made the decision.
      type: String
    - contextPath: URL.Malicious.Description
      description: For malicious URLs, the reason for the vendor to make the decision.
      type: String
    - contextPath: URL.Malicious.Score
      description: For malicious URLs, the score from the vendor.
      type: Number
    - contextPath: ThreatExchange.URL.share_level
      description: A designation of how the indicator may be shared, based on the
        US-CERT's Traffic Light Protocol.
      type: String
    - contextPath: ThreatExchange.URL.confidence
      description: A rating, from 0-100, on how confident the publisher is of the
        threat indicator's status. 0 is least confident. 100 is most confident.
      type: Number
    - contextPath: ThreatExchange.URL.indicator.id
      description: The ID of the threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.URL.indicator.indicator
      description: The threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.URL.indicator.type
      description: The type of the threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.URL.privacy_type
      description: The level of privacy applied to the descriptor. Also known as "visibility".
      type: String
    - contextPath: ThreatExchange.URL.last_updated
      description: Datetime the threat descriptor was last updated. Automatically
        computed; not directly editable.
      type: Date
    - contextPath: ThreatExchange.URL.status
      description: If the indicator is known to be malicious.
      type: String
    - contextPath: ThreatExchange.URL.owner.email
      description: The email of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.URL.owner.id
      description: The ID of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.URL.owner.name
      description: The name of the ThreatExchange member that submitted the descriptor.
        Non-editable
      type: String
    - contextPath: ThreatExchange.URL.raw_indicator
      description: A raw, unsanitized string of the indicator being described.
      type: String
    - contextPath: ThreatExchange.URL.review_status
      description: Describes how the indicator was vetted.
      type: String
    - contextPath: ThreatExchange.URL.type
      description: The type of indicator.
      type: String
    - contextPath: ThreatExchange.URL.id
      description: Unique identifier of the threat descriptor. Automatically assigned
        at create time, and non-editable.
      type: String
    - contextPath: ThreatExchange.URL.description
      description: A short summary of the indicator and threat.
      type: String
    - contextPath: ThreatExchange.URL.severity
      description: Severity of the threat associated with the indicator.
      type: String
    - contextPath: ThreatExchange.URL.added_on
      description: The datetime this descriptor was first uploaded. Automatically
        computed; not directly editable.
      type: Date
  - arguments:
    - default: true
      description: Domain name to check reputation.
      isArray: true
      name: domain
      required: true
    - defaultValue: "20"
      description: The maximum number of results per page. The maximum is 1000.
      name: limit
    - description: 'A comma-separated list of headers to display in human-readable
        format. For example: header1,header2,header3.'
      name: headers
    - description: 'The start timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: since
    - description: 'The end timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: until
    description: Checks a domain reputation.
    name: domain
    outputs:
    - contextPath: Domain.Name
      description: The domain found.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: String
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason that the vendor made the decision.
      type: String
    - contextPath: ThreatExchange.Domain.share_level
      description: A designation of how the indicator may be shared, based on the
        US-CERT's Traffic Light Protocol.
      type: String
    - contextPath: ThreatExchange.Domain.confidence
      description: A rating, from 0-100, on how confident the publisher is of the
        threat indicator's status. 0 is least confident. 100 is most confident.
      type: Number
    - contextPath: ThreatExchange.Domain.indicator.id
      description: The ID of the threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.Domain.indicator.indicator
      description: The threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.Domain.indicator.type
      description: The type of the threat indicator described by the descriptor.
      type: String
    - contextPath: ThreatExchange.Domain.privacy_type
      description: The level of privacy applied to the descriptor. Also known as "visibility".
      type: String
    - contextPath: ThreatExchange.Domain.last_updated
      description: Datetime the threat descriptor was last updated. Automatically
        computed; not directly editable.
      type: Date
    - contextPath: ThreatExchange.Domain.status
      description: If the indicator is known to be malicious.
      type: String
    - contextPath: ThreatExchange.Domain.owner.email
      description: The email of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.Domain.owner.id
      description: The ID of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.Domain.owner.name
      description: The name of the ThreatExchange member that submitted the descriptor.
        Non-editable
      type: String
    - contextPath: ThreatExchange.Domain.raw_indicator
      description: A raw, unsanitized string of the indicator being described.
      type: String
    - contextPath: ThreatExchange.Domain.review_status
      description: Describes how the indicator was vetted.
      type: String
    - contextPath: ThreatExchange.Domain.type
      description: The type of indicator.
      type: String
    - contextPath: ThreatExchange.Domain.id
      description: Unique identifier of the threat descriptor. Automatically assigned
        at create time, and non-editable.
      type: String
    - contextPath: ThreatExchange.Domain.description
      description: A short summary of the indicator and threat.
      type: String
    - contextPath: ThreatExchange.Domain.severity
      description: Severity of the threat associated with the indicator.
      type: String
    - contextPath: ThreatExchange.Domain.added_on
      description: Datetime the analysis was created.
      type: Date
  - arguments:
    - default: true
      description: Free-form text field with a value to search for. This can be a
        file hash or a string found in other fields of the objects.
      name: text
      required: true
    - auto: PREDEFINED
      description: The type of descriptor to search for.
      name: type
      predefined:
      - ADJUST_TOKEN
      - API_KEY
      - AS_NUMBER
      - BANNER
      - CMD_LINE
      - COOKIE_NAME
      - CRX
      - DEBUG_STRING
      - DEST_PORT
      - DIRECTORY_QUERIED
      - DOMAIN
      - EMAIL_ADDRESS
      - FILE_CREATED
      - FILE_DELETED
      - FILE_MOVED
      - FILE_NAME
      - FILE_OPENED
      - FILE_READ
      - FILE_WRITTEN
      - GET_PARAM
      - HASH_IMPHASH
      - HASH_MD5
      - HASH_PDQ
      - HASH_TMK
      - HASH_SHA1
      - HASH_SHA256
      - HASH_SSDEEP
      - HASH_VIDEO_MD5
      - HTML_ID
      - HTTP_REQUEST
      - IP_ADDRESS
      - IP_SUBNET
      - ISP
      - LATITUDE
      - LATITUDE
      - LAUNCH_AGENT
      - LOCATION
      - LONGITUDE
      - MALWARE_NAME
      - MEMORY_ALLOC
      - MEMORY_PROTECT
      - MEMORY_WRITTEN
      - MUTANT_CREATED
      - MUTEX
      - NAME_SERVER
      - OTHER_FILE_OP
      - PASSWORD
      - PASSWORD_SALT
      - PAYLOAD_DATA
      - PAYLOAD_TYPE
      - POST_DATA
      - PROTOCOL
      - REFERER
      - REGISTRAR
      - REGISTRY_KEY
      - REG_KEY_CREATED
      - REG_KEY_DELETED
      - REG_KEY_ENUMERATED
      - REG_KEY_MONITORED
      - REG_KEY_OPENED
      - REG_KEY_VALUE_CREATED
      - REG_KEY_VALUE_DELETED
      - REG_KEY_VALUE_MODIFIED
      - REG_KEY_VALUE_QUERIED
      - SIGNATURE
      - SOURCE_PORT
      - TELEPHONE
      - TEXT_STRING
      - TREND_QUERY
      - URI
      - USER_AGENT
      - VOLUME_QUERIED
      - WEBSTORAGE_KEY
      - WEB_PAYLOAD
      - WHOIS_NAME
      - WHOIS_ADDR1
      - WHOIS_ADDR2
      - XPI
      required: true
    - defaultValue: "20"
      description: The maximum number of results per page. The maximum is 1000.
      name: limit
    - description: 'A comma-separated list of headers to display in human-readable
        format. For example: header1,header2,header3.'
      name: headers
    - description: 'The start timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: since
    - description: 'The end timestamp for collecting malware. Supported time formats:
        epoch time (e.g., 1619870400), ISO 8601 (e.g., 2021-05-01T12:00:00), and free
        text (e.g., 24 hours ago).'
      name: until
    - defaultValue: "false"
      description: When set to 'true', the API will not do approximate matching on
        the value in the text.
      name: strict_text
    - description: Returns results collected before this cursor.
      name: before
    - description: Returns results collected after this cursor.
      name: after
    description: Searches for subjective opinions on indicators of compromise stored
      in ThreatExchange.
    name: threatexchange-query
    outputs:
    - contextPath: ThreatExchange.Query.data.share_level
      description: A designation of how the indicator may be shared, based on the
        US-CERT's Traffic Light Protocol.
      type: String
    - contextPath: ThreatExchange.Query.data.last_updated
      description: Datetime the threat descriptor was last updated. Automatically
        computed; not directly editable.
      type: Date
    - contextPath: ThreatExchange.Query.data.owner.email
      description: The email of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.Query.data.owner.id
      description: The ID of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.Query.data.owner.name
      description: The name of the ThreatExchange member that submitted the descriptor.
        Non-editable.
      type: String
    - contextPath: ThreatExchange.Query.data.raw_indicator
      description: A raw, unsanitized string of the indicator being described.
      type: String
    - contextPath: ThreatExchange.Query.data.type
      description: The type of indicator.
      type: String
    - contextPath: ThreatExchange.Query.data.id
      description: Unique identifier of the threat descriptor. Automatically assigned
        at create time, and non-editable.
      type: String
    - contextPath: ThreatExchange.Query.data.added_on
      description: The datetime this descriptor was first uploaded. Automatically
        computed; not directly editable.
      type: Date
    - contextPath: ThreatExchange.Query.paging.before
      description: Paging before cursor.
      type: String
    - contextPath: ThreatExchange.Query.paging.after
      description: Paging after cursor.
      type: String
  - arguments: []
    description: Returns a list of current members of  ThreatExchange, alphabetized
      by application name. Each application may also include an optional contact email
      address. You can set this address, if desired, under the settings panel for
      your application.
    name: threatexchange-members
    outputs:
    - contextPath: ThreatExchange.Member.id
      description: Member's ID.
      type: String
    - contextPath: ThreatExchange.Member.email
      description: Member's email.
      type: String
    - contextPath: ThreatExchange.Member.name
      description: Member's name.
      type: String
  - arguments:
    - default: true
      description: |-
        Freeform text field with a value to search for.
        This value should describe a broader type or class of attack you are interested in.
      name: text
      required: true
    - description: Returns results collected before this cursor.
      name: before
    - description: Returns results collected after this cursor.
      name: after
    description: |-
      Enables searching for tags in ThreatExchange.
      With this call, you can search for ThreatTag objects by text.
    name: threatexchange-tags-search
    outputs:
    - contextPath: ThreatExchange.Tag.data.id
      description: The tag's ID.
      type: String
    - contextPath: ThreatExchange.Tag.data.text
      description: The tag's text.
      type: String
    - contextPath: ThreatExchange.Tag.paging.before
      description: Paging before cursor.
      type: Unknown
    - contextPath: ThreatExchange.Tag.paging.after
      description: Paging after cursor.
      type: String
  - arguments:
    - default: true
      description: ThreatTag ID to get it's related tagged objects. ThreatTag ID can
        be retrieved by the threatexchange-tags-search command.
      name: tag_id
      required: true
    - description: Fetches all objects that have been tagged since this time (inclusive).
      name: tagged_since
    - description: Fetches all objects that have been tagged until this time (inclusive).
      name: tagged_until
    - description: Returns results collected before this cursor.
      name: before
    - description: Returns results collected after this cursor.
      name: after
    description: Gets a list of tagged objects for a specific ThreatTag.
    name: threatexchange-tagged-objects-list
    outputs:
    - contextPath: ThreatExchange.TaggedObject.data.id
      description: The ID of the tagged object.
      type: String
    - contextPath: ThreatExchange.TaggedObject.data.type
      description: The type of the tagged object.
      type: String
    - contextPath: ThreatExchange.TaggedObject.data.name
      description: The name of the tagged object.
      type: String
    - contextPath: ThreatExchange.TaggedObject.paging.before
      description: Paging before cursor.
      type: String
    - contextPath: ThreatExchange.TaggedObject.paging.after
      description: Paging after cursor.
      type: String
  - arguments:
    - default: true
      description: ID of a ThreatExchange object. Can be retrieved by ThreatExchange
        reputation commands and the threatexchange-tagged-objects-list command.
      name: object_id
      required: true
    description: Gets a ThreatExchange object by ID.
    name: threatexchange-object-get-by-id
    outputs:
    - contextPath: ThreatExchange.Object.id
      description: ID of a ThreatExchange object.
      type: String
  dockerimage: demisto/python3:3.10.4.29342
  runonce: false
  script: |
    register_module_line('ThreatExchange v2', 'start', __line__())
    """
    An integration module for the ThreatExchange V2 API.
    API Documentation:
        https://developers.facebook.com/docs/threat-exchange/reference/apis
    """

    import collections
    from typing import Tuple
    import urllib3



    # Disable insecure warnings #
    urllib3.disable_warnings()

    DEFAULT_LIMIT = 20
    COMMAND_PREFIX = 'threatexchange'
    VENDOR_NAME = 'ThreatExchange v2'
    CONTEXT_PREFIX = 'ThreatExchange'
    THREAT_DESCRIPTORS_SUFFIX = 'threat_descriptors'
    MALWARE_ANALYSES_SUFFIX = 'malware_analyses'
    THREAT_TAGS_SUFFIX = 'threat_tags'
    TAGGED_OBJECTS_SUFFIX = 'tagged_objects'
    THREAT_EXCHANGE_MEMBERS_SUFFIX = 'threat_exchange_members'
    TIMEOUT_FOR_LIST_CALLS = 30
    DEFAULT_DESCRIPTION_FOR_MALICIOUS_INDICATOR = 'Indicator was classified as malicious by more than {}%' \
                                                  ' of detection engines.'


    class ThreatExchangeV2Status:
        UNKNOWN = 'UNKNOWN'
        NON_MALICIOUS = 'NON_MALICIOUS'
        SUSPICIOUS = 'SUSPICIOUS'
        MALICIOUS = 'MALICIOUS'


    class Client(BaseClient):
        """Client class to interact with the service API

        This Client implements API calls, and does not contain any XSOAR logic.
        Should only do requests and return data.
        It inherits from BaseClient defined in CommonServer Python.
        Most calls use _http_request() that handles proxy, SSL verification, etc.
        For this implementation, no special attributes defined
        """

        def __init__(self, base_url, access_token, verify=True, proxy=False):
            super().__init__(base_url, verify, proxy)
            self.access_token = access_token

        def ip(self, ip: str, since: Optional[int], until: Optional[int], limit: Optional[int] = DEFAULT_LIMIT) -> Dict:
            """
            See Also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-descriptors
            Args:
                ip: ip address
                since: Returns malware collected after a timestamp
                until: Returns malware collected before a timestamp
                limit: Defines the maximum size of a page of results. The maximum is 1,000

            Returns: The API call response
            """
            response = self._http_request(
                'GET',
                THREAT_DESCRIPTORS_SUFFIX,
                params={
                    'access_token': self.access_token,
                    'type': 'IP_ADDRESS',
                    'text': ip,
                    'strict_text': True,
                    'since': since,
                    'until': until,
                    'limit': limit
                }
            )
            return response

        def file(self, file: str, since: Optional[int], until: Optional[int], limit: Optional[int] = DEFAULT_LIMIT) -> Dict:
            """
            See Also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/malware-analyses/v10.0
            Args:
                file: Hash of a file
                since: Returns malware collected after a timestamp
                until: Returns malware collected before a timestamp
                limit: Defines the maximum size of a page of results. The maximum is 1,000

            Returns: The API call response
            """

            response = self._http_request(
                'GET',
                MALWARE_ANALYSES_SUFFIX,
                params=assign_params(**{
                    'access_token': self.access_token,
                    'text': file,
                    'strict_text': True,
                    'since': since,
                    'until': until,
                    'limit': limit
                })
            )
            return response

        def domain(self, domain: str, since: Optional[int], until: Optional[int],
                   limit: Optional[int] = DEFAULT_LIMIT) -> Dict:
            """
            See Also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-descriptors
            Args:
                domain: Domain
                since: Returns malware collected after a timestamp
                until: Returns malware collected before a timestamp
                limit: Defines the maximum size of a page of results. The maximum is 1,000

            Returns: The API call response
            """

            response = self._http_request(
                'GET',
                THREAT_DESCRIPTORS_SUFFIX,
                params=assign_params(**{
                    'access_token': self.access_token,
                    'type': 'DOMAIN',
                    'text': domain,
                    'strict_text': True,
                    'since': since,
                    'until': until,
                    'limit': limit
                })
            )
            return response

        def url(self, url: str, since: Optional[int], until: Optional[int], limit: Optional[int] = DEFAULT_LIMIT) -> Dict:
            """
            See Also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-descriptors
            Args:
                url: URL
                since: Returns malware collected after a timestamp
                until: Returns malware collected before a timestamp
                limit: Defines the maximum size of a page of results. The maximum is 1,000

            Returns: The API call response
            """

            response = self._http_request(
                'GET',
                THREAT_DESCRIPTORS_SUFFIX,
                params=assign_params(**{
                    'access_token': self.access_token,
                    'type': 'URI',
                    'text': url,
                    'strict_text': True,
                    'since': since,
                    'until': until,
                    'limit': limit
                })
            )
            return response

        def members(self) -> Dict:
            """
            See Also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-exchange-members/v10.0

            Returns: The API call response
            """

            response = self._http_request(
                'GET',
                THREAT_EXCHANGE_MEMBERS_SUFFIX,
                params={'access_token': self.access_token},
                timeout=TIMEOUT_FOR_LIST_CALLS
            )
            return response

        def query(self, text: str, descriptor_type: str, since: Optional[int], until: Optional[int],
                  limit: Optional[int] = DEFAULT_LIMIT, strict_text: Optional[bool] = False,
                  before: Optional[str] = None, after: Optional[str] = None) -> Dict:
            """
            See Also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-descriptors
            Args:
                text: Freeform text field with a value to search for
                descriptor_type: The type of descriptor to search for
                since: Returns malware collected after a timestamp
                until: Returns malware collected before a timestamp
                limit: Defines the maximum size of a page of results. The maximum is 1,000
                strict_text: When set to 'true', the API will not do approximate matching on the value in text
                before: Returns results collected before this cursor
                after: Returns results collected after this cursor

            Returns: The API call response
            """

            response = self._http_request(
                'GET',
                THREAT_DESCRIPTORS_SUFFIX,
                params=assign_params(**{
                    'access_token': self.access_token,
                    'type': descriptor_type,
                    'text': text,
                    'strict_text': strict_text,
                    'since': since,
                    'until': until,
                    'limit': limit,
                    'before': before,
                    'after': after
                }),
                timeout=TIMEOUT_FOR_LIST_CALLS
            )
            return response

        def tags_search(self, text: str, before: Optional[str] = None, after: Optional[str] = None) -> Dict:
            """
            See also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-tags/v10.0
            Args:
                text: Freeform text field with a value to search for.
                      This value should describe a broader type or class of attack you are interested in.
                before: Returns results collected before this cursor
                after:  Returns results collected after this cursor

            Returns: The API call response
            """
            response = self._http_request(
                'GET',
                THREAT_TAGS_SUFFIX,
                params=assign_params(**{
                    'access_token': self.access_token,
                    'text': text,
                    'before': before,
                    'after': after
                }),
                timeout=TIMEOUT_FOR_LIST_CALLS
            )
            return response

        def tagged_objects_list(self, tag_id: str, tagged_since: Optional[int], tagged_until: Optional[int],
                                before: Optional[str] = None, after: Optional[str] = None) -> Dict:
            """
            See also:
                https://developers.facebook.com/docs/threat-exchange/reference/apis/threattags/v10.0
            Args:
                tag_id: ThreatTag ID to get it's related tagged objects
                tagged_since:  Fetches all objects that have been tagged since this time (inclusive)
                tagged_until: Fetches all objects that have been tagged until this time (inclusive)
                before: Returns results collected before this cursor
                after:  Returns results collected after this cursor

            Returns: The API call response
            """
            url_suffix = f'{tag_id}/{TAGGED_OBJECTS_SUFFIX}'
            response = self._http_request(
                'GET',
                url_suffix,
                params=assign_params(**{
                    'access_token': self.access_token,
                    'tagged_since': tagged_since,
                    'tagged_until': tagged_until,
                    'before': before,
                    'after': after
                }),
                timeout=TIMEOUT_FOR_LIST_CALLS
            )
            return response

        def object_get_by_id(self, object_id: str) -> Dict:
            """
            Gets ThreatExchange object by ID
            Args:
                object_id: ID of a ThreatExchange object

            Returns: The API call response
            """
            response = self._http_request(
                'GET',
                object_id,
                params={
                    'access_token': self.access_token
                }
            )
            return response


    def get_reputation_data_statuses(reputation_data: List) -> List[str]:
        """
        collects reported statuses of reputation data
        Args:
            reputation_data: returned data list of a certain reputation command

        Returns: a list of reported statuses
        """
        reputation_statuses = [status for data_entry in reputation_data if (status := data_entry.get('status'))]
        return reputation_statuses


    def calculate_dbot_score(reputation_data: List, params: Dict[str, Any]) -> int:
        """
        Calculates the Dbot score of the given reputation command data, by the following logic:
        MALICIOUS > malicious threshold (50%) = Malicious
        MALICIOUS <= malicious threshold (50%) = Suspicious
        SUSPICIOUS > suspicious threshold (1) = Suspicious
        NON_MALICIOUS > non malicious threshold (50%) = Good
        else Unknown
        Args:
            reputation_data: returned data list of a certain reputation command
            params: parameters of the integration
        Returns: the calculated Dbot score
        """
        # get user's thresholds:
        malicious_threshold = arg_to_number(params.get('malicious_threshold', 50), arg_name='malicious_threshold')
        if malicious_threshold is None:
            malicious_threshold = 50
        suspicious_threshold = arg_to_number(params.get('suspicious_threshold', 1), arg_name='suspicious_threshold')
        if suspicious_threshold is None:
            suspicious_threshold = 1
        non_malicious_threshold = arg_to_number(params.get('non_malicious_threshold', 50),
                                                arg_name='non_malicious_threshold')
        if non_malicious_threshold is None:
            non_malicious_threshold = 50

        # collect and count reported statuses:
        reputation_statuses = get_reputation_data_statuses(reputation_data)
        num_of_statuses = len(reputation_statuses)
        occurrences = collections.Counter(reputation_statuses)

        # calculate Dbot score:
        num_of_malicious = occurrences.get(ThreatExchangeV2Status.MALICIOUS, 0)
        num_of_suspicious = occurrences.get(ThreatExchangeV2Status.SUSPICIOUS, 0)
        num_of_non_malicious = occurrences.get(ThreatExchangeV2Status.NON_MALICIOUS, 0)
        if num_of_statuses == 0:  # no reported statuses
            score = Common.DBotScore.NONE
        elif num_of_malicious >= 1:  # at least one malicious status was reported
            if ((num_of_malicious / num_of_statuses) * 100) > malicious_threshold:
                score = Common.DBotScore.BAD
            else:  # num_of_malicious <= malicious_threshold
                score = Common.DBotScore.SUSPICIOUS
        elif num_of_suspicious > suspicious_threshold:  # number of suspicious statuses is above threshold
            score = Common.DBotScore.SUSPICIOUS
        elif ((num_of_non_malicious / num_of_statuses) * 100) > non_malicious_threshold:
            # number of non malicious statuses is above threshold
            score = Common.DBotScore.GOOD
        else:  # there isn't enough information - Dbot score is defined as unknown
            score = Common.DBotScore.NONE

        return score


    def calculate_engines(reputation_data: List) -> Tuple[int, int]:
        """
        Calculates the number of engines that scanned the indicator, and how many of them are positive
         - i.e returned malicious status.
        Args:
            reputation_data: returned data list of a certain reputation command

        Returns: number of engines, number of positive engines
        """
        num_of_engines = len(reputation_data)
        reputation_statuses = get_reputation_data_statuses(reputation_data)
        occurrences = collections.Counter(reputation_statuses)
        num_of_positive_engines = occurrences.get(ThreatExchangeV2Status.MALICIOUS, 0)

        return num_of_engines, num_of_positive_engines


    def flatten_outputs_paging(raw_response: Dict) -> Dict:
        """
        flatten the paging section of the raw_response - i.e removes 'cursors' key.
        Args:
            raw_response: response of an API call

        Returns: outputs dict

        """
        paging: Dict
        paging = raw_response.get('paging', {})
        outputs = raw_response.copy()
        cursor_before = paging.get('cursors', {}).get('before')
        cursor_after = paging.get('cursors', {}).get('after')
        outputs.pop('paging', None)
        outputs['paging'] = {
            'before': cursor_before,
            'after': cursor_after,
        }
        return outputs


    def get_malicious_description(score: int, reputation_data: List[Dict], params: Dict[str, Any]) -> Optional[str]:
        """
        Gets the malicious description of certain indicator.
        If the indicator was classified as malicious, description is defined as default malicious description.
        If the indicator wasn't classified as malicious, description will be None (and won't be added to context).
        Args:
            score: calculated dbot score of the indicator
            reputation_data: returned data of a certain reputation command
            params: integration's parameters

        Returns: malicious description

        """
        malicious_description: Union[str, None]
        if score == Common.DBotScore.BAD:
            malicious_threshold = arg_to_number(params.get('malicious_threshold', 50))
            default_description = DEFAULT_DESCRIPTION_FOR_MALICIOUS_INDICATOR.format(malicious_threshold)
            malicious_description = default_description

        else:  # dbot-score isn't malicious
            malicious_description = None

        return malicious_description


    def convert_string_to_epoch_time(date: Optional[str], arg_name: Optional[str] = None) -> Optional[int]:
        """
        Converts a string representing a date into epoch time format
        Args:
            date: date string
            arg_name: name of the date argument

        Returns: date in epoch time format (if an error occurred, or date in None returns None)
        """
        if date:
            if date.isdigit():  # date is an epoch time format string
                return int(date)

            date_obj = dateparser.parse(date)  # date is a string in a time format such as: iso 8601, free text, etc
            if isinstance(date_obj, datetime):
                epoch_time = date_obj.timestamp()
                return int(epoch_time)
            else:  # date was given in a wrong format
                if arg_name:
                    raise ValueError('Invalid date: "{}"="{}"'.format(arg_name, date))

        return None


    def test_module(client: Client) -> str:
        """
        Tests API connectivity and authentication.

        Returning 'ok' indicates that the integration works like it is supposed to.
        Connection to the service is successful.
        Raises exceptions if something goes wrong.

        Args:
            client: client to use

        Returns: 'ok' if test passed, anything else will fail the test
        """

        client.ip(ip='8.8.8.8', since=None, until=None)
        return 'ok'


    def ip_command(client: Client, args: Dict[str, Any], params: Dict[str, Any]) -> List[CommandResults]:
        """
        Returns IP's reputation
        """
        ips = argToList(args.get('ip'))
        since = convert_string_to_epoch_time(args.get('since'), arg_name='since')
        until = convert_string_to_epoch_time(args.get('until'), arg_name='until')
        limit = arg_to_number(args.get('limit'), arg_name='limit')
        headers = argToList(args.get('headers'))
        reliability = params.get('feedReliability')
        results: List[CommandResults] = list()

        for ip in ips:
            if not is_ip_valid(ip, accept_v6_ips=True):  # check IP's validity
                raise ValueError(f'IP "{ip}" is not valid')
            try:
                raw_response = client.ip(ip, since, until, limit)
            except Exception as exception:
                # If anything happens, handle like there are no results
                err_msg = f'Could not process IP: "{ip}"\n {str(exception)}'
                demisto.debug(err_msg)
                raw_response = {}
            if data := raw_response.get('data'):
                score = calculate_dbot_score(reputation_data=data, params=params)
                num_of_engines, num_of_positive_engines = calculate_engines(reputation_data=data)
                malicious_description = get_malicious_description(score, data, params)
                dbot_score = Common.DBotScore(
                    indicator=ip,
                    indicator_type=DBotScoreType.IP,
                    integration_name=VENDOR_NAME,
                    score=score,
                    reliability=reliability,
                    malicious_description=malicious_description
                )
                if not headers:
                    headers = ['description', 'owner', 'status', 'type', 'raw_indicator', 'share_level', 'confidence',
                               'severity', 'added_on', 'last_updated', 'review_status', 'id']
                readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Result for IP {ip}', data, headers=headers)
                ip_indicator = Common.IP(
                    ip=ip,
                    dbot_score=dbot_score,
                    detection_engines=num_of_engines,
                    positive_engines=num_of_positive_engines
                )

            else:  # no data
                dbot_score = Common.DBotScore(
                    indicator=ip,
                    indicator_type=DBotScoreType.IP,
                    integration_name=VENDOR_NAME,
                    score=Common.DBotScore.NONE,
                    reliability=reliability
                )
                readable_output = f'{CONTEXT_PREFIX} does not have details about IP: {ip} \n'
                ip_indicator = Common.IP(
                    ip=ip,
                    dbot_score=dbot_score,
                )

            result = CommandResults(
                outputs_prefix=f'{CONTEXT_PREFIX}.IP',
                outputs_key_field='id',
                outputs=data,
                indicator=ip_indicator,
                readable_output=readable_output,
                raw_response=raw_response
            )
            results.append(result)

        return results


    def file_command(client: Client, args: Dict[str, Any], params: Dict[str, Any]) -> List[CommandResults]:
        """
        Returns file's reputation
        """
        files = argToList(args.get('file'))
        since = convert_string_to_epoch_time(args.get('since'), arg_name='since')
        until = convert_string_to_epoch_time(args.get('until'), arg_name='until')
        limit = arg_to_number(args.get('limit'), arg_name='limit')
        headers = argToList(args.get('headers'))
        reliability = params.get('feedReliability')
        results: List[CommandResults] = list()

        for file in files:
            if get_hash_type(file) not in ('sha256', 'sha1', 'md5'):  # check file's validity
                raise ValueError(f'Hash "{file}" is not of type SHA-256, SHA-1 or MD5')
            try:
                raw_response = client.file(file, since, until, limit)
            except Exception as exception:
                # If anything happens, handle like there are no results
                err_msg = f'Could not process file: "{file}"\n {str(exception)}'
                demisto.debug(err_msg)
                raw_response = {}
            if data := raw_response.get('data'):
                score = calculate_dbot_score(reputation_data=data, params=params)
                malicious_description = get_malicious_description(score, data, params)
                dbot_score = Common.DBotScore(
                    indicator=file,
                    indicator_type=DBotScoreType.FILE,
                    integration_name=VENDOR_NAME,
                    score=score,
                    reliability=reliability,
                    malicious_description=malicious_description
                )
                if not headers:
                    headers = ['description', 'status', 'share_level', 'added_on', 'review_status', 'id', 'password',
                               'sample_size', 'sample_size_compressed', 'sample_type', 'victim_count', 'md5', 'sha1',
                               'sha256', 'sha3_384', 'ssdeep']
                readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Result for file hash {file}', data, headers=headers)
                data_entry = data[0]
                file_indicator = Common.File(
                    dbot_score=dbot_score,
                    file_type=data_entry.get('sample_type'),
                    size=data_entry.get('sample_size'),
                    md5=data_entry.get('md5'),
                    sha1=data_entry.get('sha1'),
                    sha256=data_entry.get('sha256'),
                    ssdeep=data_entry.get('ssdeep'),
                    tags=data_entry.get('tags')
                )

            else:  # no data
                dbot_score = Common.DBotScore(
                    indicator=file,
                    indicator_type=DBotScoreType.FILE,
                    integration_name=VENDOR_NAME,
                    score=Common.DBotScore.NONE,
                    reliability=reliability
                )
                readable_output = f'{CONTEXT_PREFIX} does not have details about file: {file} \n'
                file_indicator = Common.File(
                    dbot_score=dbot_score
                )

            result = CommandResults(
                outputs_prefix=f'{CONTEXT_PREFIX}.File',
                outputs_key_field='id',
                outputs=data,
                indicator=file_indicator,
                readable_output=readable_output,
                raw_response=raw_response
            )
            results.append(result)

        return results


    def domain_command(client: Client, args: Dict[str, Any], params: Dict[str, Any]) -> List[CommandResults]:
        """
        Returns domain's reputation
        """
        domains = argToList(args.get('domain'))
        since = convert_string_to_epoch_time(args.get('since'), arg_name='since')
        until = convert_string_to_epoch_time(args.get('until'), arg_name='until')
        limit = arg_to_number(args.get('limit'), arg_name='limit')
        headers = argToList(args.get('headers'))
        reliability = params.get('feedReliability')
        results: List[CommandResults] = list()

        for domain in domains:
            try:
                raw_response = client.domain(domain, since, until, limit)
            except Exception as exception:
                # If anything happens, handle like there are no results
                err_msg = f'Could not process domain: "{domain}"\n {str(exception)}'
                demisto.debug(err_msg)
                raw_response = {}
            if data := raw_response.get('data'):
                score = calculate_dbot_score(reputation_data=data, params=params)
                num_of_engines, num_of_positive_engines = calculate_engines(reputation_data=data)
                malicious_description = get_malicious_description(score, data, params)
                dbot_score = Common.DBotScore(
                    indicator=domain,
                    indicator_type=DBotScoreType.DOMAIN,
                    integration_name=VENDOR_NAME,
                    score=score,
                    reliability=reliability,
                    malicious_description=malicious_description
                )
                if not headers:
                    headers = ['description', 'owner', 'status', 'type', 'raw_indicator', 'share_level', 'confidence',
                               'severity', 'added_on', 'last_updated', 'review_status', 'id']
                readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Result for domain {domain}', data, headers=headers)
                domain_indicator = Common.Domain(
                    domain=domain,
                    dbot_score=dbot_score,
                    detection_engines=num_of_engines,
                    positive_detections=num_of_positive_engines
                )
            else:  # no data
                dbot_score = Common.DBotScore(
                    indicator=domain,
                    indicator_type=DBotScoreType.DOMAIN,
                    integration_name=VENDOR_NAME,
                    score=Common.DBotScore.NONE,
                    reliability=reliability
                )
                readable_output = f'{CONTEXT_PREFIX} does not have details about domain: {domain} \n'
                domain_indicator = Common.Domain(
                    domain=domain,
                    dbot_score=dbot_score
                )

            result = CommandResults(
                outputs_prefix=f'{CONTEXT_PREFIX}.Domain',
                outputs_key_field='id',
                outputs=data,
                indicator=domain_indicator,
                readable_output=readable_output,
                raw_response=raw_response
            )
            results.append(result)

        return results


    def url_command(client: Client, args: Dict[str, Any], params: Dict[str, Any]) -> List[CommandResults]:
        """
        Returns URL's reputation
        """
        urls = argToList(args.get('url'))
        since = convert_string_to_epoch_time(args.get('since'), arg_name='since')
        until = convert_string_to_epoch_time(args.get('until'), arg_name='until')
        limit = arg_to_number(args.get('limit'), arg_name='limit')
        headers = argToList(args.get('headers'))
        reliability = params.get('feedReliability')
        results: List[CommandResults] = list()
        for url in urls:
            try:
                raw_response = client.url(url, since, until, limit)
            except Exception as exception:
                # If anything happens, handle like there are no results
                err_msg = f'Could not process URL: "{url}"\n {str(exception)}'
                demisto.debug(err_msg)
                raw_response = {}
            if data := raw_response.get('data'):
                score = calculate_dbot_score(reputation_data=data, params=params)
                num_of_engines, num_of_positive_engines = calculate_engines(reputation_data=data)
                malicious_description = get_malicious_description(score, data, params)
                dbot_score = Common.DBotScore(
                    indicator=url,
                    indicator_type=DBotScoreType.URL,
                    integration_name=VENDOR_NAME,
                    score=score,
                    reliability=reliability,
                    malicious_description=malicious_description
                )
                if not headers:
                    headers = ['description', 'owner', 'status', 'type', 'raw_indicator', 'share_level', 'confidence',
                               'severity', 'added_on', 'last_updated', 'review_status', 'id']
                readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Result for URL {url}', data, headers=headers)
                url_indicator = Common.URL(
                    url=url,
                    dbot_score=dbot_score,
                    detection_engines=num_of_engines,
                    positive_detections=num_of_positive_engines
                )
            else:  # no data
                dbot_score = Common.DBotScore(
                    indicator=url,
                    indicator_type=DBotScoreType.URL,
                    integration_name=VENDOR_NAME,
                    score=Common.DBotScore.NONE,
                    reliability=reliability
                )
                readable_output = f'{CONTEXT_PREFIX} does not have details about URL: {url} \n'
                url_indicator = Common.URL(
                    url=url,
                    dbot_score=dbot_score
                )

            result = CommandResults(
                outputs_prefix=f'{CONTEXT_PREFIX}.URL',
                outputs_key_field='id',
                outputs=data,
                indicator=url_indicator,
                readable_output=readable_output,
                raw_response=raw_response
            )
            results.append(result)

        return results


    def members_command(client: Client) -> CommandResults:
        """
        Returns a list of current members of the ThreatExchange, alphabetized by application name.
        Each application may also include an optional contact email address.
        See Also:
              https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-exchange-members/v10.0

        """
        raw_response = client.members()
        if data := raw_response.get('data'):
            headers = ['id', 'name', 'email']
            readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Members: ', data, headers=headers, removeNull=True)
        else:  # no data
            readable_output = f'{CONTEXT_PREFIX} does not have any members \n'

        result = CommandResults(
            outputs_prefix=f'{CONTEXT_PREFIX}.Member',
            outputs_key_field='id',
            outputs=data,
            readable_output=readable_output,
            raw_response=raw_response
        )
        return result


    def query_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Searches for subjective opinions on indicators of compromise stored in ThreatExchange.
        """
        text = str(args.get('text'))
        descriptor_type = str(args.get('type'))
        since = convert_string_to_epoch_time(args.get('since'), arg_name='since')
        until = convert_string_to_epoch_time(args.get('until'), arg_name='until')
        limit = arg_to_number(args.get('limit'), arg_name='limit')
        strict_text = argToBoolean(args.get('strict_text', False))
        headers = argToList(args.get('headers'))
        before = args.get('before')
        after = args.get('after')

        raw_response = client.query(text, descriptor_type, since, until, limit, strict_text, before, after)
        try:  # removes 'next' field to prevent access token uncovering
            del raw_response['paging']['next']
        except KeyError:  # for no paging cases
            pass

        if data := raw_response.get('data'):
            readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Query Result:', data, headers=headers)
            if raw_response.get('paging'):  # if paging exist - flatten the output
                outputs = flatten_outputs_paging(raw_response)
                readable_output += tableToMarkdown('Pagination:', outputs.get('paging'))
            else:  # no paging
                outputs = raw_response

        else:  # no data
            readable_output = f'{CONTEXT_PREFIX} does not have details about {descriptor_type}: {text} \n'
            outputs = raw_response

        outputs['text'] = text
        outputs['type'] = descriptor_type

        result = CommandResults(
            outputs_prefix=f'{CONTEXT_PREFIX}.Query',
            outputs_key_field=['text', 'type'],
            outputs=outputs,
            readable_output=readable_output,
            raw_response=raw_response
        )

        return result


    def tags_search_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Enables searching for tags in ThreatExchange.
        With this call you can search for ThreatTag objects by text.
        See Also:
            https://developers.facebook.com/docs/threat-exchange/reference/apis/threattags/v10.0
        """
        text = str(args.get('text'))
        before = args.get('before')
        after = args.get('after')

        raw_response = client.tags_search(text, before, after)
        try:  # removes 'next' field to prevent access token uncovering
            del raw_response['paging']['next']
        except KeyError:  # for no paging cases
            pass

        if data := raw_response.get('data'):
            readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Tags: ', data, removeNull=True)
            if raw_response.get('paging'):  # if paging exist - flatten the output
                outputs = flatten_outputs_paging(raw_response)
                readable_output += tableToMarkdown('Pagination:', outputs.get('paging'))
            else:  # no paging
                outputs = raw_response

        else:  # no data
            readable_output = f'{CONTEXT_PREFIX} does not have any tags for text: {text} \n'
            outputs = raw_response

        outputs['text'] = text

        result = CommandResults(
            outputs_prefix=f'{CONTEXT_PREFIX}.Tag',
            outputs_key_field='text',
            outputs=outputs,
            readable_output=readable_output,
            raw_response=raw_response
        )
        return result


    def tagged_objects_list_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets a list of tagged objects for a specific ThreatTag.
        See Also:
            https://developers.facebook.com/docs/threat-exchange/reference/apis/threat-tags/v10.0
        """
        tag_id = str(args.get('tag_id'))
        tagged_since = arg_to_number(args.get('tagged_since'), arg_name='tagged_since')
        tagged_until = arg_to_number(args.get('tagged_until'), arg_name='tagged_until')
        before = args.get('before')
        after = args.get('after')

        raw_response = client.tagged_objects_list(tag_id, tagged_since, tagged_until, before, after)
        try:  # removes 'next' field to prevent access token uncovering
            del raw_response['paging']['next']
        except KeyError:  # for no paging cases
            pass

        if data := raw_response.get('data'):
            readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Tagged Objects for ThreatTag: {tag_id}', data,
                                              removeNull=True)
            if raw_response.get('paging'):  # if paging exist - flatten the output
                outputs = flatten_outputs_paging(raw_response)
                readable_output += tableToMarkdown('Pagination:', outputs.get('paging'))
            else:  # no paging
                outputs = raw_response

        else:  # no data
            readable_output = f'{CONTEXT_PREFIX} does not have any tagged objects for ThreatTag: {tag_id} \n'
            outputs = raw_response

        outputs['tag_id'] = tag_id

        result = CommandResults(
            outputs_prefix=f'{CONTEXT_PREFIX}.TaggedObject',
            outputs_key_field='tag_id',
            outputs=outputs,
            readable_output=readable_output,
            raw_response=raw_response
        )
        return result


    def object_get_by_id_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets ThreatExchange object by ID.
        """
        object_id = str(args.get('object_id'))

        raw_response = client.object_get_by_id(object_id)
        if raw_response:
            readable_output = tableToMarkdown(f'{CONTEXT_PREFIX} Object {object_id}:', raw_response, removeNull=True)
        else:  # no data
            readable_output = f'{CONTEXT_PREFIX} does not have any object with ID: {object_id} \n'

        result = CommandResults(
            outputs_prefix=f'{CONTEXT_PREFIX}.Object',
            outputs_key_field='id',
            outputs=raw_response,
            readable_output=readable_output,
            raw_response=raw_response
        )
        return result


    def main():
        """
        main function, parses params and runs command functions
        """
        command = demisto.command()
        params = demisto.params()
        args = demisto.args()

        app_id_obj = params.get('app_id')
        app_id = app_id_obj['identifier']
        app_secret = app_id_obj['password']
        access_token = f'{app_id}|{app_secret}'
        base_url = 'https://graph.facebook.com/v3.2'
        verify_certificate = not argToBoolean(params.get('insecure', False))
        proxy = argToBoolean(params.get('proxy', False))
        handle_proxy()

        demisto.debug(f'Command being called is {command}')
        try:
            client = Client(
                base_url=base_url,
                access_token=access_token,
                verify=verify_certificate,
                proxy=proxy
            )
            result: Union[str, CommandResults, List[CommandResults]]
            if command == 'test-module':
                result = test_module(client)
            elif command == 'ip':
                result = ip_command(client, args, params)
            elif command == 'file':
                result = file_command(client, args, params)
            elif command == 'domain':
                result = domain_command(client, args, params)
            elif command == 'url':
                result = url_command(client, args, params)
            elif command == f'{COMMAND_PREFIX}-members':
                result = members_command(client)
            elif command == f'{COMMAND_PREFIX}-query':
                result = query_command(client, args)
            elif command == f'{COMMAND_PREFIX}-tags-search':
                result = tags_search_command(client, args)
            elif command == f'{COMMAND_PREFIX}-tagged-objects-list':
                result = tagged_objects_list_command(client, args)
            elif command == f'{COMMAND_PREFIX}-object-get-by-id':
                result = object_get_by_id_command(client, args)
            else:
                raise NotImplementedError(f'Command {command} is not implemented')
            return_results(result)
        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {command} command.\nError:\n{str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('ThreatExchange v2', 'end', __line__())
  subtype: python3
  type: python
system: true
