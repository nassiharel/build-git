category: Analytics & SIEM
commonfields:
  id: Google Chronicle Backstory
  version: -1
configuration:
- display: User's Service Account JSON
  name: service_account_credential
  required: true
  type: 4
- additionalinfo: Select the region based on the location of the chronicle backstory
    instance.
  defaultvalue: General
  display: Region
  name: region
  options:
  - General
  - Europe
  - Asia
  required: false
  type: 15
- display: Provide comma(',') separated categories (e.g. APT-Activity, Phishing).
    Indicators belonging to these "categories" would be considered as "malicious"
    when executing reputation commands.
  name: malicious_categories
  required: false
  type: 12
- display: Provide comma(',') separated categories (e.g. Unwanted, VirusTotal YARA
    Rule Match). Indicators belonging to these "categories" would be considered as
    "suspicious" when executing reputation commands.
  name: suspicious_categories
  required: false
  type: 12
- display: Specify the "severity" of indicator that should be considered as "malicious"
    irrespective of the category.  If you wish to consider all indicators with High
    severity as Malicious, set this parameter to 'High'. Allowed values are 'High',
    'Medium' and 'Low'. This configuration is applicable to reputation commands only.
  name: override_severity_malicious
  options:
  - high
  - medium
  - low
  required: false
  type: 16
- display: Specify the "severity" of indicator that should be considered as "suspicious"
    irrespective of the category. If you wish to consider all indicators with Medium
    severity as Suspicious, set this parameter to 'Medium'. Allowed values are 'High',
    'Medium' and 'Low'. This configuration is applicable to reputation commands only.
  name: override_severity_suspicious
  options:
  - high
  - medium
  - low
  required: false
  type: 16
- display: Specify the numeric value of "confidence score". If the indicator's confidence
    score is equal or above the configured threshold, it would be considered as "malicious".
    The value provided should be greater than the suspicious threshold. This configuration
    is applicable to reputation commands only.
  name: override_confidence_score_malicious_threshold
  required: false
  type: 0
- display: Specify the numeric value of "confidence score". If the indicator's confidence
    score is equal or above the configured threshold, it would be considered as "suspicious".
    The value provided should be smaller than the malicious threshold. This configuration
    is applicable to reputation commands only.
  name: override_confidence_score_suspicious_threshold
  required: false
  type: 0
- display: Select the confidence score level. If the indicator's confidence score
    level is equal or above the configured level, it would be considered as "malicious".
    The confidence level configured should have higher precedence than the suspicious
    level. This configuration is applicable to reputation commands only. Refer the
    "confidence score" level precedence UNKNOWN SEVERITY < INFORMATIONAL < LOW < MEDIUM
    < HIGH.
  name: override_confidence_level_malicious
  options:
  - unknown_severity
  - informational
  - low
  - medium
  - high
  required: false
  type: 15
- display: |-
    Select the confidence score level. If the indicator's confidence score level is equal or above the configured level, it would be considered as "suspicious".
    The confidence level configured should have lesser precedence than the malicious level. This configuration is applicable to reputation commands only. Refer the "confidence score" level precedence UNKNOWN SEVERITY < INFORMATIONAL < LOW < MEDIUM < HIGH.
  name: override_confidence_level_suspicious
  options:
  - unknown_severity
  - informational
  - low
  - medium
  - high
  required: false
  type: 15
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: 3 days
  display: First fetch time interval. The time range to consider for initial data
    fetch.(<number> <unit>, e.g., 1 day, 7 days, 3 months, 1 year).
  name: first_fetch
  required: false
  type: 0
- defaultvalue: "10"
  display: How many incidents to fetch each time
  name: max_fetch
  required: false
  type: 0
- additionalinfo: Select Chronicle alert type to create actionable incident. Available
    options are IOC Domain matches(Default), Assets with alerts, Detection alerts
    and User alerts.
  defaultvalue: IOC Domain matches
  display: Chronicle Alert Type (Select the type of data to consider for fetch incidents).
  name: backstory_alert_type
  options:
  - IOC Domain matches
  - Assets with alerts
  - Detection alerts
  - User alerts
  required: false
  type: 15
- display: Select the severity of asset alerts to be filtered for Fetch Incidents.
    Available options are 'High', 'Medium', 'Low' and 'Unspecified' (Default-No Selection).
  name: incident_severity
  options:
  - High
  - Medium
  - Low
  - Unspecified
  required: false
  type: 15
- additionalinfo: 'Fetches detection by either Rule ID (format: ru_{UUID}) or Version
    ID (format: {ruleId}@v_{int64}_{int64}. Enter in comma separated format to add
    multiple. Entered rules have precedence over the "Fetch all rules detections"
    checkbox.'
  display: Detections to fetch by Rule ID or Version ID
  name: fetch_detection_by_ids
  required: false
  type: 0
- additionalinfo: Fetch detections for all versions of all the rules.
  display: Fetch all rules detections
  name: fetch_all_detections
  required: false
  type: 8
- additionalinfo: Select the alert state to filter the detections to be fetched using
    fetch incidents. Available options are 'ALERTING' and 'NOT_ALERTING' (Default-No
    Selection).
  display: Filter detections by alert state
  name: fetch_detection_by_alert_state
  options:
  - ALERTING
  - NOT_ALERTING
  required: false
  type: 15
- additionalinfo: Select the time window to query Chronicle. While selecting the time
    window consider the time delay for an event to appear in Chronicle after generation.
    Available options are 15 (Default), 30, 45 and 60. This parameter is not applied
    when "IOC Domain matches" Chronicle Alert Type is selected. Don't touch unless
    you're missing alerts.
  defaultvalue: "15"
  display: Time window (in minutes)
  name: time_window
  options:
  - "15"
  - "30"
  - "45"
  - "60"
  required: false
  type: 15
- additionalinfo: Sort detections by "DETECTION_TIME" or by "CREATED_TIME". If not
    specified, it defaults to "CREATED_TIME". This configuration is applicable to
    "Detection alerts" only.
  defaultvalue: CREATED_TIME
  display: List Basis
  name: fetch_detection_by_list_basis
  options:
  - CREATED_TIME
  - DETECTION_TIME
  required: false
  type: 15
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.0.20
    packID: GoogleChronicleBackstory
    packName: Chronicle
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Use the Chronicle integration to retrieve Asset alerts or IOC Domain
  matches as Incidents. Use it to fetch a list of infected assets based on the indicator
  accessed. This integration also provides reputation and threat enrichment of indicators
  observed in the enterprise.
detaileddescription: "### Partner Contributed Integration\n#### Integration Author:
  Chronicle\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email**: [chronicle-support@chronicle.security](mailto:chronicle-support@chronicle.security)\n-
  **URL**: [https://go.chronicle.security/contact](https://go.chronicle.security/contact)\n***\n##
  Configure an API account on Google Chronicle\n---\nYour Customer Experience Engineer
  (CEE) will provide you with a [Google Developer Service Account Credential](https://developers.google.com/identity/protocols/OAuth2#serviceaccount)
  to enable the Google API client to communicate with the Backstory API.\n\n### Reputation
  Calculation Algorithm\nChronicle provides the intelligence context to the indicators
  as provided by the configured threat intelligence sources. The IOC context properties
  provided by Chronicle are Severity, Category and Confidence Score. To provide the
  user with control over the reputation calculation, the integration configuration
  enables granular control over these properties. \n\n* Users can specify a list of
  categories, IoCs belonging to which should be considered as Malicious or Suspicious
  irrespective of its severity and confidence score. For example, if you want to consider
  all the IoCs of Category 'Blocked' as Malicious, configure the category within instance
  configuration. \n* Users can specify the Severity levels, indicators belonging to
  such severity would be considered as Malicious/Suspicious irrespective of the category
  and confidence score. \n* The confidence score provided by the Threat Intel sources
  can be numeric or a string representation (Low, Medium, or High). The configuration
  allows separate options to control reputation calculation based on the returned
  confidence score. The user can configure the raw confidence score threshold values(separate
  configuration for numeric score and string representation) to control the reputation
  calculation.\n\nNote: While evaluating the reputation of an indicator at multiple
  stages, if an indicator is found to be Malicious, the overall reputation remains
  'Malicious'. For example, if a category is configured with both Malicious and Suspicious
  categories, the IoCs belonging to such category would be considered Malicious.\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/google-chronicle-backstory)"
display: Chronicle (Partner Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAcCAYAAACqAXueAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAASwAAAABAAABLAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAeKADAAQAAAABAAAAHAAAAADxiZlLAAAACXBIWXMAAC4jAAAuIwF4pT92AAACaWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjE1MDE8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MzUzPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CkPj9EoAABO1SURBVGgF7Vp7eFXVld/7nHPfSSCEQI0PxLZ8LVTFISFap3ohgLVjteqE+aRCnuQF8TnaTnG+XqrIpyMfKgoEE0gI1kpGLeNUcQbhqjAqgrXa2BatUEujcA153Pe955w9v7XvPdckhBB0OuUPtubuc/Zee6+113vtA5+9IvQeY6yAMxYXjCl4/uKNM4MJkc0Y37dzWdbs1EYCW3Nsfab9LTigAWmBaveMM/U44xyy+DLNNJjqcjE9Gv5KZhsS7ZfcNrPXmYdT5oDGBEuQcIXQDWZ+SQtmzDB1U4NAE6dMyZkFfxUOaIILwYTBIGj84Jfj75RMzjJR9IKZwtShNJz2+kKttLRUzc3NVQ4UFIj8zk7anNF7T0+P2dHRYeJVjtG4BVtQUGD4fD6aO22b1+vTpkzp4k1NTTo8ZeYMoyFYCMFra2u1AwcKhN/v00ezxoLhJfdFe+1jnWMM2NyX9aRQFaY5GIv1hf+EGHy+RALi4PtPeiAISOns7OQQ4gmVgw46f/58JQ1D5H6+7yjxWAf/f+4H05pi9ee0j0zM0LUjQw+Z1XT3kf/hn036UNgiHsF1FxdqUgqEGHaKDRSbeow5wfc/ZpaOYhfSbghYamZ5Tc03hMGvgVZcAtcyHvtEkPv9Dltvh+a/inejpqbGtmHDhmRZZc08xpXphuDbtnD+B1KS082SLZrKKuvmg/5ilTlXtLSsPkbKejJLttZWVDScC09baqri4OYn1j+X4e0oHrTQOdecb6i/fe2dG9nKUcB/AZCRrdfr82l+CBdCGxM31Ue54Iuyc7LJ1zMDaYGiKEzVtB/EYtF/Kauq3WVyowrCPSgJ4fz28fkTvtt99GgP3v/Q1dWloj9tXDWFEAjJqKqq+xbTtKfdnizW39czATQuXL58OdF6MndLVY0pFGP62HHjV/Uc634f7yTgUVu1phgXTnTkFt9f9FS0honsW95a0PQ8NmDTfJ32fDb1lJkV7NrPswuCwu+bdTLiZQztgHCrqpZMihnGK9lZWZNCoaDe19+3CZXVf+Fon3KmuRHaL0OCX+/Jyp4VDoU+LK+uv7y1ed0biPWhaAQGzlmMaHY4HAp5A6+XMbh7MdTdk0UQHHo6FwesSrBoZnpMvhCcH27Dyxjz+/3Mv2uXMTTMkAVCSNxaR8KcNm2a9FcWbrwTDVjqCCT1+OFkIn4OrLYT2zI//aSbxOdnoD01jm4QPUKo8UgkDGh+DD+DGtExa9ZyeQ4/ZrxD1rLCp2/sKvzFDaLomVJRvO2fBN5/PuOZG86Su1DK9VdqRBhtDcbYy6rqOhtu+WdRVl2/9+aqhq8Nh7KysjIbcK/Aij9aVFNzHsEsqqp/Zultd4vyyrry4dZ4vV4qA487AwljGHgSllSQYeYY5mivYVsaz6A5a4z2pImFdXUTKiqWFA8CAm0n2pfGKRQRfHlV7XfrG+8QOP/r6fXyTCda603RKmGQ8QqFayoTSVM3kqbpyHffFA9E7NjoH71+rwr9PaklppGeUkdZIRYk3Tnjl3myPFPDoeCBiEOd3bF2bai01GfPze0SBw4cEGAU6+7uVtesWRNcuHDh91RVtbW1tPYSMiT8sCx64LIso/jNDP51k8Oz6/w3ra3rDxGc1UhJYEG2lpYWsgS+sKL+Cq6JcYbQ33qyufkwGEaJj3lzTc1Ziq5OY4rpUbjaFe4NvI05HX8U4wlGlDY0ZDmDpru9fX0AVq5XVtZfYHJzGuG2Ce2dlpbH/0R4AW+SMiM5JJr34V3Dn7UXWaq+YEF9rsPDLkJUyoXn6mV67B2M9xIs7UGNkA5safdPoc0WSYoiTdEmmIKFhF282+7zHSVYrFewgVQweietFnrw8xI2P5A/dF+C+79onJIkEOeO66JK16FDQrmLhFteXu5sbfVJl0uIyEWi6XSg9vZ28lPS6uH6iFDFNE0EXZG9qLr+UbvN0Whz25hpGCwSiRhlVfUPtrWs+wmtaWxsdPSHk3vx6F5UWV+lcPGQw+m82ImLmd6e7l9i/PqKisZ8U0k+CLW5OSvLo3GFs2QyyURO3kfwEveCYa3EUKLdEzcfUd1aZVll/XUoEmbbnI5bNRvhNoE7bJRX1z3Q2rx+GTEZSmXC+l5AX3Lo8JHLgOsNjMvwBxrvxftSh9M1Fsor845olPWUVdetAswKzFEQltZIz9QotHR0+PTyqvrSmCH+zeN2TbIRbvAiHA7Fyypr100+76w7CUdGuqmlsAeV/k8lRoH3A4M2TsN86c7r80kXmTCVmQ6n4+x4LH4wEvxsO23c2toaHw6BVRqBaKJZllLQPi0Rxw0cYys8LndjPBZ7NRQMPQThvorETHV73EjM6m6n/cLhsB2AeWDyeTje82DoxUjc9kC4B2DMneRSTUV/Mzs7pxz7JcKR0JOh/v6Hseceh8N5gcvj3rSosu5nJFzaDwEmV1XJPsQTUJJbY7H49lCwfyXw7ISgVJfb8xOEnCXEZIJHG+dyu+EwTfKOsoG2bVnZWfcoqjIWucSL4WBwbTQa3qVptly323NfeVXd4wSoKKZ1xygNjmphKNxi8G6r0+GcFI1GXwkGgw9FwqGfE3h2zpjbDv75E1JaBgoJP1w0fIOGZw/eutLxkQC+SBM+pnCf3HjY5VO6urgfM8IUU2x2B4OQ3iWLJCtNC3LYdbQEDBNWDIWLxoGRhmlaHqzmjraW9authWDeA6am3Y33pfh72OPxJPojyagCK4HH0OLxyD+0tTS9MAD+38HsycFg/2sJrpc+1dx8xJpbVF17M7L7zWDov1Ysrtuz6Yn1L4FhMBhczSrqhGgsUom9NmXgK+tW2kzzxyBvCcbW4g8VH9MNeBa4a6nci6pqf+TxZF0bCgYDiJI3bN64fre1vry69oZ4zHwGStIA178KEgoiDNG0XLuweulk3DyuM2CxiUT8ts0bmx6x1lZU1K7AGV7yeLK/X1ZRWyEtmNTCAwpQALOdpsq+kb6I8lurRtkTt3fBEkYS7qCtOPfAomANvI/GrSx0EMxIL5zrdoedJXX9BRIuWTe5YloinOqDMZgVGDoZSdm5iOHS1O02GJDgP21tbnrBggVTpsLobgz1B6M61xeQcGnOm050Njc3bcGW99vtdkiV3SpJwocVWDakpj/b1ty0iTwAhReaU0zlkVg0SpYzGXE/lbAiNtNZOVdkDMRTHQkcdnXr5o1rdxM+0E/xWQFtz0Ib6mDV8zduXPeRwQWZvtyafqCiZbBSNZFIbNzc8rlwaW7Tpqb3sXcjPQPjDzUbeheEu1P6ecF2Zx9mF7vfY/gkxHZdydgsAhxFEzNm2Pj+/UkETf3TeTMnH+42DhfS+0iN814BjgH9BAKj8mIk8OPmYBdUJ6P9B/1gvQYPIF28Fo0mDMXep3BlAh6k+gOPputJCECXlvvpp1pKwTm/3OP2sGB//68o2YKHsEuFwJ756Yybq+YWMHwZhtKZMI/BtRLal+lnypQpHFemUnimyZNcZSHYi1tP2lO4ASOVGRc3VAVo3HY+QsQRhyq20fq8vLwkhEtKgRjr1Ta3rG+iZ2qqmbl0kvNg0uUoubA9+xY81VaAOPBiQAfADW6ALWOi0QiOy4qVI0KB1WpspT0k/pL7a3a55xXmSpdbXuan/UdsW8EAabUQJvWBOYXrFMP8pSVcIMkc0NqI7pXpWTGM9+NxyqfEjB82NuaQeyYNtuCG6TklOYF0vYkT0E06/UQJFh6A9pX44nEPR5CQLk1Tk4CSjZtINQ1VlZWBx9Mjx8GCCZRQQQKHCAp33xY869i6VdJqxmwBWFw/psc1IIOGKcPfEm52fM5A1oHjEW0IH5m9YFmEw9B0nktJEdphxPQIeiqXJB4aRGKJpNJnR9VAETPd5LFSMILlUWIKhZmJfUqB41pN1a63adp1yD1uQG5QQvEDKzRlhqKzvTkfsR+PeZEV2HDDKDxQBenlTipestr5EMosEPTZnMLrpqrhD8Y7HHV0Cous4Xorzk6aVPBWUk/+3u1256uR5E0E29nXl0I+ZCEYgHyBCUpy/Cgt5DR5dxqU0kHugNhuLXM4wlTFS+bC3WXGh6OMm6I/5QHl1ai1hex9uMygB0UxSGw5OFs4EAhEwdy09Q/OcOWiIGjCA+GCIDK4KRDDTysJroYN6AdarnUuuS79k8pFfAmrarDmyMHTM3777chdoKvl0SAbkxSJSSLJzqa/mBE9V4/p55g2VoBQMUVrzt3DchwBpidpgcLs+NKnpPjCvNbOQ3oBS4WaGeSSu73F5xiq+WiWql4fQYnQG5deOaONQ5ZmXskScTjcJ9c/BmY8BqJXli1esrtt9epOOiB9QcoA44FgqaxC5r3MbVdWrkVJheFBMAPhR/N8JDtbKgCI3RePSScwj+IolChG/aFD5+tQGgRtFoHLvYquGlGGUEKIEqzOQQLjyBRHg0vCQItQwrm2bGx6B+uPwfou+OjjT4ow9zqdDV+LEhdeKGv+ePnihumM67HWDRt+T2US4cJ/0iNhm7dhqVei+pr+5JNr2rCePMugRhdGmzat/VDLVgNY58YkYtOJE1+52AeGXjNjhsr9finFIyUz79CZcf9YTXP0I9uAxZguRbEnEQVO1sBEaYVtG9c9jsNe58nKmgvm7URtV9vaso5SfKni1j4Q/rS4YawdOzb3it6+nosw/n1Loy2YU+2j7+URDo4s9HXQsBdZ7cxwhD+GsWqUa7IW9/uZXr548XSkCvciYQO0aJF4EM/B8ZHbkPm0l5CJGJKmp1CHL0kmko8gESsBP2D35J6ZvmhR3dnITbbb7a6JuMe+UGeiH7kEuQW5I37ao5Hw7cjbboOB7AIPZQ5iEYMPGw+53a470a/SdOHgminllXElFuDA3kqifPv3m91zii81hLl2nE29pFcXrA93YIC1Ab2Zlu1oLItKHvn1J5Ljuo71h3/l9nhm4QPDc2D2PjBjBxTmL/C/OfC0l8FSrsFdNOvt7enBjY9MQHBeahkrQpIzmKWgh3iiqWpqHAoohZQ+WH5+J5Vc8vMjV4xa1L5vof6sAmMuwtebVpRGnwF0JvAtzcrOcaBOfRblUErAsIjByAZyC3qQqj9RqaViMGBBKWhFDCZIbrruQe06Bx9WilAqvVteWbsGtxIfM5N/E05/Cc46Effub7a2rP9tWWXDPPr4AgcrBYUE7Nfg0Qoo5DIkU9vw3Ax8L6MaQb4sbnI6XXMpt0G9v0PDmfswPJGFZbJAce7zFgC4lUV2dCSPeqdlMdX9ABY1OJGv9eh6AoTTGpkxoI97VMUVN02pjcKHkDNCPQwBmzLerF5N/nE21YbQyltwIVBos9kLiSUUcOhmCh8hTPxtRVy5G67nzykiBTwV0CuKdF0DYzDNI0C7KZkxYsmUwgnmxAJmJpIZZSZ3Sx8oWp/wvbOwsvYy1NMbgb/IZrcVSeWBqIAXf32PQ7hUU9Naiu/QGxVdKhYTvkyjaI3PphCmXbelYjASQQcSoUxG1tr6cC9uzr6Dy5EtKLfm4eJlFVUUlE6gxGK4ut0WVs0y2lOopl3iEsiW0cA3Mox7cC+Pmz2+HJcz1eBTNRFGpRc84ce4Mq1ob2naqcEy7tDDyvOahzmNCIvCS9M/uUm1w+fY8QVeBqfA7MKboCGrc23aRAjWjNMNIUPITjWplWNtmutYUo9ALnfJ4c5S7NSRBhm+szJnEGyipnsAsWhNLBK+AqRcDKbQXWkEgvoA8Wh3e3PzQdoFMPK6UGPqXb29x1aj1HifxtNuH0twMxAMRlw5eSUoJ+xjsh2f0Bgm5uJmyhnN9XxI78AtcwW6GSIht2/07cPwRbhomAseF0JAWXABHyuG2NnW2vQBrbEs3uT6j3p7jq1mLg03YYNxX5Cf3/fHjz+5HIdXot3dAZrHXdQCMH6MKpLv0rsXSeMmn4/mrqpY3PDteDz+91Co8cD5Gf5eheW+QXDUnNx8Ldjf9x3VlipvwCs6I4fCrYR7b4NnmYuDfA0WmxAm/00k+JXtuMpMULklNxAvOyfpO+z/KfbYhNhvE4n/tj8tJ/DTO3vGV4+WFL0Yv+pS0Tt3pgiUFMXxbuJPUE/v/XOLRWTepfT+VPDqS/JpLZVP1h6j7GUJNBIsEUwWn4ax1NBaMvTdGj9Rfxz8gL2PW0MKgEFrjdVbcEPfrXGrHzov3yEossRhw9lIc9amgEkJ0BoY0KfpRfjaxTQ+K/XhGUL+AeLEL7hi7tJmG1cf/d6Me1hcWZ6jqUoQcRZzYG7KJYFCikG2cTaNHdONDzGxNG/H3pcIB9XDVDoNwHcqj1QTquRuKaZabne4f3dFTEBSgr+fwoMc/w8LSGAoaZATpmgZ8E4eR1r6cIQR4yy8NH9i3H7gxrfiE+CmteShqE/hngZafMfhJsVNX5TI86b//ZlcR2vR5Ldryhms/VLDjBEPQKul9EQr5TYZHFKTxFZcCOTDi0PQ4k2WF/tk3LXBh766ND/X8XeBSJwERQuk/8cCejazNNUGoROb7vPnne+jeliWT16vCQlJ12cRcab/23FACthCL/YxGy9MZWqBq4uuNOPs/nF27dskSF2gjEaz4XuqB9+P+5L6ziQ3lhbsePt3NL4Plx7W7RW9n2mnBwcGCZhIosyXTYU1z5eWyo7OmdmIbHYl3DTu/hiVRN3wGHdOeHlvm4SHYNn+/ZQqntDlEdyZdppxgNwtJCYV4EhJ8cRASeFzR0qKtnRfXYzrOlIEn2KVUKcZ6WfIGcCB/wWP06uPsiB8igAAAABJRU5ErkJggg==
name: Google Chronicle Backstory
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: Fetches IOC Domain matches in the specified time interval. If configured,
        overrides the start_time argument.
      name: preset_time_range
      predefined:
      - Last 1 day
      - Last 7 days
      - Last 15 days
      - Last 30 days
    - description: 'The value of the start time for your request, in RFC 3339 format
        (e.g. 2002-10-02T15:00:00Z) or relative time. If not supplied, the default
        is the UTC time corresponding to 3 days earlier than current time. Formats:
        YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours. Example: 2020-05-01T00:00:00Z,
        2020-05-01, 2 days, 5 hours.'
      name: start_time
    - defaultValue: "10000"
      description: The maximum number of IOCs to return. You can specify between 1
        and 10000. The default is 10000.
      name: page_size
    description: Lists the IOC Domain matches within your enterprise for the specified
      time interval. The indicator of compromise (IOC) domain matches lists for which
      the domains that your security infrastructure has flagged as both suspicious
      and that have been seen recently within your enterprise.
    name: gcb-list-iocs
    outputs:
    - contextPath: Domain.Name
      description: The domain name of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Iocs.Artifact
      description: The Indicator artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Iocs.IocIngestTime
      description: Time(UTC) the IOC was first seen by Chronicle.
      type: Date
    - contextPath: GoogleChronicleBackstory.Iocs.FirstAccessedTime
      description: Time(UTC) the artifact was first seen within your enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.Iocs.LastAccessedTime
      description: Time(UTC) the artifact was most recently seen within your enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.Iocs.Sources.Category
      description: Source Category represents the behavior of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Iocs.Sources.IntRawConfidenceScore
      description: The numeric confidence score of the IOC reported by the source.
      type: Number
    - contextPath: GoogleChronicleBackstory.Iocs.Sources.NormalizedConfidenceScore
      description: The normalized confidence score of the IOC reported by the source.
      type: String
    - contextPath: GoogleChronicleBackstory.Iocs.Sources.RawSeverity
      description: The severity of the IOC as reported by the source.
      type: String
    - contextPath: GoogleChronicleBackstory.Iocs.Sources.Source
      description: The source that reported the IOC.
      type: String
  - arguments:
    - default: true
      description: ' The artifact indicator associated with assets. The artifact type
        can be one of the following: IP, Domain, MD5, SHA1, or SHA256. '
      name: artifact_value
      required: true
    - auto: PREDEFINED
      description: Fetches assets that accessed the artifact during the interval specified.
        If configured, overrides the start_time and end_time arguments.
      name: preset_time_range
      predefined:
      - Last 1 day
      - Last 7 days
      - Last 15 days
      - Last 30 days
    - description: 'The value of the start time for your request, in RFC 3339 format
        (e.g. 2002-10-02T15:00:00Z) or relative time. If not supplied, the default
        is the UTC time corresponding to 3 days earlier than current time. Formats:
        YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours. Example: 2020-05-01T00:00:00Z,
        2020-05-01, 2 days, 5 hours.'
      name: start_time
    - description: 'The value of the end time for your request, in RFC 3339 format
        (e.g. 2002-10-02T15:00:00Z) or relative time. If not supplied,  the default
        is current UTC time. Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N
        hours. Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.'
      name: end_time
    - description: The maximum number of IOCs to return. You can specify between 1
        and 10000. The default is 10000.
      name: page_size
    description: Returns a list of the assets that accessed the input artifact (IP,
      domain, MD5, SHA1 and SHA256) during the specified time.
    name: gcb-assets
    outputs:
    - contextPath: GoogleChronicleBackstory.Asset.HostName
      description: The hostname of the asset that accessed the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.IpAddress
      description: The IP address of the asset that accessed the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.MacAddress
      description: The MAC address of the asset that accessed the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.ProductId
      description: The Product ID of the asset that accessed the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.AccessedDomain
      description: The domain artifact accessed by the asset.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.AccessedIP
      description: The IP address artifact accessed by the asset.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.AccessedMD5
      description: The MD5 file hash artifact accessed by the asset.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.AccessedSHA1
      description: The SHA1 file hash artifact accessed by the asset.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.AccessedSHA256
      description: The SHA256 file hash artifact accessed by the asset.
      type: String
    - contextPath: GoogleChronicleBackstory.Asset.FirstAccessedTime
      description: The time when the asset first accessed the artifact.
      type: Date
    - contextPath: GoogleChronicleBackstory.Asset.LastAccessedTime
      description: The time when the asset last accessed the artifact.
      type: Date
    - contextPath: Host.Hostname
      description: The hostname of the asset that accessed the artifact.
      type: String
    - contextPath: Host.ID
      description: The Product ID of the asset that accessed the artifact.
      type: String
    - contextPath: Host.IP
      description: The IP address of the asset that accessed the artifact.
      type: String
    - contextPath: Host.MACAddress
      description: The MAC address of the asset that accessed the artifact.
      type: String
  - arguments:
    - default: true
      description: The IP address to check.
      isArray: true
      name: ip
      required: true
    description: Checks the reputation of an IP address.
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: 'The reputation score (0: Unknown, 1: Good, 2: Suspicious, 3: Bad)'
      type: Number
    - contextPath: IP.Address
      description: The IP address of the artifact.
      type: String
    - contextPath: IP.Malicious.Vendor
      description: For malicious IPs, the vendor that made the decision.
      type: String
    - contextPath: IP.Malicious.Description
      description: For malicious IPs, the reason that the vendor made the decision.
      type: String
    - contextPath: GoogleChronicleBackstory.IP.IoCQueried
      description: The artifact that was queried.
      type: String
    - contextPath: GoogleChronicleBackstory.IP.Sources.Address.IpAddress
      description: The IP address of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IP.Sources.Address.Domain
      description: The domain name of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IP.Sources.Address.Port
      description: The port number of the artifact.
      type: Number
    - contextPath: GoogleChronicleBackstory.IP.Sources.Category
      description: The behavior of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IP.Sources.ConfidenceScore
      description: The confidence score indicating the accuracy and appropriateness
        of the assigned category.
      type: Number
    - contextPath: GoogleChronicleBackstory.IP.Sources.FirstAccessedTime
      description: The time the IOC was first accessed within the enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.IP.Sources.LastAccessedTime
      description: The time the IOC was most recently seen within your enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.IP.Sources.Severity
      description: Impact of the artifact on the enterprise.
      type: String
  - arguments:
    - default: true
      description: The domain name to check.
      isArray: true
      name: domain
      required: true
    description: Checks the reputation of a domain.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: 'The reputation score (0: Unknown, 1: Good, 2: Suspicious, 3: Bad)'
      type: Number
    - contextPath: Domain.Name
      description: The domain name of the artifact.
      type: String
    - contextPath: Domain.Malicious.Vendor
      description: For malicious domains, the vendor that made the decision.
      type: String
    - contextPath: Domain.Malicious.Description
      description: For malicious domains, the reason that the vendor made the decision.
      type: String
    - contextPath: GoogleChronicleBackstory.Domain.IoCQueried
      description: The domain that queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Domain.Sources.Address.IpAddress
      description: The IP address of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Domain.Sources.Address.Domain
      description: The domain name of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Domain.Sources.Address.Port
      description: The port number of the artifact.
      type: Number
    - contextPath: GoogleChronicleBackstory.Domain.Sources.Category
      description: The behavior of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.Domain.Sources.ConfidenceScore
      description: The confidence score indicating the accuracy and appropriateness
        of the assigned category.
      type: Number
    - contextPath: GoogleChronicleBackstory.Domain.Sources.FirstAccessedTime
      description: The time the IOC was first accessed within the enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.Domain.Sources.LastAccessedTime
      description: The time the IOC was most recently seen within your enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.Domain.Sources.Severity
      description: Impact of the artifact on the enterprise.
      type: String
  - arguments:
    - description: The artifact indicator value. The supported artifact types are
        IP and domain.
      name: artifact_value
      required: true
    description: Accepts an artifact indicator and returns any threat intelligence
      associated with the artifact. The threat intelligence information is drawn from
      your enterprise security systems and from Chronicle's IoC partners (for example,
      the DHS threat feed).
    name: gcb-ioc-details
    outputs:
    - contextPath: Domain.Name
      description: The domain name of the artifact.
      type: String
    - contextPath: IP.Address
      description: The IP address of the of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IocDetails.IoCQueried
      description: The artifact entered by the user.
      type: String
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.Address.IpAddress
      description: The IP address of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.Address.Domain
      description: The domain name of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.Address.Port
      description: The port number of the artifact.
      type: Number
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.Category
      description: The behavior of the artifact.
      type: String
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.ConfidenceScore
      description: The confidence score indicating the accuracy and appropriateness
        of the assigned category.
      type: Number
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.FirstAccessedTime
      description: The time the IOC was first accessed within the enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.LastAccessedTime
      description: The time the IOC was most recently seen within your enterprise.
      type: Date
    - contextPath: GoogleChronicleBackstory.IocDetails.Sources.Severity
      description: Impact of the artifact on the enterprise.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: Fetch alerts for the specified time range. If preset_time_range
        is configured, overrides the start_time and end_time arguments.
      name: preset_time_range
      predefined:
      - Last 1 day
      - Last 7 days
      - Last 15 days
      - Last 30 days
    - description: 'The value of the start time for your request, in RFC 3339 format
        (e.g. 2002-10-02T15:00:00Z) or relative time. If not supplied, the default
        is the UTC time corresponding to 3 days earlier than current time. Formats:
        YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours. Example: 2020-05-01T00:00:00Z,
        2020-05-01, 2 days, 5 hours.'
      name: start_time
    - description: 'The value of the end time for your request, in RFC 3339 format
        (e.g. 2002-10-02T15:00:00Z) or relative time. If not supplied,  the default
        is current UTC time. Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N
        hours. Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.'
      name: end_time
    - defaultValue: "10000"
      description: The maximum number of IOCs to return. You can specify between 1
        and 10000. The default is 10000.
      name: page_size
    - auto: PREDEFINED
      description: The severity by which to filter the returned alerts. If not supplied,
        all alerts are fetched. This is applicable for asset alerts only. The possible
        values are "High", "Medium", "Low", or "Unspecified".
      name: severity
      predefined:
      - High
      - Medium
      - Low
      - Unspecified
    - auto: PREDEFINED
      defaultValue: Asset Alerts
      description: Specify which type of alerts you want. The possible values are
        "Asset Alerts" or "User Alerts".
      name: alert_type
      predefined:
      - Asset Alerts
      - User Alerts
    description: List all the alerts tracked within your enterprise for the specified
      time range. Both the parsed alerts and their corresponding raw alert logs are
      returned.
    name: gcb-list-alerts
    outputs:
    - contextPath: GoogleChronicleBackstory.Alert.AssetName
      description: The asset identifier. It can be IP Address, MAC Address, Hostname
        or Product ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Alert.AlertInfo.Name
      description: The name of the alert.
      type: String
    - contextPath: GoogleChronicleBackstory.Alert.AlertInfo.Severity
      description: The severity of the alert.
      type: String
    - contextPath: GoogleChronicleBackstory.Alert.AlertInfo.SourceProduct
      description: The source of the alert.
      type: String
    - contextPath: GoogleChronicleBackstory.Alert.AlertInfo.Timestamp
      description: The time of the alert in Chronicle.
      type: String
    - contextPath: GoogleChronicleBackstory.Alert.AlertCounts
      description: The total number of alerts.
      type: Number
    - contextPath: GoogleChronicleBackstory.UserAlert.User
      description: The user identifier. It can be username or email address.
      type: String
    - contextPath: GoogleChronicleBackstory.UserAlert.AlertInfo.Name
      description: The name of the user alert.
      type: String
    - contextPath: GoogleChronicleBackstory.UserAlert.AlertInfo.SourceProduct
      description: The source of the user alert.
      type: String
    - contextPath: GoogleChronicleBackstory.UserAlert.AlertInfo.Timestamp
      description: The time of the user alert in Chronicle.
      type: String
    - contextPath: GoogleChronicleBackstory.UserAlert.AlertInfo.RawLog
      description: The raw log of the user alert.
      type: String
    - contextPath: GoogleChronicleBackstory.UserAlert.AlertCounts
      description: The total number of user alerts.
      type: Number
  - arguments:
    - auto: PREDEFINED
      description: Specify the identifier type of the asset you are investigating.
        The possible values are Host Name, IP Address, MAC Address or Product ID.
      name: asset_identifier_type
      predefined:
      - Host Name
      - IP Address
      - MAC Address
      - Product ID
      required: true
    - description: Value of the asset identifier.
      name: asset_identifier
      required: true
    - auto: PREDEFINED
      description: Get events that are discovered during the interval specified. If
        configured, overrides the start_time and end_time arguments.
      name: preset_time_range
      predefined:
      - Last 1 day
      - Last 7 days
      - Last 15 days
      - Last 30 days
    - description: ' The value of the start time for your request. The format of Date
        should comply with RFC 3339 (e.g. 2002-10-02T15:00:00Z) or relative time.
        If not supplied, the product considers UTC time corresponding to 2 hours earlier
        than current time. Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours.
        Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.'
      name: start_time
    - description: 'The value of the end time for your request. The format of Date
        should comply with RFC 3339 (e.g. 2002-10-02T15:00:00Z) or relative time.
        If not supplied, the product considers current UTC time. Formats: YYYY-MM-ddTHH:mm:ssZ,
        YYYY-MM-dd, N days, N hours. Example: 2020-05-01T00:00:00Z, 2020-05-01, 2
        days, 5 hours.'
      name: end_time
    - defaultValue: "100"
      description: Specify the maximum number of events to fetch. You can specify
        between 1 and 1000. The default is 100.
      name: page_size
    - description: 'Specify the reference time for the asset you are investigating,
        in RFC 3339 format (e.g. 2002-10-02T15:00:00Z) or relative time. If not supplied,
        the product considers start time as reference time. Formats: YYYY-MM-ddTHH:mm:ssZ,
        YYYY-MM-dd, N days, N hours. Example: 2020-05-01T00:00:00Z, 2020-05-01, 2
        days, 5 hours.'
      name: reference_time
    description: List all of the events discovered within your enterprise on a particular
      device within the specified time range. If you receive the maximum number of
      events you specified using the page_size parameter (or 100, the default), there
      might still be more events within your Chronicle account. You can narrow the
      time range and issue the call again to ensure you have visibility into all possible
      events. This command returns more than 60 different types of events. Any event
      would have only specific output context set. Refer the UDM documentation to
      figure out the output properties specific to the event types.
    name: gcb-list-events
    outputs:
    - contextPath: GoogleChronicleBackstory.Events.eventType
      description: Specifies the type of the event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.eventTimestamp
      description: The GMT timestamp when the event was generated.
      type: Date
    - contextPath: GoogleChronicleBackstory.Events.collectedTimestamp
      description: The GMT timestamp when the event was collected by the vendor's
        local collection infrastructure.
      type: Date
    - contextPath: GoogleChronicleBackstory.Events.description
      description: Human-readable description of the event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.productEventType
      description: Short, descriptive, human-readable, and product-specific event
        name or type.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.productLogId
      description: A vendor-specific event identifier to uniquely identify the event
        (a GUID). Users might use this identifier to search the vendor's proprietary
        console for the event in question.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.productName
      description: Specifies the name of the product.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.productVersion
      description: Specifies the version of the product.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.urlBackToProduct
      description: URL linking to a relevant website where you can view more information
        about this specific event or the general event category.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.vendorName
      description: Specifies the product vendor's name.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.mac
      description: MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.principal.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.target.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.intermediary.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.src.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.observer.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.about.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.applicationProtocol
      description: Indicates the network application protocol.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.direction
      description: Indicates the direction of network traffic.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email
      description: Specifies the email address for the sender/recipient.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.ipProtocol
      description: Indicates the IP protocol.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.receivedBytes
      description: Specifies the number of bytes received.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.sentBytes
      description: Specifies the number of bytes sent.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.clientHostname
      description: Hostname for the client.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.clientIdentifier
      description: Client identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.file
      description: Filename for the boot image.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.flags
      description: Value for the DHCP flags field.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.hlen
      description: Hardware address length.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.hops
      description: DHCP hop count.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.htype
      description: Hardware address type.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.leaseTimeSeconds
      description: Client-requested lease time for an IP address in seconds.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.opcode
      description: BOOTP op code.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.requestedAddress
      description: Client identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.seconds
      description: Seconds elapsed since the client began the address acquisition/renewal
        process.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.sname
      description: Name of the server which the client has requested to boot from.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.transactionId
      description: Client transaction ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.type
      description: DHCP message type.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.chaddr
      description: IP address for the client hardware.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.ciaddr
      description: IP address for the client.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.giaddr
      description: IP address for the relay agent.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.siaddr
      description: IP address for the next bootstrap server.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dhcp.yiaddr
      description: Your IP address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authoritative
      description: Set to true for authoritative DNS servers.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.id
      description: Stores the DNS query identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.response
      description: Set to true if the event is a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.opcode
      description: Stores the DNS OpCode used to specify the type of DNS query (standard,
        inverse, server status, etc.).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.recursionAvailable
      description: Set to true if a recursive DNS lookup is available.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.recursionDesired
      description: Set to true if a recursive DNS lookup is requested.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.responseCode
      description: Stores the DNS response code as defined by RFC 1035, Domain Names
        - Implementation and Specification.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.truncated
      description: Set to true if this is a truncated DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.questions.name
      description: Stores the domain name.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.questions.class
      description: Stores the code specifying the class of the query.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.questions.type
      description: Stores the code specifying the type of the query.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.answers.binaryData
      description: Stores the raw bytes of any non-UTF8 strings that might be included
        as part of a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.answers.class
      description: Stores the code specifying the class of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.answers.data
      description: Stores the payload or response to the DNS question for all responses
        encoded in UTF-8 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.answers.name
      description: Stores the name of the owner of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.answers.ttl
      description: Stores the time interval for which the resource record can be cached
        before the source of the information should again be queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.answers.type
      description: Stores the code specifying the type of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authority.binaryData
      description: Stores the raw bytes of any non-UTF8 strings that might be included
        as part of a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authority.class
      description: Stores the code specifying the class of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authority.data
      description: Stores the payload or response to the DNS question for all responses
        encoded in UTF-8 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authority.name
      description: Stores the name of the owner of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authority.ttl
      description: Stores the time interval for which the resource record can be cached
        before the source of the information should again be queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.authority.type
      description: Stores the code specifying the type of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.additional.binaryData
      description: Stores the raw bytes of any non-UTF8 strings that might be included
        as part of a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.additional.class
      description: Stores the code specifying the class of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.additional.data
      description: Stores the payload or response to the DNS question for all responses
        encoded in UTF-8 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.additional.name
      description: Stores the name of the owner of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.additional.ttl
      description: Stores the time interval for which the resource record can be cached
        before the source of the information should again be queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.dns.additional.type
      description: Stores the code specifying the type of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.from
      description: Stores the from email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.replyTo
      description: Stores the reply_to email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.to
      description: Stores the to email addresses.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.cc
      description: Stores the cc email addresses.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.bcc
      description: Stores the bcc email addresses.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.mailId
      description: Stores the mail (or message) ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.email.subject
      description: Stores the email subject line.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.ftp.command
      description: Stores the FTP command.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.http.method
      description: Stores the HTTP request method.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.http.referralUrl
      description: Stores the URL for the HTTP referer.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.http.responseCode
      description: Stores the HTTP response status code, which indicates whether a
        specific HTTP request has been successfully completed.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.network.http.useragent
      description: Stores the User-Agent request header which includes the application
        type, operating system, software vendor or software version of the requesting
        software user agent.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.authentication.authType
      description: Type of system an authentication event is associated with (Chronicle
        UDM).
      type: String
    - contextPath: GoogleChronicleBackstory.Events.authentication.mechanism
      description: Mechanism(s) used for authentication.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.about
      description: Provide a description of the security result.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.action
      description: Specify a security action.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.category
      description: Specify a security category.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.confidence
      description: Specify a confidence with regards to a security event as estimated
        by the product.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.confidenceDetails
      description: Additional detail with regards to the confidence of a security
        event as estimated by the product vendor.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.priority
      description: Specify a priority with regards to a security event as estimated
        by the product vendor.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.priorityDetails
      description: Vendor-specific information about the security result priority.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.ruleId
      description: Identifier for the security rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.ruleName
      description: Name of the security rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.severity
      description: Severity of a security event as estimated by the product vendor
        using values defined by the Chronicle UDM.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.severityDetails
      description: Severity for a security event as estimated by the product vendor.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.threatName
      description: Name of the security threat.
      type: String
    - contextPath: GoogleChronicleBackstory.Events.securityResult.urlBackToProduct
      description: URL to direct you to the source product console for this security
        event.
      type: String
  - arguments:
    - default: true
      description: |-
        Unique identifier for a rule or specific version of a rule, defined and returned by the server. You can specify exactly one rule identifier.
        Use the following format to specify the id:
         ru_{UUID} or {ruleId}@v_{int64}_{int64}. If not specified then detections for all versions of all rules are returned.
      name: id
    - description: |-
        (Deprecated: use `start_time` instead) Time to begin returning detections, filtering on a detection's "detectionTime". If not specified, the start time is treated as open-ended.
        Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours.
        Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.
      name: detection_start_time
    - description: |-
        (Deprecated: use `end_time` instead) Time to stop returning detections, filtering on a detection's "detectionTime". If not specified, the end time is treated as open-ended.
        Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours.
        Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.
      name: detection_end_time
    - auto: PREDEFINED
      description: |-
        Filter detections on if they are ALERTING or NOT_ALERTING.
        Avoid specifying to return all detections.
      name: alert_state
      predefined:
      - ALERTING
      - NOT_ALERTING
    - defaultValue: "100"
      description: Specify the limit on the number of detections to display. You can
        specify between 1 and 1,000.
      name: page_size
    - description: A page token received from a previous call. Provide this to retrieve
        the subsequent page. If the page token is configured, overrides the detection
        start and end time arguments.
      name: page_token
    - auto: PREDEFINED
      defaultValue: "False"
      description: |-
        Whether the user wants to retrieve detections for all versions of a rule with a given rule identifier.

        Note: If this option is set to true, rule id is required.
      name: detection_for_all_versions
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: |-
        Sort detections by "DETECTION_TIME" or by "CREATED_TIME". If not specified, it defaults to "DETECTION_TIME". Detections are returned in descending order of the timestamp.

        Note: Requires either "start_time" or "end_time" argument.
      name: list_basis
      predefined:
      - DETECTION_TIME
      - CREATED_TIME
    - description: |-
        Time to begin returning detections, filtering by the detection field specified in the listBasis parameter. If not specified, the start time is treated as open-ended.
        Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours.
        Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.
      name: start_time
    - description: |-
        Time to stop returning detections, filtering by the detection field specified by the listBasis parameter. If not specified, the end time is treated as open-ended.
        Formats: YYYY-MM-ddTHH:mm:ssZ, YYYY-MM-dd, N days, N hours.
        Example: 2020-05-01T00:00:00Z, 2020-05-01, 2 days, 5 hours.
      name: end_time
    description: Return the detections for the specified version of a rule, the latest
      version of a rule, all versions of a rule, or all versions of all rules.
    name: gcb-list-detections
    outputs:
    - contextPath: GoogleChronicleBackstory.Detections.id
      description: Identifier for the detection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.ruleId
      description: Identifier for the rule generating the detection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.ruleVersion
      description: Identifier for the rule version generating the detection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.ruleName
      description: Name of the rule generating the detection, as parsed from ruleText.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.timeWindowStartTime
      description: The start time of the window the detection was found in.
      type: Date
    - contextPath: GoogleChronicleBackstory.Detections.timeWindowEndTime
      description: The end time of the window the detection was found in.
      type: Date
    - contextPath: GoogleChronicleBackstory.Detections.alertState
      description: Indicates whether the rule generating this detection currently
        has alerting enabled or disabled.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.urlBackToProduct
      description: URL pointing to the Chronicle UI for this detection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.type
      description: Type of detection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.createdTime
      description: Time the detection was created.
      type: Date
    - contextPath: GoogleChronicleBackstory.Detections.detectionTime
      description: The time period the detection was found in.
      type: Date
    - contextPath: GoogleChronicleBackstory.Detections.ruleType
      description: Whether the rule generating this detection is a single event or
        multi-event rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.detectionFields.key
      description: The key for a field specified in the rule, for MULTI_EVENT rules.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.detectionFields.value
      description: The value for a field specified in the rule, for MULTI_EVENT rules.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.label
      description: The variable a given set of UDM events belongs to.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principalAssetIdentifier
      description: Specifies the principal asset identifier of the event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.targetAssetIdentifier
      description: Specifies the target asset identifier of the event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.eventType
      description: Specifies the type of the event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.eventTimestamp
      description: The GMT timestamp when the event was generated.
      type: Date
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.ingestedTimestamp
      description: The GMT timestamp when the event was ingested in the vendor's instance.
      type: Date
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.description
      description: Human-readable description of the event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.productEventType
      description: Short, descriptive, human-readable, and product-specific event
        name or type.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.productLogId
      description: A vendor-specific event identifier to uniquely identify the event
        (a GUID). Users might use this identifier to search the vendor's proprietary
        console for the event in question.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.productName
      description: Specifies the name of the product.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.productVersion
      description: Specifies the version of the product.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.urlBackToProduct
      description: URL linking to a relevant website where you can view more information
        about this specific event or the general event category.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.vendorName
      description: Specifies the product vendor's name.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.mac
      description: MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.principal.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.target.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.intermediary.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.src.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.observer.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.assetId
      description: Vendor-specific unique device identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.email
      description: Email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.hostname
      description: Client hostname or domain name field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.platform
      description: Platform operating system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.platformPatchLevel
      description: Platform operating system patch level.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.platformVersion
      description: Platform operating system version.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.ip
      description: IP address associated with a network connection.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.port
      description: Source or destination network port number when a specific network
        connection is described within an event.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.mac
      description: One or more MAC addresses associated with a device.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.administrativeDomain
      description: Domain which the device belongs to (for example, the Windows domain).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.url
      description: Standard URL.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.commandLine
      description: Stores the command line string for the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.productSpecificProcessId
      description: Stores the product specific process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.productSpecificParentProcessId
      description: Stores the product specific process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file
      description: Stores the file name of the file in use by the process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.fileMetadata
      description: Metadata associated with the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.fullPath
      description: Full path identifying the location of the file on the system.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.md5
      description: MD5 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.mimeType
      description: Multipurpose Internet Mail Extensions (MIME) type of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.sha1
      description: SHA-1 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.sha256
      description: SHA-256 hash value of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.file.size
      description: Size of the file.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.parentPid
      description: Stores the process ID for the parent process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.process.pid
      description: Stores the process ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.registry.registryKey
      description: Stores the registry key associated with an application or system
        component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.registry.registryValueName
      description: Stores the name of the registry value associated with an application
        or system component.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.registry.registryValueData
      description: Stores the data associated with a registry value.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.emailAddresses
      description: Stores the email addresses for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.employeeId
      description: Stores the human resources employee ID for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.firstName
      description: Stores the first name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.middleName
      description: Stores the middle name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.lastName
      description: Stores the last name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.groupid
      description: Stores the group ID associated with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.phoneNumbers
      description: Stores the phone numbers for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.title
      description: Stores the job title for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.userDisplayName
      description: Stores the display name for the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.userid
      description: Stores the user ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.about.user.windowsSid
      description: Stores the Microsoft Windows security identifier (SID) associated
        with a user.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.applicationProtocol
      description: Indicates the network application protocol.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.direction
      description: Indicates the direction of network traffic.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email
      description: Specifies the email address for the sender/recipient.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.ipProtocol
      description: Indicates the IP protocol.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.receivedBytes
      description: Specifies the number of bytes received.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.sentBytes
      description: Specifies the number of bytes sent.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.clientHostname
      description: Hostname for the client.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.clientIdentifier
      description: Client identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.file
      description: Filename for the boot image.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.flags
      description: Value for the DHCP flags field.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.hlen
      description: Hardware address length.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.hops
      description: DHCP hop count.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.htype
      description: Hardware address type.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.leaseTimeSeconds
      description: Client-requested lease time for an IP address in seconds.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.opcode
      description: BOOTP op code.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.requestedAddress
      description: Client identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.seconds
      description: Seconds elapsed since the client began the address acquisition/renewal
        process.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.sname
      description: Name of the server which the client has requested to boot from.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.transactionId
      description: Client transaction ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.type
      description: DHCP message type.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.chaddr
      description: IP address for the client hardware.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.ciaddr
      description: IP address for the client.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.giaddr
      description: IP address for the relay agent.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.siaddr
      description: IP address for the next bootstrap server.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dhcp.yiaddr
      description: Your IP address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authoritative
      description: Set to true for authoritative DNS servers.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.id
      description: Stores the DNS query identifier.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.response
      description: Set to true if the event is a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.opcode
      description: Stores the DNS OpCode used to specify the type of DNS query (standard,
        inverse, server status, etc.).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.recursionAvailable
      description: Set to true if a recursive DNS lookup is available.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.recursionDesired
      description: Set to true if a recursive DNS lookup is requested.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.responseCode
      description: Stores the DNS response code as defined by RFC 1035, Domain Names
        - Implementation and Specification.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.truncated
      description: Set to true if this is a truncated DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.questions.name
      description: Stores the domain name.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.questions.class
      description: Stores the code specifying the class of the query.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.questions.type
      description: Stores the code specifying the type of the query.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.answers.binaryData
      description: Stores the raw bytes of any non-UTF8 strings that might be included
        as part of a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.answers.class
      description: Stores the code specifying the class of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.answers.data
      description: Stores the payload or response to the DNS question for all responses
        encoded in UTF-8 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.answers.name
      description: Stores the name of the owner of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.answers.ttl
      description: Stores the time interval for which the resource record can be cached
        before the source of the information should again be queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.answers.type
      description: Stores the code specifying the type of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authority.binaryData
      description: Stores the raw bytes of any non-UTF8 strings that might be included
        as part of a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authority.class
      description: Stores the code specifying the class of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authority.data
      description: Stores the payload or response to the DNS question for all responses
        encoded in UTF-8 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authority.name
      description: Stores the name of the owner of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authority.ttl
      description: Stores the time interval for which the resource record can be cached
        before the source of the information should again be queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.authority.type
      description: Stores the code specifying the type of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.additional.binaryData
      description: Stores the raw bytes of any non-UTF8 strings that might be included
        as part of a DNS response.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.additional.class
      description: Stores the code specifying the class of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.additional.data
      description: Stores the payload or response to the DNS question for all responses
        encoded in UTF-8 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.additional.name
      description: Stores the name of the owner of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.additional.ttl
      description: Stores the time interval for which the resource record can be cached
        before the source of the information should again be queried.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.dns.additional.type
      description: Stores the code specifying the type of the resource record.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.from
      description: Stores the from email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.replyTo
      description: Stores the reply_to email address.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.to
      description: Stores the to email addresses.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.cc
      description: Stores the cc email addresses.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.bcc
      description: Stores the bcc email addresses.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.mailId
      description: Stores the mail (or message) ID.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.email.subject
      description: Stores the email subject line.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.ftp.command
      description: Stores the FTP command.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.http.method
      description: Stores the HTTP request method.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.http.referralUrl
      description: Stores the URL for the HTTP referer.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.http.responseCode
      description: Stores the HTTP response status code, which indicates whether a
        specific HTTP request has been successfully completed.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.network.http.useragent
      description: Stores the User-Agent request header which includes the application
        type, operating system, software vendor or software version of the requesting
        software user agent.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.authentication.authType
      description: Type of system an authentication event is associated with (Chronicle
        UDM).
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.authentication.mechanism
      description: Mechanism(s) used for authentication.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.about
      description: Provide a description of the security result.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.action
      description: Specify a security action.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.category
      description: Specify a security category.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.confidence
      description: Specify a confidence with regards to a security event as estimated
        by the product.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.confidenceDetails
      description: Additional detail with regards to the confidence of a security
        event as estimated by the product vendor.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.priority
      description: Specify a priority with regards to a security event as estimated
        by the product vendor.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.priorityDetails
      description: Vendor-specific information about the security result priority.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.ruleId
      description: Identifier for the security rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.ruleName
      description: Name of the security rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.severity
      description: Severity of a security event as estimated by the product vendor
        using values defined by the Chronicle UDM.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.severityDetails
      description: Severity for a security event as estimated by the product vendor.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.threatName
      description: Name of the security threat.
      type: String
    - contextPath: GoogleChronicleBackstory.Detections.collectionElements.references.securityResult.urlBackToProduct
      description: URL to direct you to the source product console for this security
        event.
      type: String
    - contextPath: GoogleChronicleBackstory.Token.name
      description: The name of the command to which the value of the nextPageToken
        corresponds.
      type: String
    - contextPath: GoogleChronicleBackstory.Token.nextPageToken
      description: A page token that can be provided to the next call to view the
        next page of detections. Absent if this is the last page.
      type: String
  - arguments:
    - defaultValue: "100"
      description: Specify the maximum number of Rules to return. You can specify
        between 1 and 1,000. The default is 100.
      name: page_size
    - description: A page token, received from a previous call.  Provide this to retrieve
        the subsequent page.
      name: page_token
    - auto: PREDEFINED
      description: To filter live rules.
      name: live_rule
      predefined:
      - "true"
      - "false"
    description: List the latest versions of all Rules.
    name: gcb-list-rules
    outputs:
    - contextPath: GoogleChronicleBackstory.Rules.ruleId
      description: Unique identifier for a Rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.versionId
      description: Unique identifier for a specific version of a rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.ruleName
      description: Name of the rule, as parsed from ruleText.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.ruleText
      description: Source code for the rule, as defined by the user.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.liveRuleEnabled
      description: Whether the rule is enabled to run as a Live Rule.
      type: Boolean
    - contextPath: GoogleChronicleBackstory.Rules.alertingEnabled
      description: Whether the rule is enabled to generate Alerts.
      type: Boolean
    - contextPath: GoogleChronicleBackstory.Rules.versionCreateTime
      description: A string representing the time in ISO-8601 format.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.compilationState
      description: Compilation state of the rule. It can be SUCCEEDED or FAILED.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.compilationError
      description: A compilation error if compilationState is FAILED, absent if compilationState
        is SUCCEEDED.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.Metadata.severity
      description: Severity for the rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.Metadata.author
      description: Name of author for the rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.Metadata.description
      description: Description of the rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.Metadata.reference
      description: Reference link for the rule.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.Metadata.created
      description: Time at which the rule is created.
      type: String
    - contextPath: GoogleChronicleBackstory.Rules.Metadata.updated
      description: Time at which the rule is updated.
      type: String
    - contextPath: GoogleChronicleBackstory.Token.name
      description: The name of the command to which the value of the nextPageToken
        corresponds.
      type: String
    - contextPath: GoogleChronicleBackstory.Token.nextPageToken
      description: A page token that can be provided to the next call to view the
        next page of Rules. Absent if this is the last page.
      type: String
  dockerimage: demisto/googleapi-python3:1.0.0.29031
  isfetch: true
  runonce: false
  script: |
    register_module_line('Google Chronicle Backstory', 'start', __line__())
    """Main file for GoogleChronicleBackstory Integration."""


    from collections import defaultdict
    from typing import Any, Dict, Tuple, List
    import httplib2
    import urllib.parse
    from oauth2client import service_account
    from copy import deepcopy
    import dateparser
    from hashlib import sha256

    # A request will be tried 3 times if it fails at the socket/connection level
    httplib2.RETRIES = 3

    ''' CONSTANTS '''

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%S.%fZ'

    SCOPES = ['https://www.googleapis.com/auth/chronicle-backstory']

    BACKSTORY_API_V1_URL = 'https://{}backstory.googleapis.com/v1'
    BACKSTORY_API_V2_URL = 'https://{}backstory.googleapis.com/v2'
    MAX_ATTEMPTS = 60
    DEFAULT_FIRST_FETCH = "3 days"
    REGIONS = {
        "General": "",
        "Europe": "europe-",
        "Asia": "asia-southeast1-"
    }

    ISO_DATE_REGEX = (r'^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):'
                      r'([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?Z$')

    CHRONICLE_OUTPUT_PATHS = {
        'Asset': 'GoogleChronicleBackstory.Asset(val.{0} && val.{0} == obj.{0})',
        'Iocs': 'GoogleChronicleBackstory.Iocs(val.Artifact && val.Artifact == obj.Artifact)',
        'IocDetails': 'GoogleChronicleBackstory.IocDetails(val.IoCQueried && val.IoCQueried == obj.IoCQueried)',
        'Ip': 'GoogleChronicleBackstory.IP(val.IoCQueried && val.IoCQueried == obj.IoCQueried)',
        'Domain': 'GoogleChronicleBackstory.Domain(val.IoCQueried && val.IoCQueried == obj.IoCQueried)',
        'Alert': 'GoogleChronicleBackstory.Alert(val.AssetName && val.AssetName == obj.AssetName)',
        'UserAlert': 'GoogleChronicleBackstory.UserAlert(val.User && val.User == obj.User)',
        'Events': 'GoogleChronicleBackstory.Events',
        'Detections': 'GoogleChronicleBackstory.Detections(val.id == obj.id && val.ruleVersion == obj.ruleVersion)',
        'Rules': 'GoogleChronicleBackstory.Rules(val.ruleId == obj.ruleId)',
        'Token': 'GoogleChronicleBackstory.Token(val.name == obj.name)'
    }

    ARTIFACT_NAME_DICT = {
        'domain_name': 'Domain',
        'hash_sha256': 'SHA256',
        'hash_sha1': 'SHA1',
        'hash_md5': 'MD5',
        'destination_ip_address': 'IP'
    }

    ASSET_IDENTIFIER_NAME_DICT = {
        'host name': 'hostname',
        'ip address': 'asset_ip_address',
        'mac address': 'mac',
        'product id': 'product_id',
    }

    HOST_CTX_KEY_DICT = {
        'hostname': 'Hostname',
        'assetIpAddress': 'IP',
        'productId': 'ID',
        'MACAddress': 'MACAddress'
    }

    CONTEXT_KEY_DICT = {
        'hostname': 'HostName',
        'assetIpAddress': 'IpAddress',
        'productId': 'ProductId',
        'MACAddress': 'MACAddress'
    }

    STANDARD_CTX_KEY_MAP = {
        'ip': 'Address',
        'domain': 'Name',
        'file': 'Name'
    }

    DBOT_SCORE_MAPPING = {
        0: 'Unknown',
        1: 'Good',
        2: 'Suspicious',
        3: 'Malicious'
    }

    CONFIDENCE_LEVEL_PRIORITY = {
        'unknown_severity': 0,
        'informational': 1,
        'low': 2,
        'medium': 3,
        'high': 4
    }

    SEVERITY_MAP = {
        'unspecified': 0,
        'low': 1,
        'medium': 2,
        'high': 3
    }

    MESSAGES = {
        "INVALID_DAY_ARGUMENT": 'Invalid value provided. Allowed values are  "Last 1 day", "Last 7 days", '
                                '"Last 15 days" and "Last 30 days"',
        "INVALID_PAGE_SIZE": 'Page size should be in the range from 1 to 1000.',
        "NO_RECORDS": 'No Records Found'
    }
    FIRST_ACCESSED_TIME = 'First Accessed Time'
    LAST_ACCESSED_TIME = 'Last Accessed Time'
    IP_ADDRESS = 'IP Address'
    CONFIDENCE_SCORE = 'Confidence Score'
    VENDOR = 'Google Chronicle Backstory'
    LAST_SEEN_AGO = 'Last Seen Ago'
    LAST_SEEN = 'Last Seen'
    FIRST_SEEN_AGO = 'First Seen Ago'
    FIRST_SEEN = 'First Seen'
    ALERT_NAMES = 'Alert Names'

    ''' CLIENT CLASS '''


    class Client:
        """
        Client to use in integration to fetch data from Chronicle Backstory.

        requires service_account_credentials : a json formatted string act as a token access
        """

        def __init__(self, params: Dict[str, Any], proxy, disable_ssl):
            """
            Initialize HTTP Client.

            :param params: parameter returned from demisto.params()
            :param proxy: whether to use environment proxy
            :param disable_ssl: whether to disable ssl
            """
            encoded_service_account = str(params.get('service_account_credential'))
            service_account_credential = json.loads(encoded_service_account, strict=False)
            credentials = service_account.ServiceAccountCredentials.from_json_keyfile_dict(service_account_credential,
                                                                                           scopes=SCOPES)
            self.http_client = credentials.authorize(get_http_client(proxy, disable_ssl))
            self.region = params.get("region") if params.get("region") else "General"


    ''' HELPER FUNCTIONS '''


    def get_http_client(proxy, disable_ssl):
        """
        Construct HTTP Client.

        :param proxy: if proxy is enabled, http client with proxy is constructed
        :param disable_ssl: insecure
        :return: http_client object
        """
        proxy_info = {}
        if proxy:
            proxies = handle_proxy()
            if not proxies.get('https', True):
                raise DemistoException('https proxy value is empty. Check Demisto server configuration' + str(proxies))
            https_proxy = proxies['https']
            if not https_proxy.startswith('https') and not https_proxy.startswith('http'):
                https_proxy = 'https://' + https_proxy
            parsed_proxy = urllib.parse.urlparse(https_proxy)
            proxy_info = httplib2.ProxyInfo(
                proxy_type=httplib2.socks.PROXY_TYPE_HTTP,  # disable-secrets-detection
                proxy_host=parsed_proxy.hostname,
                proxy_port=parsed_proxy.port,
                proxy_user=parsed_proxy.username,
                proxy_pass=parsed_proxy.password)
        return httplib2.Http(proxy_info=proxy_info, disable_ssl_certificate_validation=disable_ssl)


    def validate_response(client, url, method='GET'):
        """
        Get response from Chronicle Search API and validate it.

        :param client: object of client class
        :type client: object of client class

        :param url: url
        :type url: str

        :param method: HTTP request method
        :type method: str

        :return: response
        """
        demisto.info('[CHRONICLE DETECTIONS]: Request URL: ' + url.format(REGIONS[client.region]))
        raw_response = client.http_client.request(url.format(REGIONS[client.region]), method)
        if not raw_response:
            raise ValueError('Technical Error while making API call to Chronicle. Empty response received')
        if raw_response[0].status == 500:
            raise ValueError('Internal server error occurred, Reattempt will be initiated.')
        if raw_response[0].status == 429:
            raise ValueError('API rate limit exceeded. Reattempt will be initiated.')
        if raw_response[0].status == 400 or raw_response[0].status == 404:
            raise ValueError(
                'Status code: {}\nError: {}'.format(raw_response[0].status, parse_error_message(raw_response[1])))
        if raw_response[0].status != 200:
            raise ValueError(
                'Status code: {}\nError: {}'.format(raw_response[0].status, parse_error_message(raw_response[1])))
        try:
            response = json.loads(raw_response[1])
            return response
        except json.decoder.JSONDecodeError:
            raise ValueError('Invalid response format while making API call to Chronicle. Response not in JSON format')


    def get_params_for_reputation_command():
        """
        Get Demisto parameters related to the reputation command.

        :return: Dict of parameters related to reputation command
        :rtype: dict
        """
        # fetching parameters for reputation command
        malicious_category_list = demisto.params().get('malicious_categories')
        suspicious_category_list = demisto.params().get('suspicious_categories')
        malicious_category_list = malicious_category_list if malicious_category_list is not None else ''
        suspicious_category_list = suspicious_category_list if suspicious_category_list is not None else ''

        # create list of malicious and suspicious categories based on entered comma separated values
        override_malicious_categories = [malicious_category.strip().lower() for malicious_category in
                                         malicious_category_list.split(',')]
        override_suspicious_categories = [suspicious_category.strip().lower() for suspicious_category in
                                          suspicious_category_list.split(',')]

        malicious_severity_list = demisto.params().get('override_severity_malicious')
        suspicious_severity_list = demisto.params().get('override_severity_suspicious')
        override_malicious_severity = malicious_severity_list if malicious_severity_list is not None else ''
        override_suspicious_severity = suspicious_severity_list if suspicious_severity_list is not None else ''

        override_malicious_confidence_score = demisto.params().get('override_confidence_score_malicious_threshold')
        override_suspicious_confidence_score = demisto.params().get('override_confidence_score_suspicious_threshold')

        malicious_confidence_score_threshold_str = demisto.params().get('override_confidence_level_malicious')
        suspicious_confidence_score_threshold_str = demisto.params().get(
            'override_confidence_level_suspicious')

        override_malicious_confidence_score_str = malicious_confidence_score_threshold_str \
            if malicious_confidence_score_threshold_str is not None else ''
        override_suspicious_confidence_score_str = suspicious_confidence_score_threshold_str \
            if suspicious_confidence_score_threshold_str is not None else ''

        return {
            'malicious_categories': override_malicious_categories,
            'suspicious_categories': override_suspicious_categories,
            'override_severity_malicious': override_malicious_severity,
            'override_severity_suspicious': override_suspicious_severity,
            'override_confidence_score_malicious_threshold': override_malicious_confidence_score,
            'override_confidence_score_suspicious_threshold': override_suspicious_confidence_score,
            'override_confidence_level_malicious': override_malicious_confidence_score_str,
            'override_confidence_level_suspicious': override_suspicious_confidence_score_str
        }


    def validate_configuration_parameters(param: Dict[str, Any]):
        """
        Check whether entered configuration parameters are valid or not.

        :type param: dict
        :param param: Dictionary of demisto configuration parameter

        :return: raise ValueError if any configuration parameter is not in valid format else returns None
        :rtype: None
        """
        # get configuration parameters
        service_account_json = param.get('service_account_credential', '')
        fetch_days = param.get('first_fetch', DEFAULT_FIRST_FETCH).lower()
        page_size = param.get('max_fetch', '10')
        time_window = param.get('time_window', '15')

        detection_by_ids = param.get('fetch_detection_by_ids') or ""
        detection_by_id = [r_v_id.strip() for r_v_id in detection_by_ids.split(',')]

        if param.get('backstory_alert_type', 'ioc domain matches').lower() == 'detection alerts' and not \
                param.get('fetch_all_detections', False) and not get_unique_value_from_list(detection_by_id):
            raise ValueError('Please enter one or more Rule ID(s) or Version ID(s) as value of "Detections to '
                             'fetch by Rule ID or Version ID" or check the checkbox "Fetch all rules '
                             'detections" to fetch detections.')

        try:
            # validate service_account_credential configuration parameter
            json.loads(service_account_json, strict=False)

            # validate max_fetch configuration parameter
            if not page_size.isdigit():
                raise ValueError('Incidents fetch limit must be a number')

            invalid_time_window_error_message = 'Time window(in minutes) should be in the numeric range from 1 to 60.'
            if not time_window:
                time_window = '15'
            if not time_window.isdigit():
                raise ValueError(invalid_time_window_error_message)
            time_window = int(time_window)
            if time_window > 60:
                raise ValueError(invalid_time_window_error_message)

            # validate first_fetch parameter
            range_split = fetch_days.split(' ')
            if len(range_split) != 2:
                raise ValueError('First fetch days must be "number time_unit", '
                                 'examples: (10 days, 6 months, 1 year, etc.)')

            if not range_split[0].isdigit():
                raise ValueError('First fetch days must be "number time_unit", '
                                 'examples: (10 days, 6 months, 1 year, etc.)')
            if not range_split[1] in ['day', 'days', 'month', 'months', 'year', 'years']:
                raise ValueError('First fetch days field\'s unit is invalid. Must be in day(s), month(s) or year(s)')

            # validate override_confidence_score_malicious_threshold and override_confidence_score_suspicious_threshold
            # parameters
            reputation_related_params = get_params_for_reputation_command()
            if reputation_related_params['override_confidence_score_malicious_threshold'] is not None \
                    and reputation_related_params['override_confidence_score_malicious_threshold'] != '' \
                    and not reputation_related_params['override_confidence_score_malicious_threshold'].isnumeric():
                raise ValueError('Confidence Score Threshold must be a number')
            if reputation_related_params['override_confidence_score_suspicious_threshold'] is not None \
                    and reputation_related_params['override_confidence_score_suspicious_threshold'] != '' \
                    and not reputation_related_params['override_confidence_score_suspicious_threshold'].isnumeric():
                raise ValueError('Confidence Score Threshold must be a number')

        except json.decoder.JSONDecodeError:
            raise ValueError('User\'s Service Account JSON has invalid format')


    def validate_start_end_date(start_date, end_date=None, reference_time=None):
        """
        Perform start and end date validation.

        Check whether the start_date and end_date provided are in valid ISO Format(e.g. 2019-10-17T00:00:00Z).
        Check whether start_date is not later than end_date.
        Check whether start_date and end_date are not a future date.

        :type start_date: string
        :param start_date: date

        :type end_date: string
        :param end_date: date

        :type reference_time: string
        :param reference_time: date

        :return: raise ValueError if validation fails, else return None
        :rtype: str, str, Optional[str]
        """
        if start_date.isdigit():
            raise ValueError("Invalid start time, supports ISO date format only. e.g. 2019-10-17T00:00:00Z")

        # checking date format
        start_date = dateparser.parse(start_date, settings={'STRICT_PARSING': True})
        if not start_date:
            raise ValueError('Invalid start time, supports ISO date format only. e.g. 2019-10-17T00:00:00Z')

        start_date = str(datetime.strftime(start_date, DATE_FORMAT))

        if end_date:
            if end_date.isdigit():
                raise ValueError("Invalid end time, supports ISO date format only. e.g. 2019-10-17T00:00:00Z")
            # checking date format
            end_date = dateparser.parse(end_date, settings={'STRICT_PARSING': True})
            if not end_date:
                raise ValueError('Invalid end time, supports ISO date format only. e.g. 2019-10-17T00:00:00Z')

            end_date = str(datetime.strftime(end_date, DATE_FORMAT))

        if reference_time:
            # checking date format
            reference_time = dateparser.parse(reference_time, settings={'STRICT_PARSING': True})
            if not reference_time:
                raise ValueError('Invalid reference time, supports ISO date format only. e.g. 2019-10-17T00:00:00Z')

            reference_time = str(datetime.strftime(reference_time, DATE_FORMAT))

        return start_date, end_date, reference_time


    def validate_page_size(page_size):
        """
        Validate that page size parameter is in numeric format or not.

        :type page_size: str
        :param page_size: this value will be check as numeric or not

        :return: True if page size is valid  else raise ValueError
        :rtype: bool
        """
        if not page_size or not str(page_size).isdigit() or int(page_size) == 0:
            raise ValueError('Page size must be a non-zero numeric value')
        return True


    def validate_preset_time_range(value):
        """
        Validate that preset_time_range parameter is in valid format or not and \
        strip the keyword 'Last' to extract the date range if validation is through.

        :type value: str
        :param value: this value will be check as valid or not

        :return: 1 Day, 7 Days, 15 Days, 30 Days or ValueError
        :rtype: string or Exception
        """
        value_split = value.split(' ')
        try:
            if value_split[0].lower() != 'last':
                raise ValueError(MESSAGES["INVALID_DAY_ARGUMENT"])

            day = int(value_split[1])

            if day not in [1, 7, 15, 30]:
                raise ValueError(MESSAGES["INVALID_DAY_ARGUMENT"])

            if value_split[2].lower() not in ['day', 'days']:
                raise ValueError(MESSAGES["INVALID_DAY_ARGUMENT"])
        except Exception:
            raise ValueError(MESSAGES["INVALID_DAY_ARGUMENT"])
        return value_split[1] + ' ' + value_split[2].lower()


    def get_chronicle_default_date_range(days=DEFAULT_FIRST_FETCH):
        """
        Get Chronicle Backstory default date range(last 3 days).

        :return: start_date, end_date (ISO date in UTC)
        :rtype: string
        """
        start_date, end_date = parse_date_range(days)
        return start_date.strftime(DATE_FORMAT), end_date.strftime(DATE_FORMAT)


    def get_artifact_type(value):
        """
        Derive the input value's artifact type based on the regex match. \
        The returned artifact_type is complaint with the Search API.

        :type value: string
        :param value: artifact value

        :return: domain_name, hash_sha256, hash_sha1, hash_md5, destination_ip_address or raise ValueError
        :rtype: string or Exception
        """
        # checking value if is valid ip
        if is_ip_valid(value, True):
            return 'destination_ip_address'
        else:
            hash_type = get_hash_type(value)  # checking value if is MD5, SHA-1 or SHA-256

            if hash_type != 'Unknown':
                return 'hash_' + hash_type

            return 'domain_name'  # if it's not IP or hash then it'll be considered as domain_name


    def prepare_hr_for_assets(asset_identifier_value, asset_identifier_key, data):
        """
        Prepare HR for assets.

        :param asset_identifier_value: Value of asset identifier
        :param asset_identifier_key: Key of asset identifier
        :param data: response from API endpoint
        :return: HR dictionary
        """
        tabular_data_dict = dict()
        tabular_data_dict['Host Name'] = asset_identifier_value if asset_identifier_key == 'hostname' else '-'
        tabular_data_dict['Host IP'] = asset_identifier_value if asset_identifier_key == 'assetIpAddress' else '-'
        tabular_data_dict['Host MAC'] = asset_identifier_value if asset_identifier_key == 'MACAddress' else '-'
        tabular_data_dict[FIRST_ACCESSED_TIME] = data.get('firstSeenArtifactInfo', {}).get('seenTime', '-')
        tabular_data_dict[LAST_ACCESSED_TIME] = data.get('lastSeenArtifactInfo', {}).get('seenTime', '-')
        return tabular_data_dict


    def parse_assets_response(response: Dict[str, Any], artifact_type, artifact_value):
        """
        Parse response of list assets within the specified time range.

        :type response: Dict
        :param response: it is response of assets

        :type artifact_type: String
        :param artifact_type: type of artifact (domain_name, hash_sha256, hash_sha1, hash_md5, destination_ip_address)

        :type artifact_value: String
        :param artifact_value: value of artifact

        :return: command output
        :rtype: Tuple
        """
        asset_list = response.get('assets', [])
        context_data = defaultdict(list)  # type: Dict[str, Any]
        tabular_data_list = list()
        host_context = list()

        for data in asset_list:
            # Extract the asset identifier key from response.
            # It could be one of Hostname, IpAddress, Mac
            asset_dict = data.get('asset', {})
            if not asset_dict:
                demisto.debug('Empty asset details found in response. Skipping this record.')
                continue

            asset_identifier_key = list(asset_dict.keys())[0]
            asset_identifier_value = list(asset_dict.values())[0]

            # The asset identifier keys for MAC and product ID are not definitive.
            # Using string match, to ascertain the asset identifier in such case.
            if asset_identifier_key not in CONTEXT_KEY_DICT:
                if "mac" in asset_identifier_key.lower():
                    asset_identifier_key = 'MACAddress'
                elif "product" in asset_identifier_key.lower():
                    asset_identifier_key = 'productId'
                else:
                    demisto.debug('Unknown asset identifier found - {}. Skipping this asset'.format(asset_identifier_key))
                    continue
            ctx_primary_key = CONTEXT_KEY_DICT[asset_identifier_key]

            # Preparing GCB custom context
            gcb_context_data = dict()
            gcb_context_data[ctx_primary_key] = asset_identifier_value
            gcb_context_data['FirstAccessedTime'] = data.get('firstSeenArtifactInfo', {}).get('seenTime', '')
            gcb_context_data['LastAccessedTime'] = data.get('lastSeenArtifactInfo', {}).get('seenTime', '')
            gcb_context_data['Accessed' + ARTIFACT_NAME_DICT[artifact_type]] = artifact_value
            context_data[CHRONICLE_OUTPUT_PATHS['Asset'].format(ctx_primary_key)].append(gcb_context_data)

            # Response for HR
            tabular_data_dict = prepare_hr_for_assets(asset_identifier_value, asset_identifier_key, data)
            tabular_data_list.append(tabular_data_dict)

            # Populating Host context for list of assets
            host_context.append({HOST_CTX_KEY_DICT[asset_identifier_key]: asset_identifier_value})
        return context_data, tabular_data_list, host_context


    def get_default_command_args_value(args: Dict[str, Any], date_range=None):
        """
        Validate and return command arguments default values as per Chronicle Backstory.

        :type args: dict
        :param args: contain all arguments for command

        :type date_range: string
        :param date_range: The date range to be parsed

        :return : start_time, end_time, page_size
        :rtype : datetime, datetime, int̥
        """
        preset_time_range = args.get('preset_time_range', None)
        reference_time = None
        if preset_time_range:
            preset_time_range = validate_preset_time_range(preset_time_range)
            start_time, end_time = get_chronicle_default_date_range(preset_time_range)
        else:
            if date_range is None:
                date_range = DEFAULT_FIRST_FETCH
            start_time, end_time = get_chronicle_default_date_range(days=date_range)
            start_time = args.get('start_time', start_time)
            end_time = args.get('end_time', end_time)
        page_size = args.get('page_size', 10000)
        validate_page_size(page_size)
        if args.get('reference_time', ''):
            start_time, end_time, reference_time = validate_start_end_date(start_time, end_time,
                                                                           args.get('reference_time', ''))
        else:
            start_time, end_time, _ = validate_start_end_date(start_time, end_time)

        return start_time, end_time, page_size, reference_time


    def parse_error_message(error):
        """
        Extract error message from error object.

        :type error: bytearray
        :param error: Error byte response to be parsed

        :return: error message
        :rtype: str
        """
        try:
            json_error = json.loads(error)
        except json.decoder.JSONDecodeError:
            demisto.debug(
                'Invalid response received from Chronicle Search API. Response not in JSON format. Response - {}'.format(
                    error))
            raise ValueError('Invalid response received from Chronicle Search API. Response not in JSON format.')

        if json_error.get('error', {}).get('code') == 403:
            return 'Permission denied'
        return json_error.get('error', {}).get('message', '')


    def transform_to_informal_time(total_time, singular_expected_string, plural_expected_string):
        """
        Convert to informal time from date to current time.

        :type total_time: float
        :param total_time: string of datetime object

        :type singular_expected_string: string
        :param singular_expected_string: expected string if total_time is 1

        :type plural_expected_string: string
        :param plural_expected_string: expected string if total_time is more than 1

        :return: informal time from date to current time
        :rtype: str
        """
        return singular_expected_string if total_time == 1 else str(total_time) + plural_expected_string


    def get_informal_time(date):
        """
        Convert to informal time from date to current time.

        :type date: string
        :param date: string of datetime object

        :return: informal time from date to current time
        :rtype: str
        """
        current_time = datetime.utcnow()
        previous_time = parse_date_string(date)

        total_time = (current_time - previous_time).total_seconds()

        if 0 < total_time < 60:
            return transform_to_informal_time(total_time, 'a second ago', ' seconds ago')
        total_time = round(total_time / 60)
        if 0 < total_time < 60:
            return transform_to_informal_time(total_time, 'a minute ago', ' minutes ago')
        total_time = round(total_time / 60)
        if 0 < total_time < 24:
            return transform_to_informal_time(total_time, 'an hour ago', ' hours ago')
        total_time = round(total_time / 24)
        if 0 < total_time < 31:
            return transform_to_informal_time(total_time, 'a day ago', ' days ago')
        total_time = round(total_time / 31)
        if 0 < total_time < 12:
            return transform_to_informal_time(total_time, 'a month ago', ' months ago')
        total_time = round((total_time * 31) / 365)
        return transform_to_informal_time(total_time, 'a year ago', ' years ago')


    def parse_list_ioc_response(ioc_matches):
        """
        Parse response of list iocs within the specified time range. \
        Constructs the Domain Standard context, Human readable and EC.

        :type ioc_matches: List
        :param ioc_matches: it is list of iocs

        :return: gives dict that contain hr_ioc_matches dict for human readable,domain_std_context and contexts dict for
            context data
        :rtype: Dict
        """
        domain_std_context = []
        hr_ioc_matches = []
        context = []
        for ioc_match in ioc_matches:
            sources = []
            # get details from response
            domain = ioc_match.get('artifact', {}).get('domainName', '')
            ingest_time = ioc_match.get('iocIngestTime', '')
            first_seen_time = ioc_match.get('firstSeenTime', '')
            last_seen_time = ioc_match.get('lastSeenTime', '')
            for ioc_rep_source in ioc_match.get('sources', []):
                source = ioc_rep_source.get('source', '')
                confidence = ioc_rep_source.get('confidenceScore', {}).get('normalizedConfidenceScore', 'unknown')
                severity = ioc_rep_source.get('rawSeverity', '')
                category = ioc_rep_source.get('category', '')

                # prepare normalized dict for human readable
                hr_ioc_matches.append({
                    'Domain': '[{}]({})'.format(domain, ioc_match.get('uri', [''])[0]),
                    'Category': category,
                    'Source': source,
                    'Confidence': confidence,
                    'Severity': severity,
                    'IOC ingest time': get_informal_time(ingest_time),
                    'First seen': get_informal_time(first_seen_time),
                    'Last seen': get_informal_time(last_seen_time),
                })

                sources.append({
                    'Category': category,
                    'IntRawConfidenceScore': ioc_rep_source.get('confidenceScore', {}).get('intRawConfidenceScore', 0),
                    'NormalizedConfidenceScore': confidence,
                    'RawSeverity': severity,
                    'Source': source
                })

            # prepare context standard data for Domain
            domain_std_context.append({'Name': domain})

            # prepare context data for IoCs
            context.append({
                'Artifact': domain,
                'IocIngestTime': ingest_time,
                'FirstAccessedTime': first_seen_time,
                'LastAccessedTime': last_seen_time,
                'Sources': sources
            })

        return {'hr_ioc_matches': hr_ioc_matches, 'domain_std_context': domain_std_context, 'context': context}


    def is_category_malicious(category, reputation_params):
        """Determine if category is malicious in reputation_params."""
        return category and category.lower() in reputation_params['malicious_categories']


    def is_severity_malicious(severity, reputation_params):
        """Determine if severity is malicious in reputation_params."""
        return severity and severity.lower() in reputation_params['override_severity_malicious']


    def is_confidence_score_malicious(confidence_score, params):
        """Determine if confidence score is malicious in reputation_params."""
        return is_int_type_malicious_score(confidence_score, params) or is_string_type_malicious_score(confidence_score,
                                                                                                       params)


    def is_string_type_malicious_score(confidence_score, params):
        """Determine if string type confidence score is malicious in reputation_params."""
        return not isinstance(confidence_score, int) and CONFIDENCE_LEVEL_PRIORITY.get(
            params['override_confidence_level_malicious'], 10) <= CONFIDENCE_LEVEL_PRIORITY.get(confidence_score.lower(),
                                                                                                -1)


    def is_int_type_malicious_score(confidence_score, params):
        """Determine if integer type confidence score is malicious in reputation_params."""
        return params['override_confidence_score_malicious_threshold'] and isinstance(confidence_score, int) and int(
            params['override_confidence_score_malicious_threshold']) <= confidence_score


    def is_category_suspicious(category, reputation_params):
        """Determine if category is suspicious in reputation_params."""
        return category and category.lower() in reputation_params['suspicious_categories']


    def is_severity_suspicious(severity, reputation_params):
        """Determine if severity is suspicious in reputation_params."""
        return severity and severity.lower() in reputation_params['override_severity_suspicious']


    def is_confidence_score_suspicious(confidence_score, params):
        """Determine if confidence score is suspicious in reputation_params."""
        return is_int_type_suspicious_score(confidence_score, params) or is_string_type_suspicious_score(confidence_score,
                                                                                                         params)


    def is_string_type_suspicious_score(confidence_score, params):
        """Determine if string type confidence score is suspicious in reputation_params."""
        return not isinstance(confidence_score, int) and CONFIDENCE_LEVEL_PRIORITY.get(
            params['override_confidence_level_suspicious'], 10) <= CONFIDENCE_LEVEL_PRIORITY.get(confidence_score.lower(),
                                                                                                 -1)


    def is_int_type_suspicious_score(confidence_score, params):
        """Determine if integer type confidence score is suspicious in reputation_params."""
        return params['override_confidence_score_suspicious_threshold'] and isinstance(confidence_score, int) and int(
            params['override_confidence_score_suspicious_threshold']) <= confidence_score


    def evaluate_dbot_score(category, severity, confidence_score):
        """
        Calculate the dbot score according to category, severity and confidence score configured.

        :type category: str
        :param category: category received in the response of list-ioc-details endpoint

        :type severity: str
        :param severity: severity received in the response of list-ioc-details endpoint

        :type confidence_score: int or str
        :param confidence_score: confidence_score received in the response of list-ioc-details endpoint

        :return: the function returns dbot score based on the entered parameters.
        :rtype: int
        """
        params = get_params_for_reputation_command()

        dbot_score = 0

        # Check if the category belongs to configured Malicious category/severity/threshold score.
        if is_category_malicious(category, params) or is_severity_malicious(severity, params) \
                or is_confidence_score_malicious(confidence_score, params):
            dbot_score = 3

        # Check if the category belongs to configured Suspicious category/severity/threshold score.
        elif is_category_suspicious(category, params) or is_severity_suspicious(severity, params) \
                or is_confidence_score_suspicious(confidence_score, params):
            dbot_score = 2

        return dbot_score


    def prepare_hr_for_ioc_details(addresses, hr_table_row):
        """
        Prepare HR for IOC Details.

        :param hr_table_row: dictionary containing HR details
        :param addresses: List of addresses
        :return: updated HR dictionary
        """
        address_data = []
        for address in addresses:
            if address.get('domain'):
                address_data.append({
                    'Domain': address['domain'],
                    'Port': address.get('port', '')
                })
                hr_table_row['Domain'] = address['domain']
            if address.get('ipAddress'):
                address_data.append({
                    'IpAddress': address['ipAddress'],
                    'Port': address.get('port', '')
                })
                hr_table_row[IP_ADDRESS] = address['ipAddress']
        return address_data, hr_table_row


    def get_context_for_ioc_details(sources, artifact_indicator, artifact_type, is_reputation_command=True):
        """
        Generate context data for reputation command and ioc details command.

        :type sources: list
        :param sources: list of the sources getting response from listiocdetails endpoint

        :type artifact_indicator: str
        :param artifact_indicator: inputted artifact indicator

        :type artifact_type: str
        :param artifact_type: the type of artifact

        :type is_reputation_command: bool
        :param is_reputation_command: true if the command is execute for reputation command, default is true

        :return: returns dict of context data, human readable, and reputation
        :rtype: dict
        """
        dbot_context = {}  # type: Dict[str, Any]
        standard_context = {}  # type: Dict[str, Any]
        source_data_list = []
        hr_table_data = []

        # To hold the max dbot score across sources.
        dbot_score_max = 0
        for source in sources:
            category = source.get('category')
            severity = source.get('rawSeverity')

            # if confidence score is not in numeric value, then it set confidence score will be set to 0
            confidence_score = source.get('confidenceScore', {}).get('strRawConfidenceScore')
            if confidence_score and confidence_score.isnumeric():
                confidence_score = int(confidence_score)

            if is_reputation_command:
                # Highest confidence score across the sources is considered for dbot_score
                source_dbot_score = evaluate_dbot_score(category, severity, confidence_score)
                dbot_score_max = source_dbot_score if source_dbot_score > dbot_score_max else dbot_score_max

            # prepare table content for Human Readable Data
            hr_table_row = {
                'Domain': '-',
                IP_ADDRESS: '-',
                'Category': category,
                CONFIDENCE_SCORE: confidence_score,
                'Severity': severity,
                FIRST_ACCESSED_TIME: source.get('firstActiveTime'),
                LAST_ACCESSED_TIME: source.get('lastActiveTime')
            }

            # Parsing the Addresses data to fetch IP and Domain data for context
            address_data, hr_table_row = prepare_hr_for_ioc_details(source.get('addresses', []), hr_table_row)
            hr_table_data.append(hr_table_row)

            source_data_list.append({
                'Address': address_data,
                'Category': source.get('category', ''),
                'ConfidenceScore': confidence_score,
                'FirstAccessedTime': source.get('firstActiveTime', ''),
                'LastAccessedTime': source.get('lastActiveTime', ''),
                'Severity': source.get('rawSeverity', '')
            })

        # Setting standard context
        standard_context[STANDARD_CTX_KEY_MAP[artifact_type]] = artifact_indicator
        if is_reputation_command:
            # set dbot context
            dbot_context = {
                'Indicator': artifact_indicator,
                'Type': artifact_type,
                'Vendor': VENDOR,
                'Score': dbot_score_max
            }
            if dbot_score_max == 3:
                standard_context['Malicious'] = {
                    'Vendor': VENDOR,
                    'Description': 'Found in malicious data set'
                }

        context = {
            'IoCQueried': artifact_indicator,
            'Sources': source_data_list
        }

        return {
            'dbot_context': dbot_context,
            'standard_context': standard_context,
            'context': context,
            'hr_table_data': hr_table_data,
            'reputation': DBOT_SCORE_MAPPING[dbot_score_max]
        }


    def parse_alert_info(alert_infos, filter_severity):
        """
        Parse alert info of alerts.

        :param alert_infos:
        :param filter_severity: will include alert_info if matches
        :return:
        """
        infos = []
        for alert_info in alert_infos:

            # filtering alert if supplied by the user in configuration settings. used for fetch-incidents only
            if filter_severity and filter_severity.lower() != alert_info.get('severity',
                                                                             '').lower() and filter_severity != 'ALL':
                continue

            info = {
                'Name': alert_info['name'],
                'SourceProduct': alert_info['sourceProduct'],
                'Severity': alert_info['severity'],
                'Timestamp': alert_info['timestamp'],
                'Uri': alert_info.get('uri', [''])[0]
            }
            infos.append(info)
        return infos, len(infos)


    def get_ioc_domain_matches(client_obj, start_time, max_fetch):
        """
        Call list IOC API with :start_time, :end_time and :max_fetch.

        filter_severity to filter out an alert after getting a response from API. Passing ALL will not filter any data

        :param client_obj perform API request
        :param start_time
        :param max_fetch

        return events - list of dict representing events
        """
        request_url = '{}/ioc/listiocs?start_time={}&page_size={}'.format(BACKSTORY_API_V1_URL, start_time, max_fetch)

        response_body = validate_response(client_obj, request_url)
        ioc_matches = response_body.get('response', {}).get('matches', [])
        parsed_ioc = parse_list_ioc_response(ioc_matches)
        return parsed_ioc['context']


    def get_gcb_alerts(client_obj, start_time, end_time, max_fetch, filter_severity):
        """
        Call list alert API with :start_time, :end_time and :max_fetch.

        filter_severity to filter out an alert after getting a response from API. Passing ALL will not filter any data

        :param client_obj perform API request
        :param start_time
        :param end_time
        :param max_fetch
        :param filter_severity

        return events - list of dict representing events
        """
        request_url = '{}/alert/listalerts?start_time={}&end_time={}&page_size={}'.format(BACKSTORY_API_V1_URL, start_time,
                                                                                          end_time, max_fetch)
        demisto.debug("[CHRONICLE] Request URL for fetching alerts: {}".format(request_url))

        json_response = validate_response(client_obj, request_url)

        alerts = []
        for alert in json_response.get('alerts', []):
            # parsing each alert infos
            alert_info, alert_count = parse_alert_info(alert['alertInfos'], filter_severity)

            # skipping alerts with no alert_infos
            if alert_count == 0 and not alert_info:
                continue

            asset_alert = {
                'AssetName': list(alert['asset'].values())[0],
                'AlertCounts': alert_count,
                'AlertInfo': alert_info
            }
            alerts.append(asset_alert)
        return alerts


    def reputation_operation_command(client_obj, indicator, reputation_function):
        """
        Call appropriate reputation command.

        Common method for reputation commands to accept argument as a comma-separated values and converted into list \
        and call specific function for all values.

        :param client_obj: object of client class
        :param indicator: comma-separated values or single value
        :param reputation_function: reputation command function. i.e ip_command and domain_command.

        :return: output of all value according to specified function.
        """
        artifacts = argToList(indicator, ',')
        for artifact in artifacts:
            return_outputs(*reputation_function(client_obj, artifact))


    def group_infos_by_alert_asset_name(asset_alerts):
        """
        Group alerts by assets.

        This method converts assets with multiple alerts into assets per asset_alert and \
        returns both human readable and context.
        For an asset, group the asset_alert infos based on asset_alert name.
        Returns human readable and context data.

        :param asset_alerts: normalized asset alerts returned by Backstory.
        :return: both human readable and context format having asset per alerts object
        """
        unique_asset_alerts_hr = {}  # type: Dict[str,Any]
        unique_asset_alert_ctx = {}  # type: Dict[str,Any]
        for asset_alert in asset_alerts:
            for info in asset_alert['AlertInfo']:
                asset_alert_key = asset_alert['AssetName'] + '-' + info['Name']

                asset_alert_hr = unique_asset_alerts_hr.get(asset_alert_key, {})
                asset_alert_ctx = unique_asset_alert_ctx.get(asset_alert_key, {})

                if asset_alert_hr:
                    # Re calculate First and Last seen time
                    if info['Timestamp'] >= asset_alert_hr[LAST_SEEN_AGO]:
                        asset_alert_hr[LAST_SEEN_AGO] = info['Timestamp']
                        asset_alert_hr[LAST_SEEN] = get_informal_time(info['Timestamp'])
                        asset_alert_ctx['LastSeen'] = info['Timestamp']
                    elif info['Timestamp'] <= asset_alert_hr[FIRST_SEEN_AGO]:
                        asset_alert_hr[FIRST_SEEN_AGO] = info['Timestamp']
                        asset_alert_hr[FIRST_SEEN] = get_informal_time(info['Timestamp'])
                        asset_alert_ctx['FirstSeen'] = info['Timestamp']
                else:
                    asset_alert_hr[FIRST_SEEN_AGO] = info['Timestamp']
                    asset_alert_hr[FIRST_SEEN] = get_informal_time(info['Timestamp'])
                    asset_alert_hr[LAST_SEEN_AGO] = info['Timestamp']
                    asset_alert_hr[LAST_SEEN] = get_informal_time(info['Timestamp'])

                    asset_alert_ctx['FirstSeen'] = info['Timestamp']
                    asset_alert_ctx['LastSeen'] = info['Timestamp']

                asset_alert_ctx.setdefault('Occurrences', []).append(info['Timestamp'])
                asset_alert_ctx['Alerts'] = asset_alert_hr['Alerts'] = asset_alert_ctx.get('Alerts', 0) + 1
                asset_alert_ctx['Asset'] = asset_alert['AssetName']
                asset_alert_ctx['AlertName'] = asset_alert_hr[ALERT_NAMES] = info['Name']
                asset_alert_ctx['Severities'] = asset_alert_hr['Severities'] = info['Severity']
                asset_alert_ctx['Sources'] = asset_alert_hr['Sources'] = info['SourceProduct']

                asset_alert_hr['Asset'] = '[{}]({})'.format(asset_alert['AssetName'], info.get('Uri'))

                unique_asset_alert_ctx[asset_alert_key] = asset_alert_ctx
                unique_asset_alerts_hr[asset_alert_key] = asset_alert_hr

        return unique_asset_alerts_hr, unique_asset_alert_ctx


    def convert_alerts_into_hr(events):
        """
        Convert alerts into human readable by parsing alerts.

        :param events: events from the response
        :return: human readable for alerts
        """
        data = group_infos_by_alert_asset_name(events)[0].values()
        return tableToMarkdown('Security Alert(s)', list(data),
                               ['Alerts', 'Asset', ALERT_NAMES, FIRST_SEEN, LAST_SEEN, 'Severities',
                                'Sources'],
                               removeNull=True)


    def get_asset_identifier_details(asset_identifier):
        """
        Return asset identifier detail such as hostname, ip, mac.

        :param asset_identifier: A dictionary that have asset information
        :type asset_identifier: dict

        :return: asset identifier name
        :rtype: str
        """
        if asset_identifier.get('hostname', ''):
            return asset_identifier.get('hostname', '')
        if asset_identifier.get('ip', []):
            return '\n'.join(asset_identifier.get('ip', []))
        if asset_identifier.get('mac', []):
            return '\n'.join(asset_identifier.get('mac', []))
        return None


    def get_more_information(event):
        """
        Get more information for event from response.

        :param event: event details
        :type event: dict

        :return: queried domain, process command line, file use by process
        :rtype: str, str, str
        """
        queried_domain = ''
        process_command_line = ''
        file_use_by_process = ''

        if event.get('metadata', {}).get('eventType', '') == 'NETWORK_DNS':
            questions = event.get('network', {}).get('dns', {}).get('questions', [])
            for question in questions:
                queried_domain += '{}\n'.format(question.get('name', ''))

        if event.get('target', {}).get('process', {}).get('commandLine', ''):
            process_command_line += event.get('target', {}).get('process', {}).get('commandLine', '')

        if event.get('target', {}).get('process', {}).get('file', {}).get('fullPath', ''):
            file_use_by_process += event.get('target', {}).get('process', {}).get('file', {}).get('fullPath', '')

        return queried_domain, process_command_line, file_use_by_process


    def get_context_for_events(events):
        """
        Convert response into Context data.

        :param events: List of events
        :type events: list

        :return: list of context data
        """
        events_ec = []
        for event in events:
            event_dict = {}
            if 'metadata' in event.keys():
                event_dict.update(event.pop('metadata'))
            event_dict.update(event)
            events_ec.append(event_dict)

        return events_ec


    def get_list_events_hr(events):
        """
        Convert events response into human readable.

        :param events: list of events
        :type events: list

        :return: returns human readable string for gcb-list-events command
        :rtype: str
        """
        hr_dict = []
        for event in events:
            # Get queried domain, process command line, file use by process information
            more_info = get_more_information(event)

            hr_dict.append({
                'Event Timestamp': event.get('metadata', {}).get('eventTimestamp', ''),
                'Event Type': event.get('metadata', {}).get('eventType', ''),
                'Principal Asset Identifier': get_asset_identifier_details(event.get('principal', {})),
                'Target Asset Identifier': get_asset_identifier_details(event.get('target', {})),
                'Queried Domain': more_info[0],
                'Process Command Line': more_info[1],
                'File In Use By Process': more_info[2]
            })

        hr = tableToMarkdown('Event(s) Details', hr_dict,
                             ['Event Timestamp', 'Event Type', 'Principal Asset Identifier', 'Target Asset Identifier',
                              'Queried Domain', 'File In Use By Process', 'Process Command Line'], removeNull=True)
        return hr


    def validate_and_parse_detection_start_end_time(args: Dict[str, Any]) -> Tuple[str, str]:
        """
        Validate and return detection_start_time and detection_end_time as per Chronicle Backstory or \
        raise a ValueError if the given inputs are invalid.

        :type args: dict
        :param args: contains all arguments for command

        :return : detection_start_time, detection_end_time: Detection start and end time in the format API accepts
        :rtype : Tuple[str, str]
        """
        detection_start_time = args.get('start_time') if args.get('start_time') else args.get('detection_start_time')
        detection_end_time = args.get('end_time') if args.get('end_time') else args.get('detection_end_time')

        list_basis = args.get('list_basis', '')
        if list_basis and not detection_start_time and not detection_end_time:
            raise ValueError("To sort detections by \"list_basis\", either \"start_time\" or \"end_time\" argument is "
                             "required.")

        invalid_time_error_message = 'Invalid {} time. Some supported formats are ISO date format and relative time.' \
                                     ' e.g. 2019-10-17T00:00:00Z, 3 days'
        if detection_start_time:
            if detection_start_time.isdigit():
                raise ValueError(invalid_time_error_message.format('start'))
            detection_start_time = dateparser.parse(detection_start_time, settings={'STRICT_PARSING': True})

            if not detection_start_time:
                raise ValueError(invalid_time_error_message.format('start'))

            detection_start_time = str(datetime.strftime(detection_start_time, DATE_FORMAT))

        if detection_end_time:
            if detection_end_time.isdigit():
                raise ValueError(invalid_time_error_message.format('end'))

            detection_end_time = dateparser.parse(detection_end_time, settings={'STRICT_PARSING': True})
            if not detection_end_time:
                raise ValueError(invalid_time_error_message.format('end'))

            detection_end_time = str(datetime.strftime(detection_end_time, DATE_FORMAT))

        return detection_start_time, detection_end_time


    def validate_and_parse_list_detections_args(args: Dict[str, Any]) -> Dict[str, Any]:
        """
        Return and validate page_size, detection_start_time and detection_end_time.

        :type args: Dict[str, Any]
        :param args: contains all arguments for list-detections command

        :return: Dictionary containing values of page_size, detection_start_time and detection_end_time
         or raise ValueError if the arguments are invalid
        :rtype: Dict[str, Any]
        """
        page_size = args.get('page_size', 100)
        validate_page_size(page_size)
        if int(page_size) > 1000:
            raise ValueError(MESSAGES["INVALID_PAGE_SIZE"])

        rule_id = args.get('id', '')
        detection_for_all_versions = argToBoolean(args.get('detection_for_all_versions', False))
        if detection_for_all_versions and not rule_id:
            raise ValueError('If "detection_for_all_versions" is true, rule id is required.')

        detection_start_time, detection_end_time = validate_and_parse_detection_start_end_time(args)

        valid_args = {'page_size': page_size, 'detection_start_time': detection_start_time,
                      'detection_end_time': detection_end_time, 'detection_for_all_versions': detection_for_all_versions}

        return valid_args


    def get_hr_for_event_in_detection(event: Dict[str, Any]) -> str:
        """
        Return a string containing event information for an event.

        :param event: event for which hr is to be prepared
        :return: event information in human readable format
        """
        event_info = []

        # Get queried domain, process command line, file use by process information
        more_info = get_more_information(event)

        event_timestamp = event.get('metadata', {}).get('eventTimestamp', '')
        event_type = event.get('metadata', {}).get('eventType', '')
        principal_asset_identifier = get_asset_identifier_details(event.get('principal', {}))
        target_asset_identifier = get_asset_identifier_details(event.get('target', {}))
        queried_domain = more_info[0][:-1]
        process_command_line = more_info[1]
        file_in_use_by_process = more_info[2]
        if event_timestamp:
            event_info.append('**Event Timestamp:** {}'.format(event_timestamp))
        if event_type:
            event_info.append('**Event Type:** {}'.format(event_type))
        if principal_asset_identifier:
            event_info.append('**Principal Asset Identifier:** {}'.format(principal_asset_identifier))
        if target_asset_identifier:
            event_info.append('**Target Asset Identifier:** {}'.format(target_asset_identifier))
        if queried_domain:
            event_info.append('**Queried Domain:** {}'.format(queried_domain))
        if process_command_line:
            event_info.append('**Process Command Line:** {}'.format(process_command_line))
        if file_in_use_by_process:
            event_info.append('**File In Use By Process:** {}'.format(file_in_use_by_process))
        return '\n'.join(event_info)


    def get_events_hr_for_detection(events: List[Dict[str, Any]]) -> str:
        """
        Convert events response related to the specified detection into human readable.

        :param events: list of events
        :type events: list

        :return: returns human readable string for the events related to the specified detection
        :rtype: str
        """
        events_hr = []
        for event in events:
            events_hr.append(get_hr_for_event_in_detection(event))

        return '\n\n'.join(events_hr)


    def get_event_list_for_detections_hr(result_events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Convert events response related to the specified detection into list of events for command's human readable.

        :param result_events: List having dictionary containing list of events
        :type result_events: List[Dict[str, Any]]

        :return: returns list of the events related to the specified detection
        :rtype: List[Dict[str,Any]]
        """
        events = []
        if result_events:
            for element in result_events:
                for event in element.get('references', []):
                    events.append(event.get('event', {}))
        return events


    def get_event_list_for_detections_context(result_events: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Convert events response related to the specified detection into list of events for command's context.

        :param result_events: Dictionary containing list of events
        :type result_events: Dict[str, Any]

        :return: returns list of the events related to the specified detection
        :rtype: List[Dict[str,Any]]
        """
        events = []
        if result_events:
            for event in result_events.get('references', []):
                events.append(event.get('event', {}))
        return events


    def get_list_detections_hr(detections: List[Dict[str, Any]], rule_or_version_id: str) -> str:
        """
        Convert detections response into human readable.

        :param detections: list of detections
        :type detections: list

        :type rule_or_version_id: str
        :param rule_or_version_id: rule_id or version_id to fetch the detections for.

        :return: returns human readable string for gcb-list-detections command
        :rtype: str
        """
        hr_dict = []
        for detection in detections:
            events = get_event_list_for_detections_hr(detection.get('collectionElements', []))
            detection_details = detection.get('detection', {})
            hr_dict.append({
                'Detection ID': "[{}]({})".format(detection.get('id', ''),
                                                  detection_details[0].get('urlBackToProduct', '')),
                'Detection Type': detection.get('type', ''),
                'Detection Time': detection.get('detectionTime', ''),
                'Events': get_events_hr_for_detection(events),
                'Alert State': detection_details[0].get('alertState', '')
            })
        rule_uri = detections[0].get('detection', {})[0].get('urlBackToProduct', '')
        if rule_uri:
            rule_uri = rule_uri.split('&', maxsplit=2)
            rule_uri = '{}&{}'.format(rule_uri[0], rule_uri[1])
        if rule_or_version_id:
            hr_title = 'Detection(s) Details For Rule: [{}]({})'. \
                format(detections[0].get('detection', {})[0].get('ruleName', ''), rule_uri)
        else:
            hr_title = 'Detection(s)'
        hr = tableToMarkdown(hr_title, hr_dict, ['Detection ID', 'Detection Type', 'Detection Time', 'Events',
                                                 'Alert State'], removeNull=True)
        return hr


    def get_events_context_for_detections(result_events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Convert events in response into Context data for events associated with a detection.

        :param result_events: List of Dictionary containing list of events
        :type result_events: List[Dict[str, Any]]

        :return: list of events to populate in the context
        :rtype: List[Dict[str, Any]]
        """
        events_ec = []
        for collection_element in result_events:
            reference = []
            events = get_event_list_for_detections_context(collection_element)
            for event in events:
                event_dict = {}
                if 'metadata' in event.keys():
                    event_dict.update(event.pop('metadata'))
                principal_asset_identifier = get_asset_identifier_details(event.get('principal', {}))
                target_asset_identifier = get_asset_identifier_details(event.get('target', {}))
                if principal_asset_identifier:
                    event_dict.update({'principalAssetIdentifier': principal_asset_identifier})
                if target_asset_identifier:
                    event_dict.update({'targetAssetIdentifier': target_asset_identifier})
                event_dict.update(event)
                reference.append(event_dict)
            collection_element_dict = {'references': reference, 'label': collection_element.get('label', '')}
            events_ec.append(collection_element_dict)

        return events_ec


    def get_context_for_detections(detection_resp: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], Dict[str, str]]:
        """
        Convert detections response into Context data.

        :param detection_resp: Response fetched from the API call for detections
        :type detection_resp: Dict[str, Any]

        :return: list of detections and token to populate context data
        :rtype: Tuple[List[Dict[str, Any]], Dict[str, str]]
        """
        detections_ec = []
        token_ec = {}
        next_page_token = detection_resp.get('nextPageToken')
        if next_page_token:
            token_ec = {'name': 'gcb-list-detections', 'nextPageToken': next_page_token}
        detections = detection_resp.get('detections', [])
        for detection in detections:
            detection_dict = detection
            result_events = detection.get('collectionElements', [])
            if result_events:
                detection_dict['collectionElements'] = get_events_context_for_detections(result_events)

            detection_details = detection.get('detection', {})
            if detection_details:
                detection_dict.update(detection_details[0])
                detection_dict.pop('detection')

            time_window_details = detection.get('timeWindow', {})
            if time_window_details:
                detection_dict.update({'timeWindowStartTime': time_window_details.get('startTime'),
                                       'timeWindowEndTime': time_window_details.get('endTime')})
                detection_dict.pop('timeWindow')
            detections_ec.append(detection_dict)

        return detections_ec, token_ec


    def get_detections(client_obj, rule_or_version_id: str, page_size: str, detection_start_time: str,
                       detection_end_time: str, page_token: str, alert_state: str, detection_for_all_versions: bool = False,
                       list_basis: str = None) \
            -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Return context data and raw response for gcb-list-detections command.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api
        :type rule_or_version_id: str
        :param rule_or_version_id: rule_id or version_id to fetch the detections for.
        :type page_size: str
        :param page_size: Number of detections to fetch at a time.
        :type detection_start_time: str
        :param detection_start_time: The time to start listing detections from.
        :type detection_end_time: str
        :param detection_end_time: The time to start listing detections to.
        :type page_token: str
        :param page_token: The token for the page from which the detections should be fetched.
        :type alert_state: str
        :param alert_state: Alert state for the detections to fetch.
        :type detection_for_all_versions: bool
        :param detection_for_all_versions: Whether to retrieve detections for all versions of a rule with a given rule
        identifier.
        :type list_basis: str
        :param list_basis: To sort the detections.

        :rtype: Tuple[Dict[str, Any], Dict[str, Any]]
        :return: ec, json_data: Context data and raw response for the fetched detections
        """
        # Make a request URL
        if not rule_or_version_id:
            rule_or_version_id = "-"
        if detection_for_all_versions and rule_or_version_id:
            rule_or_version_id = f"{rule_or_version_id}@-"

        request_url = '{}/detect/rules/{}/detections?pageSize={}' \
            .format(BACKSTORY_API_V2_URL, rule_or_version_id, page_size)

        # Append parameters if specified
        if detection_start_time:
            request_url += '&startTime={}'.format(detection_start_time)

        if detection_end_time:
            request_url += '&endTime={}'.format(detection_end_time)

        if alert_state:
            request_url += '&alertState={}'.format(alert_state)

        if list_basis:
            request_url += '&listBasis={}'.format(list_basis)

        if page_token:
            request_url += '&page_token={}'.format(page_token)
        # get list of detections from Chronicle Backstory
        json_data = validate_response(client_obj, request_url)
        raw_resp = deepcopy(json_data)
        parsed_ec, token_ec = get_context_for_detections(json_data)
        ec: Dict[str, Any] = {
            CHRONICLE_OUTPUT_PATHS['Detections']: parsed_ec
        }
        if token_ec:
            ec.update({CHRONICLE_OUTPUT_PATHS['Token']: token_ec})
        return ec, raw_resp


    def generate_delayed_start_time(time_window: str, start_time: str) -> str:
        """
        Generate the delayed start time accordingly after validating the time window provided by user.

        :type time_window: str
        :param time_window: Time window to delay the start time.
        :type start_time: str
        :param start_time: Initial start time calculated by fetch_incidents method

        :rtype: delayed_start_time: str
        :return: delayed_start_time: Returns generated delayed start time or raises error if invalid value
         is provided for time window configuration parameter
        """
        if not time_window:
            time_window = '15'
        delayed_start_time = dateparser.parse(start_time, settings={'STRICT_PARSING': True})
        delayed_start_time = delayed_start_time - timedelta(minutes=int(time_window))  # type: ignore
        delayed_start_time = datetime.strftime(delayed_start_time, DATE_FORMAT)  # type: ignore

        return delayed_start_time


    def deduplicate_events_and_create_incidents(contexts: List, event_identifiers: List[str], user_alert: bool = False):
        """
        De-duplicates the fetched events and creates a list of actionable incidents.

        :type contexts: List
        :param contexts: Context of the events fetched.
        :type event_identifiers: List[str]
        :param event_identifiers: List of hashes generated for the events fetched in previous call.
        :type user_alert: bool
        :param user_alert: if enable creates user alerts incidents otherwise create asset alerts incidents

        :rtype: new_event_hashes, incidents
        :return: Returns updated list of event hashes and unique incidents that should be created.
        """
        incidents: List[Dict[str, Any]] = []
        new_event_hashes = []
        for event in contexts:
            try:
                event_hash = sha256(str(event).encode()).hexdigest()  # NOSONAR
                new_event_hashes.append(event_hash)
            except Exception as e:
                demisto.error("[CHRONICLE] Skipping insertion of current event since error occurred while calculating"
                              " Hash for the event {}. Error: {}".format(event, str(e)))
                continue
            if event_identifiers and event_hash in event_identifiers:
                demisto.info("[CHRONICLE] Skipping insertion of current event since it already exists."
                             " Event: {}".format(event))
                continue
            if user_alert:
                event["IncidentType"] = "UserAlert"
                incidents.append({
                    'name': '{} for {}'.format(event['AlertName'], event['User']),
                    'details': json.dumps(event),
                    'rawJSON': json.dumps(event)
                })
            else:
                severity = SEVERITY_MAP.get(event['Severities'].lower(), 0)
                event["IncidentType"] = "AssetAlert"
                unique_incident = {
                    'name': '{} for {}'.format(event['AlertName'], event['Asset']),
                    'details': json.dumps(event),
                    'severity': severity,
                    'rawJSON': json.dumps(event)
                }
                incidents.append(unique_incident)
        return new_event_hashes, incidents


    def deduplicate_detections(detection_context: List[Dict[str, Any]], detection_identifiers: List[Dict[str, Any]]):
        """
        De-duplicates the fetched detections and creates a list of unique detections to be created.

        :type detection_context: Dict[str, Any]
        :param detection_context: Raw response of the detections fetched.
        :type detection_identifiers: List[str]
        :param detection_identifiers: List of dictionaries containing id and ruleVersion of detections.

        :rtype: new_detection_identifiers, incidents
        :return: Returns updated list of detection identifiers and unique incidents that should be created.
        """
        unique_detections = []
        new_detection_identifiers = []
        for detection in detection_context:
            current_detection_identifier = {'id': detection.get('id', ''),
                                            'ruleVersion': detection.get('detection', [])[0].get('ruleVersion', '')}
            new_detection_identifiers.append(current_detection_identifier)
            if detection_identifiers and current_detection_identifier in detection_identifiers:
                demisto.info("[CHRONICLE] Skipping insertion of current detection since it already exists."
                             " Detection: {}".format(detection))
                continue
            unique_detections.append(detection)
        return new_detection_identifiers, unique_detections


    def convert_events_to_actionable_incidents(events: list) -> list:
        """
        Convert event to incident.

        :type events: List
        :param events: List of events

        :rtype: list
        :return: Returns updated list of detection identifiers and unique incidents that should be created.
        """
        incidents = []
        for event in events:
            event["IncidentType"] = "DetectionAlert"
            incident = {
                'name': event['detection'][0]['ruleName'],
                'details': json.dumps(event),
                'rawJSON': json.dumps(event)
            }
            incidents.append(incident)

        return incidents


    def fetch_detections(client_obj, start_time, end_time, max_fetch, detection_to_process, detection_to_pull,
                         pending_rule_or_version_id: list, alert_state, simple_backoff_rules,
                         fetch_detection_by_list_basis):
        """
        Fetch detections in given time slot.

        This method calls the get_max_fetch_detections method.
        If detections are more than max_fetch then it partition it into 2 part, from which
        one part(total detection = max_fetch) will be pushed and another part(detection more than max_fetch) will be
        kept in 'detection_to_process' for next cycle. If all rule_id covers, then it will return empty list.
        """
        if not pending_rule_or_version_id and not detection_to_process and not detection_to_pull and not simple_backoff_rules:
            return [], detection_to_process, detection_to_pull, pending_rule_or_version_id, simple_backoff_rules

        # get detections using API call.
        detection_to_process, detection_to_pull, pending_rule_or_version_id, simple_backoff_rules = get_max_fetch_detections(
            client_obj, start_time, end_time, max_fetch, detection_to_process, detection_to_pull,
            pending_rule_or_version_id, alert_state, simple_backoff_rules, fetch_detection_by_list_basis)

        if len(detection_to_process) > max_fetch:
            events, detection_to_process = detection_to_process[:max_fetch], detection_to_process[max_fetch:]
        else:
            events = detection_to_process
            detection_to_process = []

        return events, detection_to_process, detection_to_pull, pending_rule_or_version_id, simple_backoff_rules


    def get_max_fetch_detections(client_obj, start_time, end_time, max_fetch, detection_incidents, detection_to_pull,
                                 pending_rule_or_version_id, alert_state, simple_backoff_rules,
                                 fetch_detection_by_list_basis):
        """
        Get list of detection using detection_to_pull and pending_rule_or_version_id.

        If the API responds with 429, 500 error then it will retry it for 60 times(each attempt take one minute).
        If it responds with 400 or 404 error, then it will skip that rule_id. In case of an empty response for any next_page_token
        it will skip that rule_id.
        """
        # loop if length of detection is less than max_fetch and if any further rule_id(with or without next_page_token)
        # or any retry attempt remaining
        while len(detection_incidents) < max_fetch and (len(pending_rule_or_version_id) != 0
                                                        or detection_to_pull or simple_backoff_rules):

            next_page_token = ''
            if detection_to_pull:
                rule_id = detection_to_pull.get('rule_id')
                next_page_token = detection_to_pull.get('next_page_token')
            elif simple_backoff_rules:
                rule_id = simple_backoff_rules.get('rule_id')
                next_page_token = simple_backoff_rules.get('next_page_token')
            else:
                rule_id = pending_rule_or_version_id.pop(0)

            try:
                _, raw_resp = get_detections(client_obj, rule_id, max_fetch, start_time, end_time, next_page_token,
                                             alert_state, list_basis=fetch_detection_by_list_basis)
            except ValueError as e:
                if str(e).endswith('Reattempt will be initiated.'):
                    attempts = simple_backoff_rules.get('attempts', 0)
                    if attempts < MAX_ATTEMPTS:
                        demisto.error(
                            f"[CHRONICLE DETECTIONS] Error while fetching incidents: {str(e)} Attempt no : {attempts + 1} "
                            f"for the rule_id : {rule_id} and next_page_token : {next_page_token}")
                        simple_backoff_rules = {'rule_id': rule_id, 'next_page_token': next_page_token,
                                                'attempts': attempts + 1}
                    else:
                        demisto.error(f"[CHRONICLE DETECTIONS] Skipping the rule_id : {rule_id} due to the maximum "
                                      f"number of attempts ({MAX_ATTEMPTS}). You'll experience data loss for the given rule_id. "
                                      f"Switching to next rule id.")
                        simple_backoff_rules = {}
                        detection_to_pull = {}
                    break

                if str(e).startswith('Status code: 404') or str(e).startswith('Status code: 400'):
                    if str(e).startswith('Status code: 404'):
                        demisto.error(
                            f"[CHRONICLE DETECTIONS] Error while fetching incidents: Rule with ID {rule_id} not found.")
                    else:
                        demisto.error(
                            f"[CHRONICLE DETECTIONS] Error while fetching incidents: Rule with ID {rule_id} is invalid.")
                    detection_to_pull = {}
                    simple_backoff_rules = {}
                    break

                demisto.error("Error while fetching incidents: " + str(e))
                if not detection_to_pull:
                    pending_rule_or_version_id.insert(0, rule_id)

                break

            if not raw_resp:
                detection_to_pull = {}
                simple_backoff_rules = {}
                continue

            detections: List[Dict[str, Any]] = raw_resp.get('detections', [])

            # Add found detection in incident list.
            add_detections_in_incident_list(detections, detection_incidents)

            if raw_resp.get('nextPageToken'):
                next_page_token = str(raw_resp.get('nextPageToken'))
                detection_to_pull = {'rule_id': rule_id, 'next_page_token': next_page_token}
                simple_backoff_rules = {'rule_id': rule_id, 'next_page_token': next_page_token}

            # when exact size is returned but no next_page_token
            if len(detections) <= max_fetch and not raw_resp.get('nextPageToken'):
                detection_to_pull = {}
                simple_backoff_rules = {}

        return detection_incidents, detection_to_pull, pending_rule_or_version_id, simple_backoff_rules


    def add_detections_in_incident_list(detections: List, detection_incidents: List) -> None:
        """
        Add found detection in incident list.

        :type detections: list
        :param detections: list of detection
        :type detection_incidents: list
        :param detection_incidents: list of incidents

        :rtype: None
        """
        if detections and len(detections) > 0:
            for detection in detections:
                events_ec = get_events_context_for_detections(detection.get('collectionElements', []))
                detection['collectionElements'] = events_ec
            detection_incidents.extend(detections)


    def get_unique_value_from_list(data: List) -> List:
        """
        Return unique value of list with preserving order.

        :type data: list
        :param data: list of value

        :rtype: list
        :return: list of unique value
        """
        output = []

        for value in data:
            if value and value not in output:
                output.append(value)

        return output


    def fetch_incidents_asset_alerts(client_obj, params: Dict[str, Any], start_time, end_time, time_window, max_fetch):
        """Fetch incidents of asset alerts type.

        :type client_obj: Client
        :param client_obj: client object.
        :type params: dict
        :param params: configuration parameter of fetch incidents.
        :type start_time: str
        :param start_time: start time of request.
        :type end_time: str
        :param end_time: end time of request.
        :type time_window: str
        :param time_window: time delay for an event to appear in chronicle after generation
        :type max_fetch: str
        :param max_fetch: maximum number of incidents to fetch each time

        :rtype: list
        :return: list of incidents
        """
        assets_alerts_identifiers: List = []
        last_run = demisto.getLastRun()
        filter_severity = params.get('incident_severity', 'ALL')  # All to get all type of severity
        if last_run:
            start_time = last_run.get('start_time') or start_time
            assets_alerts_identifiers = last_run.get('assets_alerts_identifiers', assets_alerts_identifiers)
        delayed_start_time = generate_delayed_start_time(time_window, start_time)
        events = get_gcb_alerts(client_obj, delayed_start_time, end_time, max_fetch, filter_severity)
        _, contexts = group_infos_by_alert_asset_name(events)

        # Converts event alerts into  actionable incidents
        new_event_hashes, incidents = deduplicate_events_and_create_incidents(list(contexts.values()),
                                                                              assets_alerts_identifiers)

        # Updates the event hashes in last run with the new event hashes
        if contexts:
            assets_alerts_identifiers = new_event_hashes

        demisto.setLastRun({
            'start_time': end_time,
            'assets_alerts_identifiers': assets_alerts_identifiers
        })

        return incidents


    def fetch_incidents_user_alerts(client_obj, params: Dict[str, Any], start_time, end_time, time_window, max_fetch):
        """Fetch incidents of user alerts type.

        :type client_obj: Client
        :param client_obj: client object.
        :type params: dict
        :param params: configuration parameter of fetch incidents.
        :type start_time: str
        :param start_time: start time of request.
        :type end_time: str
        :param end_time: end time of request.
        :type time_window: str
        :param time_window: time delay for an event to appear in chronicle after generation
        :type max_fetch: str
        :param max_fetch: maximum number of incidents to fetch each time

        :rtype: list
        :return: list of incidents
        """
        user_alerts_identifiers: List = []
        last_run = demisto.getLastRun()

        if last_run:
            start_time = last_run.get('start_time') or start_time
            user_alerts_identifiers = last_run.get('user_alerts_identifiers', user_alerts_identifiers)
        delayed_start_time = generate_delayed_start_time(time_window, start_time)
        events = get_user_alerts(client_obj, delayed_start_time, end_time, max_fetch)
        _, contexts = group_infos_by_alert_user_name(events)

        # Converts user alerts into  actionable incidents
        new_event_hashes, incidents = deduplicate_events_and_create_incidents(contexts, user_alerts_identifiers,
                                                                              user_alert=True)

        # Updates the event hashes in last run with the new event hashes
        if contexts:
            user_alerts_identifiers = new_event_hashes

        demisto.setLastRun({
            'start_time': end_time,
            'user_alerts_identifiers': user_alerts_identifiers
        })

        return incidents


    def fetch_incidents_detection_alerts(client_obj, params: Dict[str, Any], start_time, end_time, time_window, max_fetch):
        """Fetch incidents of detection alert type.

        :type client_obj: Client
        :param client_obj: client object.
        :type params: dict
        :param params: configuration parameter of fetch incidents.
        :type start_time: str
        :param start_time: start time of request.
        :type end_time: str
        :param end_time: end time of request.
        :type time_window: str
        :param time_window: time delay for an event to appear in chronicle after generation
        :type max_fetch: str
        :param max_fetch: maximum number of incidents to fetch each time

        :rtype: list
        :return: list of incidents
        """
        # list of detections that were pulled but not processed due to max_fetch.
        detection_to_process: List[Dict[str, Any]] = []
        # detections that are larger than max_fetch and had a next page token for fetch incident.
        detection_to_pull: Dict[str, Any] = {}
        # max_attempts track for 429 and 500 error
        simple_backoff_rules: Dict[str, Any] = {}
        # rule_id or version_id and alert_state for which detections are yet to be fetched.
        pending_rule_or_version_id_with_alert_state: Dict[str, Any] = {}
        detection_identifiers: List = []
        rule_first_fetched_time = None

        last_run = demisto.getLastRun()
        incidents = []

        if last_run and 'start_time' in last_run:
            start_time = last_run.get('start_time') or start_time
            detection_identifiers = last_run.get('detection_identifiers', detection_identifiers)
            detection_to_process = last_run.get('detection_to_process', detection_to_process)
            detection_to_pull = last_run.get('detection_to_pull', detection_to_pull)
            simple_backoff_rules = last_run.get('simple_backoff_rules', simple_backoff_rules)
            pending_rule_or_version_id_with_alert_state = last_run.get('pending_rule_or_version_id_with_alert_state',
                                                                       pending_rule_or_version_id_with_alert_state)

            end_time = last_run.get('rule_first_fetched_time') or end_time
        if not last_run.get('rule_first_fetched_time'):
            demisto.info(f"Starting new time window from START-TIME :  {start_time} to END_TIME : {end_time}")

        delayed_start_time = generate_delayed_start_time(time_window, start_time)
        fetch_detection_by_alert_state = pending_rule_or_version_id_with_alert_state.get('alert_state', '')
        fetch_detection_by_list_basis = pending_rule_or_version_id_with_alert_state.get('listBasis', 'CREATED_TIME')
        # giving priority to comma separated detection ids over check box of fetch all live detections
        if not pending_rule_or_version_id_with_alert_state.get("rule_id") and \
                not detection_to_pull and not detection_to_process and not simple_backoff_rules:
            fetch_detection_by_ids = params.get('fetch_detection_by_ids') or ""
            if not fetch_detection_by_ids and params.get('fetch_all_detections', False):
                fetch_detection_by_ids = '-'
            fetch_detection_by_ids = get_unique_value_from_list(
                [r_v_id.strip() for r_v_id in fetch_detection_by_ids.split(',')])

            fetch_detection_by_alert_state = params.get('fetch_detection_by_alert_state',
                                                        fetch_detection_by_alert_state)
            fetch_detection_by_list_basis = params.get('fetch_detection_by_list_basis', fetch_detection_by_list_basis)

            # when 1st time fetch or when pending_rule_or_version_id got emptied in last sync.
            # when detection_to_pull has some rule ids
            pending_rule_or_version_id_with_alert_state.update({'rule_id': fetch_detection_by_ids,
                                                                'alert_state': fetch_detection_by_alert_state,
                                                                'listBasis': fetch_detection_by_list_basis})

        events, detection_to_process, detection_to_pull, pending_rule_or_version_id, simple_backoff_rules \
            = fetch_detections(client_obj, delayed_start_time, end_time, int(max_fetch), detection_to_process,
                               detection_to_pull, pending_rule_or_version_id_with_alert_state.get('rule_id', ''),
                               pending_rule_or_version_id_with_alert_state.get('alert_state', ''), simple_backoff_rules,
                               pending_rule_or_version_id_with_alert_state.get('listBasis'))

        # The batch processing is in progress i.e. detections for pending rules are yet to be fetched
        # so updating the end_time to the start time when considered for current batch
        if pending_rule_or_version_id or detection_to_pull or simple_backoff_rules:
            rule_first_fetched_time = end_time
            end_time = start_time
        else:
            demisto.info(f"End of current time window from START-TIME : {start_time} to END_TIME : {end_time}")

        pending_rule_or_version_id_with_alert_state.update({'rule_id': pending_rule_or_version_id,
                                                            'alert_state': fetch_detection_by_alert_state,
                                                            'listBasis': fetch_detection_by_list_basis})

        detection_identifiers, unique_detections = deduplicate_detections(events, detection_identifiers)

        if unique_detections:
            incidents = convert_events_to_actionable_incidents(unique_detections)

        demisto.setLastRun({
            'start_time': end_time,
            'detection_identifiers': detection_identifiers,
            'rule_first_fetched_time': rule_first_fetched_time,
            'detection_to_process': detection_to_process,
            'detection_to_pull': detection_to_pull,
            'simple_backoff_rules': simple_backoff_rules,
            'pending_rule_or_version_id_with_alert_state': pending_rule_or_version_id_with_alert_state
        })

        return incidents


    def convert_events_to_chronicle_event_incident_field(events: List) -> None:
        """Convert Chronicle event into Chronicle Event incident field.

        :type events: list
        :param events: list of Chronicle UDM events

        :rtype: list
        :return: list of incidents
        """
        for event in events:
            event["principalAssetIdentifier"] = get_asset_identifier_details(event.get('principal', {}))
            event["targetAssetIdentifier"] = get_asset_identifier_details(event.get('target', {}))


    def get_user_alerts(client_obj, start_time, end_time, max_fetch):
        """
        Get user alerts and parse response.

        :type client_obj: Client
        :param client_obj: client object
        :type start_time: str
        :param start_time: starting time of request
        :type end_time: str
        :param end_time: end time of request
        :type max_fetch: str
        :param max_fetch: number of records will be returned

        :rtype: list
        :return: list of alerts
        """
        request_url = '{}/alert/listalerts?start_time={}&end_time={}&page_size={}'.format(BACKSTORY_API_V1_URL, start_time,
                                                                                          end_time, max_fetch)
        demisto.debug("[CHRONICLE] Request URL for fetching user alerts: {}".format(request_url))

        json_response = validate_response(client_obj, request_url)

        alerts = []
        for user_alert in json_response.get('userAlerts', []):

            # parsing each alert infos
            infos = []
            for alert_info in user_alert['alertInfos']:
                info = {
                    'Name': alert_info.get('name', ''),
                    'SourceProduct': alert_info.get('sourceProduct', ''),
                    'Timestamp': alert_info.get('timestamp', ''),
                    'Uri': alert_info.get('uri', [''])[0],
                    'RawLog': base64.b64decode(alert_info.get('rawLog', '')).decode(),  # decode base64 raw log
                    'UdmEvent': alert_info.get('udmEvent', {})
                }
                infos.append(info)
            user_identifier = list(user_alert.get("user", {}).values())
            asset_alert = {
                'User': user_identifier[0] if user_identifier else "",
                'AlertCounts': len(infos),
                'AlertInfo': infos
            }
            alerts.append(asset_alert)
        return alerts


    def group_infos_by_alert_user_name(user_alerts):
        """
        Group user alerts with combination of user identifier and alert name.

        :type user_alerts: list
        :param user_alerts: list of user alerts

        :rtype: str, list
        :return: human readable and incident context data
        """
        user_alerts = deepcopy(user_alerts)

        hr = []
        incident_context = []
        unique_alert = defaultdict(list)
        for user_alert in user_alerts:
            user = user_alert.get("User", "")
            for alert_info in user_alert["AlertInfo"]:
                alert_info["User"] = user
                unique_alert[user + " - " + alert_info["Name"]].append(alert_info)

        for _, value in unique_alert.items():
            occurrences = []
            events = []
            raw_logs = []
            for info in value:
                occurrences.append(info.get("Timestamp", ""))
                events.append(info.get("UdmEvent", ""))
                raw_logs.append(info.get("RawLog", ""))
            occurrences.sort()
            events = get_context_for_events(events)
            convert_events_to_chronicle_event_incident_field(events)

            hr.append({
                "User": '[{}]({})'.format(value[0]["User"], value[0]["Uri"]),
                'Alerts': len(value),
                ALERT_NAMES: value[0].get("Name", ""),
                FIRST_SEEN: get_informal_time(occurrences[0]),
                LAST_SEEN: get_informal_time(occurrences[-1]),
                'Sources': value[0].get("SourceProduct", ""),
            })
            incident_context.append({
                "User": value[0]["User"],
                'Alerts': len(value),
                'AlertName': value[0].get("Name", ""),
                'Occurrences': occurrences,
                'FirstSeen': occurrences[0],
                'LastSeen': occurrences[-1],
                'Sources': value[0].get("SourceProduct", ""),
                'UdmEvents': events,
                'RawLogs': raw_logs
            })

        return hr, incident_context


    def get_user_alert_hr_and_ec(client_obj: Client, start_time: str, end_time: str, page_size: str):
        """
        Get and parse HR, EC and raw response.

        :type client_obj: Client
        :param client_obj: client object
        :type start_time: str
        :param start_time: start time
        :type end_time: str
        :param end_time: end time
        :type page_size: str
        :param page_size: maximum number of records to be fetch

        :rtype: str, dict, dict
        :return: human readable. entry context and raw response
        """
        alerts = get_user_alerts(client_obj, start_time, end_time, page_size)
        if not alerts:
            hr = '### User Alert(s): '
            hr += MESSAGES["NO_RECORDS"]
            return hr, {}, {}

        # prepare alerts into human readable
        data, _ = group_infos_by_alert_user_name(alerts)
        hr = tableToMarkdown('User Alert(s)', data, ['Alerts', 'User', ALERT_NAMES, FIRST_SEEN, LAST_SEEN, 'Sources'],
                             removeNull=True)

        for alert in alerts:
            for alert_info in alert.get('AlertInfo', []):
                alert_info.pop('Uri', None)
                alert_info.pop('UdmEvent', None)

        ec = {
            CHRONICLE_OUTPUT_PATHS['UserAlert']: alerts
        }

        return hr, ec, alerts


    def get_context_for_rules(rule_resp: Dict[str, Any]) -> Tuple[List[Dict[str, Any]], Dict[str, str]]:
        """
        Convert rules response into Context data.

        :param rule_resp: Response fetched from the API call for rules
        :type rule_resp: Dict[str, Any]

        :return: list of rules and token to populate context data
        :rtype: Tuple[List[Dict[str, Any]], Dict[str, str]]
        """
        rules_ec = []
        token_ec = {}
        next_page_token = rule_resp.get('nextPageToken')
        if next_page_token:
            token_ec = {'name': 'gcb-list-rules', 'nextPageToken': next_page_token}
        rules = rule_resp.get('rules', [])
        for rule in rules:
            rules_ec.append(rule)

        return rules_ec, token_ec


    def get_rules(client_obj, args: Dict[str, str]) -> Tuple[Dict[str, Any], Dict[str, Any]]:
        """
        Return context data and raw response for gcb-list-rules command.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type args:  Dict[str, str]
        :param args: it contain arguments of gcb-list-rules command

        :rtype: Tuple[Dict[str, Any], Dict[str, Any]]
        :return: ec, json_data: Context data and raw response for the fetched rules
        """
        page_size = args.get('page_size', 100)
        validate_page_size(page_size)
        page_token = args.get('page_token', '')
        if int(page_size) > 1000:
            raise ValueError(MESSAGES["INVALID_PAGE_SIZE"])

        live_rule = args.get('live_rule', '').lower()
        if live_rule and live_rule != 'true' and live_rule != 'false':
            raise ValueError('Live rule should be true or false.')

        request_url = '{}/detect/rules?pageSize={}'.format(BACKSTORY_API_V2_URL, page_size)

        # Append parameters if specified
        if page_token:
            request_url += '&page_token={}'.format(page_token)

        # get list of rules from Chronicle Backstory
        json_data = validate_response(client_obj, request_url)
        if live_rule:
            if live_rule == 'true':
                list_live_rule = [rule for rule in json_data.get('rules', []) if rule.get('liveRuleEnabled')]
            else:
                list_live_rule = [rule for rule in json_data.get('rules', []) if not rule.get('liveRuleEnabled')]
            json_data = {
                'rules': list_live_rule
            }
        raw_resp = deepcopy(json_data)
        parsed_ec, token_ec = get_context_for_rules(json_data)
        ec: Dict[str, Any] = {
            CHRONICLE_OUTPUT_PATHS['Rules']: parsed_ec
        }
        if token_ec:
            ec.update({CHRONICLE_OUTPUT_PATHS['Token']: token_ec})
        return ec, raw_resp


    def get_list_rules_hr(rules: List[Dict[str, Any]]) -> str:
        """
        Convert rules response into human readable.

        :param rules: list of rules
        :type rules: list

        :return: returns human readable string for gcb-list-rules command
        :rtype: str
        """
        hr_dict = []
        for rule in rules:
            hr_dict.append({
                'Rule ID': rule.get('ruleId'),
                'Rule Name': rule.get('ruleName'),
                'Compilation State': rule.get('compilationState', '')
            })
        hr = tableToMarkdown('Rule(s) Details', hr_dict, ['Rule ID', 'Rule Name', 'Compilation State'],
                             removeNull=True)
        return hr


    ''' REQUESTS FUNCTIONS '''


    def test_function(client_obj, params: Dict[str, Any]):
        """
        Perform test connectivity by validating a valid http response.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type params:  Dict[str, Any]
        :param params: it contain configuration parameter

        :return: raise ValueError if any error occurred during connection
        :rtype: None
        """
        demisto.debug('Running Test having Proxy {}'.format(params.get('proxy')))
        request_url = '{}/ioc/listiocs?start_time=2019-10-15T20:37:00Z&page_size=1'.format(
            BACKSTORY_API_V1_URL)

        validate_response(client_obj, request_url)
        demisto.results('ok')


    def gcb_list_iocs_command(client_obj, args: Dict[str, Any]):
        """
        List all of the IoCs discovered within your enterprise within the specified time range.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type args:  Dict[str, Any]
        :param args: it contain arguments of gcb-list-ioc command

        :return: command output
        :rtype: (dict, dict, dict)
        """
        # retrieve arguments and validate it

        start_time, _, page_size, _ = get_default_command_args_value(args)

        # Make a request
        request_url = '{}/ioc/listiocs?start_time={}&page_size={}'.format(
            BACKSTORY_API_V1_URL, start_time, page_size)
        json_data = validate_response(client_obj, request_url)

        # List of IoCs returned for further processing
        ioc_matches = json_data.get('response', {}).get('matches', [])
        if ioc_matches:
            ioc_matches_resp = parse_list_ioc_response(ioc_matches)

            # prepare human readable response
            hr = tableToMarkdown('IOC Domain Matches', ioc_matches_resp['hr_ioc_matches'],
                                 ['Domain', 'Category', 'Source', 'Confidence', 'Severity', 'IOC ingest time',
                                  'First seen', 'Last seen'], removeNull=True)
            # prepare entry context response
            ec = {
                outputPaths['domain']: ioc_matches_resp['domain_std_context'],
                CHRONICLE_OUTPUT_PATHS['Iocs']: ioc_matches_resp['context']
            }
            return hr, ec, json_data
        else:
            return '### No domain matches found', {}, {}


    def gcb_assets_command(client_obj, args: Dict[str, str]):
        """
        List assets which relates to an IOC.

        This command will respond with a list of the assets which accessed the input artifact
        (ip, domain, md5, sha1, sha256) during the specified time.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type args:  Dict[str, str]
        :param args: it contain arguments of gcb-list-ioc command

        :return: command output
        """
        artifact_value = args.get('artifact_value', '')
        artifact_type = get_artifact_type(artifact_value)

        start_time, end_time, page_size, _ = get_default_command_args_value(args)

        request_url = '{}/artifact/listassets?artifact.{}={}&start_time={}&end_time={}&page_size={}'.format(
            BACKSTORY_API_V1_URL, artifact_type, urllib.parse.quote(artifact_value), start_time, end_time, page_size)

        response = validate_response(client_obj, request_url)

        ec = {}  # type: Dict[str, Any]
        if response and response.get('assets'):
            context_data, tabular_data, host_context = parse_assets_response(response, artifact_type,
                                                                             artifact_value)
            hr = tableToMarkdown('Artifact Accessed - {0}'.format(artifact_value), tabular_data,
                                 ['Host Name', 'Host IP', 'Host MAC', FIRST_ACCESSED_TIME, LAST_ACCESSED_TIME])
            hr += '[View assets in Chronicle]({})'.format(response.get('uri', [''])[0])
            ec = {
                'Host': host_context,
                **context_data
            }
        else:
            hr = '### Artifact Accessed: {} \n\n'.format(artifact_value)
            hr += MESSAGES["NO_RECORDS"]
        return hr, ec, response


    def gcb_ioc_details_command(client_obj, args: Dict[str, str]):
        """
        Fetch IoC Details from Backstory using 'listiocdetails' Search API.

        :type client_obj: Client
        :param client_obj: The Client object which abstracts the API calls to Backstory.

        :type args: dict
        :param args: the input artifact value, whose details are to be fetched.

        :return: command output (Human Readable, Context Data and Raw Response)
        :rtype: tuple
        """
        artifact_value = args.get('artifact_value', '')
        artifact_type = get_artifact_type(artifact_value)

        request_url = '{}/artifact/listiocdetails?artifact.{}={}'.format(BACKSTORY_API_V1_URL, artifact_type,
                                                                         urllib.parse.quote(artifact_value))
        response = validate_response(client_obj, request_url)

        ec = {}  # type: Dict[str, Any]
        hr = ''
        if response and response.get('sources'):
            normal_artifact_type = None
            if artifact_type == 'destination_ip_address':
                normal_artifact_type = 'ip'
            elif artifact_type == 'domain_name':
                normal_artifact_type = 'domain'
            else:
                raise ValueError('Unsupported artifact type')

            context_dict = get_context_for_ioc_details(response.get('sources', []), artifact_value, normal_artifact_type,
                                                       is_reputation_command=False)
            ec = {
                outputPaths[normal_artifact_type]: context_dict['standard_context'],
                CHRONICLE_OUTPUT_PATHS['IocDetails']: context_dict['context']
            }

            if context_dict['hr_table_data']:
                hr += tableToMarkdown('IoC Details', context_dict['hr_table_data'],
                                      ['Domain', IP_ADDRESS, 'Category', CONFIDENCE_SCORE, 'Severity',
                                       FIRST_ACCESSED_TIME, LAST_ACCESSED_TIME])
                hr += '[View IoC details in Chronicle]({})'.format(response.get('uri', [''])[0])
            else:
                hr += MESSAGES["NO_RECORDS"]
            return hr, ec, response

        else:
            hr += '### For artifact: {}\n'.format(artifact_value)
            hr += MESSAGES["NO_RECORDS"]

            return hr, ec, response


    def ip_command(client_obj, ip_address: str):
        """
        Reputation command for given IP address.

        :type client_obj: Client
        :param client_obj: object of the client class

        :type ip_address: str
        :param ip_address: contains arguments of reputation command ip

        :return: command output
        :rtype: tuple
        """
        if not is_ip_valid(ip_address, True):
            raise ValueError('Invalid IP - {}'.format(ip_address))

        request_url = '{}/artifact/listiocdetails?artifact.destination_ip_address={}'.format(
            BACKSTORY_API_V1_URL, ip_address)

        response = validate_response(client_obj, request_url)

        ec = {}  # type: Dict[str, Any]
        hr = ''
        if response and response.get('sources'):
            context_dict = get_context_for_ioc_details(response.get('sources', []), ip_address, 'ip')

            # preparing human readable
            hr += 'IP: ' + str(ip_address) + ' found with Reputation: ' + str(context_dict['reputation']) + '\n'
            if context_dict['hr_table_data']:
                hr += tableToMarkdown('Reputation Parameters', context_dict['hr_table_data'],
                                      ['Domain', IP_ADDRESS, 'Category', CONFIDENCE_SCORE, 'Severity',
                                       FIRST_ACCESSED_TIME, LAST_ACCESSED_TIME])
                hr += '[View IoC details in Chronicle]({})'.format(response.get('uri', [''])[0])
            else:
                hr += MESSAGES["NO_RECORDS"]

            # preparing entry context
            ec = {
                'DBotScore': context_dict['dbot_context'],
                outputPaths['ip']: context_dict['standard_context'],
                CHRONICLE_OUTPUT_PATHS['Ip']: context_dict['context']
            }
        else:
            dbot_context = {
                'Indicator': ip_address,
                'Type': 'ip',
                'Vendor': VENDOR,
                'Score': 0
            }

            hr += '### IP: {} found with Reputation: Unknown\n'.format(ip_address)
            hr += MESSAGES["NO_RECORDS"]

            ec = {
                'DBotScore': dbot_context
            }

        return hr, ec, response


    def domain_command(client_obj, domain_name: str):
        """
        Reputation command for given Domain address.

        :type client_obj: Client
        :param client_obj: object of the client class

        :type domain_name: str
        :param domain_name: contains arguments of reputation command domain

        :return: command output
        :rtype: tuple
        """
        request_url = '{}/artifact/listiocdetails?artifact.domain_name={}'.format(BACKSTORY_API_V1_URL,
                                                                                  urllib.parse.quote(domain_name))
        response = validate_response(client_obj, request_url)

        ec = {}  # type: Dict[str, Any]
        hr = ''
        if response and response.get('sources'):
            context_dict = get_context_for_ioc_details(response.get('sources', []), domain_name, 'domain')

            # preparing human readable
            hr += 'Domain: ' + str(domain_name) + ' found with Reputation: ' + str(context_dict['reputation']) + '\n'
            if context_dict['hr_table_data']:
                hr += tableToMarkdown('Reputation Parameters', context_dict['hr_table_data'],
                                      ['Domain', IP_ADDRESS, 'Category', CONFIDENCE_SCORE, 'Severity',
                                       FIRST_ACCESSED_TIME, LAST_ACCESSED_TIME])
                hr += '[View IoC details in Chronicle]({})'.format(response.get('uri', [''])[0])
            else:
                hr += MESSAGES["NO_RECORDS"]

            # preparing entry context
            ec = {
                'DBotScore': context_dict['dbot_context'],
                outputPaths['domain']: context_dict['standard_context'],
                CHRONICLE_OUTPUT_PATHS['Domain']: context_dict['context']
            }

            return hr, ec, response

        else:
            dbot_context = {
                'Indicator': domain_name,
                'Type': 'domain',
                'Vendor': VENDOR,
                'Score': 0
            }

            hr += '### Domain: {} found with Reputation: Unknown\n'.format(domain_name)
            hr += MESSAGES["NO_RECORDS"]

            ec = {
                'DBotScore': dbot_context
            }

            return hr, ec, response


    def fetch_incidents(client_obj, params: Dict[str, Any]):
        """
        Fetch alerts or IoC domain matches and convert them into actionable incidents.

        :type client_obj: Client
        :param client_obj: object of the client class

        :type params: dict
        :param params: configuration parameter of fetch incidents
        :return:
        """
        first_fetch_in_days = params.get('first_fetch', DEFAULT_FIRST_FETCH).lower()  # 3 days as default
        max_fetch = params.get('max_fetch', 10)  # default page size
        time_window = params.get('time_window', '15')

        # getting numeric value from string representation
        start_time, end_time = parse_date_range(first_fetch_in_days, date_format=DATE_FORMAT)

        # backstory_alert_type will create actionable incidents based on input selection in configuration
        backstory_alert_type = params.get('backstory_alert_type', 'ioc domain matches').lower()

        incidents = []

        if "assets with alerts" == backstory_alert_type:
            incidents = fetch_incidents_asset_alerts(client_obj, params, start_time, end_time, time_window, max_fetch)
        elif "user alerts" == backstory_alert_type:
            incidents = fetch_incidents_user_alerts(client_obj, params, start_time, end_time, time_window, max_fetch)
        elif 'detection alerts' == backstory_alert_type:
            incidents = fetch_incidents_detection_alerts(client_obj, params, start_time, end_time, time_window, max_fetch)
        else:
            last_run = demisto.getLastRun()
            if last_run:
                start_time = last_run.get('start_time') or start_time

            events = get_ioc_domain_matches(client_obj, start_time, max_fetch)
            # Converts IoCs into actionable incidents
            for event in events:
                event["IncidentType"] = "IocDomainMatches"
                incident = {
                    'name': 'IOC Domain Match: {}'.format(event['Artifact']),
                    'details': json.dumps(event),
                    'rawJSON': json.dumps(event)
                }
                incidents.append(incident)

            demisto.setLastRun({'start_time': end_time})

        # this command will create incidents in Demisto
        demisto.incidents(incidents)


    def gcb_list_alerts_command(client_obj, args: Dict[str, Any]):
        """
        List alerts which relates to an asset.

        This method fetches alerts that are correlated to the asset under investigation.
        :type client_obj: Client
        :param client_obj:

        :type args: Dict
        :param args: inputs to fetch alerts from a specified date range. start_time, end_time, and page_size are
            considered for pulling the data.
        """
        start_time, end_time, page_size, _ = get_default_command_args_value(args)

        alert_type = args.get('alert_type', 'Asset Alerts').lower()

        if alert_type not in ["asset alerts", "user alerts"]:
            raise ValueError('Allowed value for alert type should be either "Asset Alerts" or "User Alerts".')

        if alert_type == 'asset alerts':
            severity_filter = args.get('severity', 'ALL')

            # gathering all the alerts from Backstory
            alerts = get_gcb_alerts(client_obj, start_time, end_time, page_size, severity_filter)
            if not alerts:
                hr = '### Security Alert(s): '
                hr += MESSAGES["NO_RECORDS"]
                return hr, {}, {}

            # prepare alerts into human readable
            hr = convert_alerts_into_hr(alerts)

            # Remove Url key in context data
            for alert in alerts:
                for alert_info in alert.get('AlertInfo', []):
                    if 'Uri' in alert_info.keys():
                        del alert_info['Uri']
            ec = {
                CHRONICLE_OUTPUT_PATHS['Alert']: alerts
            }

            return hr, ec, alerts
        else:
            hr, ec, raw_alert = get_user_alert_hr_and_ec(client_obj, start_time, end_time, page_size)
            return hr, ec, raw_alert


    def gcb_list_events_command(client_obj, args: Dict[str, str]):
        """
        List all of the events discovered within your enterprise on a particular device within the specified time range.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type args:  Dict[str, str]
        :param args: it contain arguments of gcb-list-ioc command

        :return: command output
        :rtype: str, dict, dict
        """
        asset_identifier_type = ASSET_IDENTIFIER_NAME_DICT.get(args.get('asset_identifier_type', '').lower(),
                                                               args.get('asset_identifier_type', ''))
        asset_identifier = urllib.parse.quote(args.get('asset_identifier', ''))

        # retrieve arguments and validate it
        start_time, end_time, _, _ = get_default_command_args_value(args, '2 hours')

        page_size = args.get('page_size', '100')

        # validate page size argument
        if int(page_size) > 1000:
            raise ValueError(MESSAGES["INVALID_PAGE_SIZE"])

        reference_time = args.get('reference_time', start_time)

        # Make a request URL
        request_url = '{}/asset/listevents?asset.{}={}&start_time={}&end_time={}&page_size={}&reference_time={}' \
            .format(BACKSTORY_API_V1_URL, asset_identifier_type, asset_identifier, start_time, end_time, page_size,
                    reference_time)
        demisto.debug('Requested url : ' + request_url)

        # get list of events from Chronicle Backstory
        json_data = validate_response(client_obj, request_url)

        events = json_data.get('events', [])
        if not events:
            hr = 'No Events Found'
            return hr, {}, {}

        # prepare alerts into human readable
        hr = get_list_events_hr(events)
        hr += '[View events in Chronicle]({})'.format(json_data.get('uri', [''])[0])

        if json_data.get('moreDataAvailable', False):
            last_event_timestamp = events[-1].get('metadata', {}).get('eventTimestamp', '')
            hr += '\n\nMaximum number of events specified in page_size has been returned. There might' \
                  ' still be more events in your Chronicle account.'
            if not dateparser.parse(last_event_timestamp, settings={'STRICT_PARSING': True}):
                demisto.error('Event timestamp of the last event: {} is invalid.'.format(last_event_timestamp))
                hr += ' An error occurred while fetching the start time that could have been used to' \
                      ' fetch next set of events.'
            else:
                hr += ' To fetch the next set of events, execute the command with the start time as {}.' \
                    .format(last_event_timestamp)

        parsed_ec = get_context_for_events(json_data.get('events', []))

        ec = {
            CHRONICLE_OUTPUT_PATHS["Events"]: parsed_ec
        }

        return hr, ec, json_data


    def gcb_list_detections_command(client_obj, args: Dict[str, str]):
        """
        Return the Detections for a specified Rule Version.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type args:  Dict[str, str]
        :param args: it contain arguments of gcb-list-detections command

        :return: command output
        :rtype: str, dict, dict
        """
        # retrieve arguments and validate it
        valid_args = validate_and_parse_list_detections_args(args)

        ec, json_data = get_detections(client_obj, args.get('id', ''), valid_args.get('page_size', ''),
                                       valid_args.get('detection_start_time', ''), valid_args.get('detection_end_time', ''),
                                       args.get('page_token', ''), args.get('alert_state', ''),
                                       valid_args.get('detection_for_all_versions', False),
                                       args.get('list_basis', ''))

        detections = json_data.get('detections', [])
        if not detections:
            hr = 'No Detections Found'
            return hr, {}, {}

        # prepare alerts into human readable
        hr = get_list_detections_hr(detections, args.get('id', ''))
        hr += '\nView all detections for this rule in Chronicle by clicking on {} and to view individual detection' \
              ' in Chronicle click on its respective Detection ID.\n\nNote: If a specific version of the rule is provided' \
              ' then detections for that specific version will be fetched.'.format(detections[0].
                                                                                   get('detection')[0].get('ruleName'))

        next_page_token = json_data.get('nextPageToken')
        if next_page_token:
            hr += '\nMaximum number of detections specified in page_size has been returned. To fetch the next set of' \
                  ' detections, execute the command with the page token as {}.'.format(next_page_token)

        return hr, ec, json_data


    def gcb_list_rules_command(client_obj, args: Dict[str, str]):
        """
        Return the latest version of all rules.

        :type client_obj: Client
        :param client_obj: client object which is used to get response from api

        :type args:  Dict[str, str]
        :param args: it contain arguments of gcb-list-rules command

        :return: command output
        :rtype: str, dict, dict
        """
        ec, json_data = get_rules(client_obj, args)

        rules = json_data.get('rules', [])
        if not rules:
            hr = 'No Rules Found'
            return hr, {}, {}

        hr = get_list_rules_hr(rules)

        next_page_token = json_data.get('nextPageToken')
        if next_page_token:
            hr += '\nMaximum number of rules specified in page_size has been returned. To fetch the next set of' \
                  ' rules, execute the command with the page token as {}.'.format(next_page_token)

        return hr, ec, json_data


    def main():
        """PARSE AND VALIDATE INTEGRATION PARAMS."""
        # supported command list
        chronicle_commands = {
            'gcb-list-iocs': gcb_list_iocs_command,
            'gcb-assets': gcb_assets_command,
            'gcb-ioc-details': gcb_ioc_details_command,
            'gcb-list-alerts': gcb_list_alerts_command,
            'gcb-list-events': gcb_list_events_command,
            'gcb-list-detections': gcb_list_detections_command,
            'gcb-list-rules': gcb_list_rules_command
        }
        # initialize configuration parameter
        proxy = demisto.params().get('proxy')
        disable_ssl = demisto.params().get('insecure', False)
        command = demisto.command()

        try:
            validate_configuration_parameters(demisto.params())

            # Initializing client Object
            client_obj = Client(demisto.params(), proxy, disable_ssl)

            # trigger command based on input
            if command == 'test-module':
                test_function(client_obj, demisto.args())
            elif command == 'fetch-incidents':
                fetch_incidents(client_obj, demisto.params())
            elif command == 'ip':
                ip = demisto.args()['ip']
                reputation_operation_command(client_obj, ip, ip_command)
            elif command == 'domain':
                domain = demisto.args()['domain']
                reputation_operation_command(client_obj, domain, domain_command)
            elif command in chronicle_commands:
                return_outputs(*chronicle_commands[command](client_obj, demisto.args()))

        except Exception as e:
            return_error('Failed to execute {} command.\nError: {}'.format(demisto.command(), str(e)))


    # initial flow of execution
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Google Chronicle Backstory', 'end', __line__())
  subtype: python3
  type: python
system: true
