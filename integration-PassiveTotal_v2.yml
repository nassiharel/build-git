category: Data Enrichment & Threat Intelligence
commonfields:
  id: PassiveTotal v2
  version: -1
configuration:
- defaultvalue: https://api.passivetotal.org
  display: API URL
  name: url
  required: true
  type: 0
- display: Username
  name: username
  required: true
  type: 0
- display: API Secret
  name: secret
  required: true
  type: 4
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: All the PassiveTotal API calls would timeout if the response is
    not returned within the configured time interval. Default is 20.
  defaultvalue: "20"
  display: HTTP(S) Request Timeout (in seconds)
  name: request_timeout
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 2.1.1
    packID: PassiveTotal
    packName: PassiveTotal
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Analyze and understand threat infrastructure from a variety of sources-passive
  DNS, active DNS, WHOIS, SSL certificates and more-without devoting resources to
  time-intensive manual threat research and analysis.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: RiskIQ
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [paloaltonetworks@riskiq.net](mailto:paloaltonetworks@riskiq.net)
  - **URL**: [https://www.riskiq.com/resources/support/](https://www.riskiq.com/resources/support/)
  ***
  Generate a RiskIQ PassiveTotal API credentials
  ------------------------------------------
  RiskIQ PassiveTotal works best for existing enterprise clients, though is functional for free clients as well. In order to leverage the functionality within this application, users must first register for an account on [RiskIQ Community](https://community.riskiq.com/) using a corporate email address. Once verified, API keys can be found within the [Account Settings](https://community.riskiq.com/settings) page.


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/passive-total-v2)
display: PassiveTotal v2 (Partner Contribution)
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyVpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDAyIDc5LjE2NDM2MCwgMjAyMC8wMi8xMy0wMTowNzoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjEgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUU5NDlFRTU5QTI2MTFFQTk2OTU5MkZBMDA4QzVCRTAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUU5NDlFRTY5QTI2MTFFQTk2OTU5MkZBMDA4QzVCRTAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowQTg5NTgzODk5Q0UxMUVBOTY5NTkyRkEwMDhDNUJFMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1RTk0OUVFNDlBMjYxMUVBOTY5NTkyRkEwMDhDNUJFMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrDuRKsAAA1OSURBVHja7FsJdFRFFq2/dv/es4ckZiEJCIRVNgHHDVFZFD2KEBEdZERxUBFUQNARFDCKwDi4goPAgDIjDLIoCEcMAiYEkDUhO0mTdFbS6b3/Nq/ijweSTtKR4bic/865VPfvqt/169Z7777qQMiyjFT74xqpLoFKsGoqwaqpBKumEqyaSrBqKsGqqQSrBKumEqyaSrBqKsGqXWOjW14gCKLDQeELvqU5DWuQtCxDcRrJoGW856b1cKnL+etbyx+PiFYX2iHY+OI3z4DLv2rUaUIZvRbJBh2iDBxKNGpQhIaS/G7vAZfHl75n8vVV6lL/jgjuuuo4K/PiEaNeMyAhNhRxDI1YmkQUSSBbowcRooTiww3IomORwAt8QXndxB0TU7eqy/07ITjtk9yCcIshRUMRSEuRyOv2uf0+/hiMzWcoQm/Wa4ZqWDohIcpEsNDH5RPkE+crx+2b0mOXuuS/cYITV5/6ICrKPJ0jgVinR66qqN9UW++Y4si4Q7q838j1uUNjI027k6LNIT5BQuXVTu/J4uqw03/t51aX/TdKcJcVx7TmcLPTzDFUY1UDsl6oXhNm0n1NmfRJhFEXxnCMzkxTPgNF2HU0aWWRbIswsFsNOo2u2uFDR/IrP8qf0Xe6uuy/HsF0u70F8RGKoSl7XSOy19jRzAmDH/f4hEc9fsFn94mOS4IsOv1SJPRkm2oumkZ2HjkvXGyw0iTZxcswE+GySvA1tkeyHWnQhAK+B0hBE8wyzGhJEFHVhWqUkhgFwooiAAzkXCYaIYNfEGW/IBPVdq/TwYsNMCQOUrAhwsxpMovryngI1V1WnYisfLZ/tUrDNSN3PDSDAI2AnoAPgiJ48s7yTbVu//j8KicQSyNSz6GyakeN3y/s9nj5zUYdm7ludJwH9x29qaAfL6N7wNtH6nRsdJhBk3pbamT0V0U1LggZe7q8e3JM5cy+FYG+J3rRoW7Q9OngOUSAF1AJyLO9MtzbskPM4sMGKOFmIgIdsC4YdqTl50lLf7BA8JoGKWg0tD0hE4VKBEFDWw95qRhwAJFoXemsgedajX3/ZDL060+Q5L6iJ3o3tDXJvv8pImWSGEFSZCRBkzxDk99k3xnXpEFCpv6rpxAds6x7WsL7Oeldvwo0vs+np0JFRKyAed2FKBSG9BxlMWplHUvzJEWUkYj4eM+wiIyWfqisTwyguMODDmzpO8qeT44NmVRfVINklwdxLI0qCy9Oz3r4Tx8F6r87PfVHaDAWDVlzVl+O0P7+yVE9ByWENvxoc/TjPf6NMe+dHlkxo7cUYDjegW92YtNWxiw6dEfFK8PPtizTAUsA8wFXEJy45MhAaPCihis7/SigBuADRABuALwAmJO04tiHsEmeLXnuBv9ltxgN+Dugv/Kcrazf54XJsHE2K950BjCxmVxsjE5r4GV5HF6uQONT3sueVVNWm0HTFI3MemSy6Fw0TbpIkhRkRJggtabAvN4cdaRmLnS/Y++NEceUoRzACigFXNchwfdtu0DHRhiXYq2lYSgEXwB7hESuCzX+YFY/a1ovV9Tiw90uVDboxw/vFmYONVhdLt+tPo9/Kny8pp2hSeCZpW19CJ4eo2yEyYB1ykIGa+sUct8ALC6dO8R3xQZ4+yg+sh2rkPgk4DTgvWBvnrY5f5ISGk3KMz5zYky85wo3M2rdbZUT1684tNBaXLXIYODk0NjQvZoI8/TscUlXrAUQ2xU20CJ4+TDgW3h/C5B8HF5vUDagDvBFhwSzLDVJr2WaRBPHUqKMWcaZW5JGKQvVriW/nUMiXjSDnCMPn7KS4WnX5VMkF+fR0E90QHC7BuRXAMlPwcv7AQPBi6PAizs8MQPvxSKwF+Bi6byhCwL1KZ0zCEeWLxNX5GRhHQHeeyyYOfVan6sHD8CbAm9eB2DSqfu7fhaorykuzNNgbU1xz1WHUusKba9pTHopNCF8wsk/9/si0HggE4ffyUBsIbSvAlYDbtww2IjnvrO53/oWKppsTTB9Z/PrkvLajUAwwpBE8eZgHjrMonsopYuZTImxIMHjqWUlqZYXJdgszKDY175jrkZQAMlOaOqUt5Ygh+FVxU8dlrj0h67tdYT8W1UyKzhye6w7h3VDjkIu9qT+Jx9I/qyt/pau0QEd2GN3r5YFkeg6oOuqc22Qe7nZqxpe91xyFcHLoUB2r476tyIYqqKmOG675EJFhZUvkhpGJDHBvNAlYs7unh16TJRpXup1oYgCOd3o9O4XJPk4jEXu+ka+Mf8CdzUEgwcPUfIM9paSYMaUzr/RqUQeLc69Scuy1iQuy3o66c2scQkZ2UMS38qOhxDdqY3X/ZOzT0OTjaMroBZw648PpRS1W5EYOREEXn0rgi85B0f2iEMhMSHvBJUCx6cKnnpHsw4Y01H/ViFaJgi8EMhqaxCqM+6qNm0ozAGFOYS1GAnR7V2Lw0JbN7t/j+2GpDBd76pLbnQiKw9RUWFvOHzCRAE82FluK4ewTbUzl1FAYFvlVBigt+It2JZAePZ3ghOcV21KTf54IJWeuDynBLb7fgIRK8GL89q4T2jKmjPbFGGIRRrOs/GAtSCyJgDJ7f4/IIqhWqUUv9NjDAHvhhBsDfZhBI+vORokdppgNy86vbyEaqoa6Ki5e1IIinoS1NsJNioUNWSfHRo5b+/d1UtHBZT5eprabq1zo727jyHWZDhuXTiizLjlQjf81K78cgdsEKmduXzYwVx5xWtWA7mbO+Nx4MV4M8yHEL0QWhymU3GuBUThAztAAmCAsgEeS1p57GbIw1kBbrUdYAAcUMQOFlWHAQ8A3sIqvL15aPWsM9DJExdqIDoVyqSfHUXsNMEOv5jb6BFuEyQJiT5+YUF60qOpm0sOa2MihjWFlMrabTErc+Irnht4hbeN3V259ZLTG3vw4DlEEYRE6rUPDttSoq8VxLG83WXn6xqTMc/tzOUvgMJAIlMRFLj2nQl5+MQvDfEgsvCCFCi4MrUszyGVUmmZQtSDAW6BlerfAK/nPtYT36ui18bz90K7DzAb6uBSyMP/aOv7dWZtq2saA+eCCGmEfJoIXlwazHOIfqH53KCw0znY6Re3NPoExJkMyGerTY99eX93uDyOZGifJjoMCU63xtfoKkhcm/dzzXXL1rK1NlvD+O8O5SERwrEm3JxR/vLwYrtHmE96/RH27NxagmG+df93utDOXHKAvAMBgMuPuUqduwvCePy1OBEqnT0QR5d3lbdtfcfEwmlpr52f2utnzzk7uftBaKYob1f12Vp8b1vfYQjRGVsRbOJOSnzT7aYFM88Bn5/jBB+f0nwE0WmCM++7LtPm9Febwi1I9PhoPy8e9Z4rjYaP7jGkxgtKDjCBdxemrC94oNfa3Kz8POvU83nWpjCjDTVmVi4YPq/vx+dmC42uGXUni0o4mkrUajXLr0I94/D3kRJOv4YSKVgFjcukOYCspKU/jAii+y1KW9HG5wWBLp6Z1O1zaF5S1nNzv+2lgwP1M4bpsVNcEY45i+Fpn8ODReML4MW3d6iibQ0lUHLhUPApeHxBpwluWlC/MNYlISm2Twom0+ijqFP86eLZtCR/zJgNEinJiKhvZB15Zf8uzysf7Gj4KfLqTLqCSJbe2m3JkS9ry2sera2sM3gZOtmvZVfUbUj/7iqdDCvXvbhCwbkQSGaDHIcFGl7wTMjBm0BF3w4qWtvioCMEQvQMeLlJubSxs5MDgZWhpBJcKezsv6usVUnGcoyepIgrDlnynr/pFBui/0yUZRpCyB4geRU+1Li8z+AdxczALXkZ8csPeUmSiDInRObiw5Rg5hWQ4DMPJR4FkqdY0pJFzsQhSRApUs+NkiX5KVN0BKl1g2ap/elIVhcZgkKSY2SdxVDhsbtSK+udK2sbXeO8vNibRASt1TBrKb3mpasNoeDFOHpMwFER8Cdc08csPtyhOAGBNU/J71jBTlLypRvKJCuUSSVQJmFvrVfI0QMWgMD64hdO81l8YKIcf341eI9V30r0aKnaltf2D4vEh0DvAMkkL8vP8DIquimzSh6076KYtq1Qqqlo8FcVVr1gjjJpkgY2Rec4RSx2aO3+HgziqhcpCNs9tvpk2i8iWQcbX6dBFKdBxE8HXDiMO+3ZebxGEELcHGwGLYMIksBCq5QmyUXVS277Zwe1bYjiZeVAoi+IWpiDXRmrTLakYuEwUfmxgYXrwyAAFlsXDCsL8GMDDU86AJ6vJ7Tx8JhmCUpCaLHIqQOch+1+qHTWwJoAPzaYoV8EQZLlRU/0bneOkIMpkiITCZokGJqsyr4zztEU+7+vomBdkgQ7X3Xw7lhHoLG3H67W4FQE8XEUaBmLzy9Sfi/8I4p1BiO3g9EyOLKkA2YoaWQohOnylqo8aIKbLeH903G0j39YZpnrkYaxkCzjgAcolAVxr21nZhKI9RGURhul51gSSC4Dkg8yFLmrbtlIr/qD3v/XIHxTSrk2RvlRYwSQbA+aYNX+WKb+4btKsGoqwaqpBKumEqyaSrBqKsGqqQSrBKumEqyaSrBqKsGqqQSrdlX2PwEGALRgVkJ3NbzRAAAAAElFTkSuQmCC
name: PassiveTotal v2
script:
  commands:
  - arguments:
    - description: Query value to use in your request.
      name: query
      required: true
    - auto: PREDEFINED
      description: 'WHOIS field to execute the search on: domain, email, name, organization,
        address, phone, nameserver.'
      name: field
      predefined:
      - domain
      - email
      - name
      - organization
      - address
      - phone
      - nameserver
      required: true
    description: Gets WHOIS information records based on field matching queries.
    name: pt-whois-search
    outputs:
    - contextPath: Domain.Name
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: Domain.WHOIS.CreationDate
      description: The date that the domain was created.
      type: Date
    - contextPath: Domain.WHOIS.UpdatedDate
      description: The date that the domain was last updated.
      type: Date
    - contextPath: Domain.WHOIS.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.WHOIS.NameServers
      description: Name servers of the domain.
      type: String
    - contextPath: Domain.Organization
      description: The organization of the domain.
      type: String
    - contextPath: Domain.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Registrar.Name
      description: 'The name of the registrar, for example: ''GoDaddy''.'
      type: String
    - contextPath: Domain.WHOIS.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.domain
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: PassiveTotal.WHOIS.registrar
      description: The name of the registrar of the domain
      type: String
    - contextPath: PassiveTotal.WHOIS.whoisServer
      description: WHOIS server name where the details of domain registrations belong
      type: String
    - contextPath: PassiveTotal.WHOIS.registered
      description: The date that the domain was registered.
      type: Date
    - contextPath: PassiveTotal.WHOIS.expiresAt
      description: The expiration date of the domain.
      type: Date
    - contextPath: PassiveTotal.WHOIS.registryUpdatedAt
      description: The date when registry was last updated.
      type: Date
    - contextPath: PassiveTotal.WHOIS.lastLoadedAt
      description: Last loaded date of WHOIS database.
      type: Date
    - contextPath: PassiveTotal.WHOIS.nameServers
      description: Name servers of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.organization
      description: The organization of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.name
      description: Name of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.telephone
      description: Telephone number fetched from whois details of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.contactEmail
      description: Contact Email address of the domain owner
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantEmail
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantFax
      description: The fax number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantName
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantOrganization
      description: The organizations of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantStreet
      description: The street of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCity
      description: The city of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantState
      description: The state of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantPostalCode
      description: The postal code of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCountry
      description: The country of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantTelephone
      description: The telephone number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminEmail
      description: The email address of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminFax
      description: The fax number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminName
      description: The name of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminOrganization
      description: The organizations of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminStreet
      description: The street of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCity
      description: The city of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminState
      description: The state of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminPostalCode
      description: The postal code of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCountry
      description: The country of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminTelephone
      description: The telephone number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingEmail
      description: The email address of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingFax
      description: The fax number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingName
      description: The name of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingOrganization
      description: The organizations of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingStreet
      description: The street of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCity
      description: The city of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingState
      description: The state of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingPostalCode
      description: The postal code of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCountry
      description: The country of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingTelephone
      description: The telephone number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.techEmail
      description: The email address of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techFax
      description: The fax number of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techName
      description: The name of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techOrganization
      description: The organizations of domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techStreet
      description: The street of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCity
      description: The city of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techState
      description: The state of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techPostalCode
      description: The postal code of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCountry
      description: The country of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techTelephone
      description: The telephone number of the domain tech.
      type: String
  - arguments:
    - description: 'Query value to use in the request. For example: riskiq.com, 1.1.1.1'
      name: query
      required: true
    - auto: PREDEFINED
      defaultValue: "false"
      description: |-
        Whether to return historical results.
        Valid values: true, false.
      name: history
      predefined:
      - "true"
      - "false"
    description: Gets WHOIS information records based on queries.
    name: pt-get-whois
    outputs:
    - contextPath: PassiveTotal.WHOIS.domain
      description: 'The domain name. For example: ''google.com''.'
      type: String
    - contextPath: PassiveTotal.WHOIS.registrar
      description: The name of the registrar of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.whoisServer
      description: WHOIS server name where the details of domain registrations belong.
      type: String
    - contextPath: PassiveTotal.WHOIS.registered
      description: The date that the domain was registered.
      type: Date
    - contextPath: PassiveTotal.WHOIS.expiresAt
      description: The expiration date of the domain.
      type: Date
    - contextPath: PassiveTotal.WHOIS.registryUpdatedAt
      description: The date when the registry was last updated.
      type: Date
    - contextPath: PassiveTotal.WHOIS.lastLoadedAt
      description: Last loaded date of WHOIS database.
      type: Date
    - contextPath: PassiveTotal.WHOIS.nameServers
      description: Name servers of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.organization
      description: The organization of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.name
      description: Name of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.telephone
      description: Telephone number fetched from whois details of the domain.
      type: String
    - contextPath: PassiveTotal.WHOIS.contactEmail
      description: Contact Email address of the domain owner.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantEmail
      description: The email address of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantFax
      description: The fax number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantName
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantOrganization
      description: The organizations of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantStreet
      description: The street of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCity
      description: The city of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantState
      description: The state of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantPostalCode
      description: The postal code of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantCountry
      description: The country of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.registrantTelephone
      description: The telephone number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminEmail
      description: The email address of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminFax
      description: The fax number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminName
      description: The name of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminOrganization
      description: The organizations of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminStreet
      description: The street of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCity
      description: The city of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminState
      description: The state of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminPostalCode
      description: The postal code of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminCountry
      description: The country of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.adminTelephone
      description: The telephone number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingEmail
      description: The email address of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingFax
      description: The fax number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingName
      description: The name of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingOrganization
      description: The organizations of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingStreet
      description: The street of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCity
      description: The city of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingState
      description: The state of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingPostalCode
      description: The postal code of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingCountry
      description: The country of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.billingTelephone
      description: The telephone number of the domain billing.
      type: String
    - contextPath: PassiveTotal.WHOIS.techEmail
      description: The email address of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techFax
      description: The fax number of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techName
      description: The name of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techOrganization
      description: The organizations of domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techStreet
      description: The street of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCity
      description: The city of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techState
      description: The state of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techPostalCode
      description: The postal code of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techCountry
      description: The country of the domain tech.
      type: String
    - contextPath: PassiveTotal.WHOIS.techTelephone
      description: The telephone number of the domain tech.
      type: String
  - arguments:
    - default: true
      description: Domain or IP address you want to search components for.
      name: query
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the host attribute components for a domain or IP address.
      Maximum 2000 records are fetched.
    name: pt-get-components
    outputs:
    - contextPath: Domain.Name
      description: 'The domain name, for example: "google.com".'
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: IP.Address
      description: The IP Address of the component.
      type: String
    - contextPath: PassiveTotal.Component.firstSeen
      description: The date and time when the component was first observed.
      type: Date
    - contextPath: PassiveTotal.Component.lastSeen
      description: The date and time when the component was most recently observed.
      type: Date
    - contextPath: PassiveTotal.Component.version
      description: The current version of component.
      type: String
    - contextPath: PassiveTotal.Component.category
      description: The category under which the component falls.
      type: String
    - contextPath: PassiveTotal.Component.label
      description: The value of the component.
      type: String
    - contextPath: PassiveTotal.Component.hostname
      description: The hostname of the component.
      type: String
    - contextPath: PassiveTotal.Component.address
      description: The IP address of the component.
      type: String
  - arguments:
    - default: true
      description: Domain or IP address you want to search trackers for.
      name: query
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the host attribute trackers for a domain or IP address.
      Maximum 2000 records are fetched.
    name: pt-get-trackers
    outputs:
    - contextPath: Domain.Name
      description: 'The domain name, for example: "google.com".'
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: IP.Address
      description: The IP Address of the component.
      type: String
    - contextPath: PassiveTotal.Tracker.firstSeen
      description: The date and time when the tracker was first observed.
      type: Date
    - contextPath: PassiveTotal.Tracker.lastSeen
      description: The date and time when the tracker was most recently observed.
      type: Date
    - contextPath: PassiveTotal.Tracker.attributeValue
      description: The value of the tracker.
      type: String
    - contextPath: PassiveTotal.Tracker.attributeType
      description: The type under which the tracker falls.
      type: String
    - contextPath: PassiveTotal.Tracker.hostname
      description: The hostname of the tracker.
      type: String
    - contextPath: PassiveTotal.Tracker.address
      description: The IP address of the tracker.
      type: String
  - arguments:
    - default: true
      description: The domain or IP being queried.
      name: query
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the passive DNS results from active account sources.
    name: pt-get-pdns-details
    outputs:
    - contextPath: PassiveTotal.PDNS.resolve
      description: The host or ip address that indicates resolve in Passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.resolveType
      description: The type of the resolve. I.e domain, ip, host, etc.
      type: String
    - contextPath: PassiveTotal.PDNS.value
      description: The value of the Passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.source
      description: Source of the passive DNS records.
      type: String
    - contextPath: PassiveTotal.PDNS.firstSeen
      description: First seen timestamp of the passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.lastSeen
      description: Last seen timestamp of the passive DNS record.
      type: String
    - contextPath: PassiveTotal.PDNS.collected
      description: The date when a passive DNS record is collected.
      type: String
    - contextPath: PassiveTotal.PDNS.recordType
      description: The type of the passive DNS record. I.e CNAME, SOA, A, etc
      type: String
    - contextPath: PassiveTotal.PDNS.recordHash
      description: The hash value of the passive DNS record.
      type: String
    - contextPath: Domain.Name
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: IP.Address
      description: The IP Address of the component.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
  - arguments:
    - auto: PREDEFINED
      description: "Field by which to search. \n\nAllowed values: issuerSurname, subjectOrganizationName,
        issuerCountry, issuerOrganizationUnitName, fingerprint, subjectOrganizationUnitName,
        serialNumber, subjectEmailAddress, subjectCountry, issuerGivenName, subjectCommonName,
        issuerCommonName, issuerStateOrProvinceName, issuerProvince, subjectStateOrProvinceName,
        sha1, subjectStreetAddress, subjectSerialNumber, issuerOrganizationName, subjectSurname,
        subjectLocalityName, issuerStreetAddress, issuerLocalityName, subjectGivenName,
        subjectProvince, issuerSerialNumber, issuerEmailAddress"
      name: field
      predefined:
      - issuerSurname
      - subjectOrganizationName
      - issuerCountry
      - issuerOrganizationUnitName
      - fingerprint
      - subjectOrganizationUnitName
      - serialNumber
      - subjectEmailAddress
      - subjectCountry
      - issuerGivenName
      - subjectCommonName
      - issuerCommonName
      - issuerStateOrProvinceName
      - issuerProvince
      - subjectStateOrProvinceName
      - sha1
      - subjectStreetAddress
      - subjectSerialNumber
      - issuerOrganizationName
      - subjectSurname
      - subjectLocalityName
      - issuerStreetAddress
      - issuerLocalityName
      - subjectGivenName
      - subjectProvince
      - issuerSerialNumber
      - issuerEmailAddress
      required: true
    - description: Field value for which to search.
      name: query
      required: true
    description: Retrieves SSL certificates for a given field value.
    name: pt-ssl-cert-search
    outputs:
    - contextPath: PassiveTotal.SSL.firstSeen
      description: Epoch timestamp when SSL certificate identified by the system.
      type: Number
    - contextPath: PassiveTotal.SSL.lastSeen
      description: The last seen epoch timestamp of the SSL certificates.
      type: Number
    - contextPath: PassiveTotal.SSL.fingerprint
      description: 'A fingerprint detail from the SSL certificates. '
      type: String
    - contextPath: PassiveTotal.SSL.sslVersion
      description: A version of the certificate.
      type: Number
    - contextPath: PassiveTotal.SSL.expirationDate
      description: The expiry date of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.issueDate
      description: Issue date of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.sha1
      description: Sha1 of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.serialNumber
      description: A serial number of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.issuerCountry
      description: The country name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerStateOrProvinceName
      description: The state or province name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerCommonName
      description: The common name of the issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerEmailAddress
      description: A contact email address of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerProvince
      description: A province of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerOrganizationUnitName
      description: An organization unit name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerSurname
      description: The surname of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerStreetAddress
      description: Street address of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerLocalityName
      description: The locality of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerSerialNumber
      description: The serial number of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerOrganizationName
      description: An organization name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.issuerGivenName
      description: A given name of the certificate issuer.
      type: String
    - contextPath: PassiveTotal.SSL.subjectCommonName
      description: The common name of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectOrganizationName
      description: An organization name of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectOrganizationUnitName
      description: An organization unit name of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectGivenName
      description: The given name of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectSurname
      description: The surname of the subject of the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectLocalityName
      description: The locality of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectEmailAddress
      description: A contact email address of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectProvince
      description: The province of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectStateOrProvinceName
      description: The state or province name of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectSerialNumber
      description: A serial number of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectStreetAddress
      description: The street address of the subject.
      type: String
    - contextPath: PassiveTotal.SSL.subjectCountry
      description: The country name of the subject from the certificate.
      type: String
    - contextPath: PassiveTotal.SSL.subjectAlternativeNames
      description: Alternative names of the subject from the certificate details.
      type: String
  - arguments:
    - description: Domain or IP address you want to search host-pairs for.
      name: query
      required: true
    - auto: PREDEFINED
      description: 'The direction of searching pair records for a given domain. Valid
        values: children, parents.'
      name: direction
      predefined:
      - children
      - parents
      required: true
    - description: Filter for records whose last seen is after this datetime. It accepts
        "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: start
    - description: Filter for records whose first seen is before this datetime. It
        accepts "yyyy-mm-dd hh:mm:ss" or "yyyy-mm-dd" format.
      name: end
    description: Retrieves the host attribute pairs related to a domain or IP address.
      Maximum 2000 records are fetched.
    name: pt-get-host-pairs
    outputs:
    - contextPath: PassiveTotal.HostPair.firstSeen
      description: The date and time when the host pair was first observed.
      type: Date
    - contextPath: PassiveTotal.HostPair.lastSeen
      description: The date and time when the host pair was most recently observed.
      type: Date
    - contextPath: PassiveTotal.HostPair.cause
      description: The cause of relation between parent and child.
      type: String
    - contextPath: PassiveTotal.HostPair.parent
      description: The hostname of the parent of the host pair.
      type: String
    - contextPath: PassiveTotal.HostPair.child
      description: The hostname of the child of the host pair.
      type: String
  - arguments:
    - default: true
      description: The domain to enrich.
      isArray: true
      name: domain
    description: Provides data enrichment for domains.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: Unknown
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: Unknown
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the DBot score.
      type: Unknown
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: Domain.Name
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: Domain.WHOIS.CreationDate
      description: The date that the domain was created.
      type: Date
    - contextPath: Domain.WHOIS.UpdatedDate
      description: The date that the domain was last updated.
      type: Date
    - contextPath: Domain.WHOIS.ExpirationDate
      description: The expiration date of the domain.
      type: Date
    - contextPath: Domain.WHOIS.NameServers
      description: Name servers of the domain.
      type: String
    - contextPath: Domain.Organization
      description: The organization of the domain.
      type: String
    - contextPath: Domain.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Admin.Email
      description: The email address of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Name
      description: The name of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Phone
      description: The phone number of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Admin.Country
      description: The country of the domain administrator.
      type: String
    - contextPath: Domain.WHOIS.Registrar.Name
      description: 'The name of the registrar, for example: ''GoDaddy''.'
      type: String
    - contextPath: Domain.WHOIS.Registrant.Email
      description: The email address of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Name
      description: The name of the registrant.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Phone
      description: The phone number for receiving abuse reports.
      type: String
    - contextPath: Domain.WHOIS.Registrant.Country
      description: The country of the registrant.
      type: String
    - contextPath: PassiveTotal.Domain.domain
      description: 'The domain name, for example: ''google.com''.'
      type: String
    - contextPath: PassiveTotal.Domain.registrar
      description: The name of the registrar of the domain
      type: String
    - contextPath: PassiveTotal.Domain.whoisServer
      description: WHOIS server name where the details of domain registrations belong
      type: String
    - contextPath: PassiveTotal.Domain.registered
      description: The date that the domain was registered.
      type: Date
    - contextPath: PassiveTotal.Domain.expiresAt
      description: The expiration date of the domain.
      type: Date
    - contextPath: PassiveTotal.Domain.registryUpdatedAt
      description: The date when registry was last updated.
      type: Date
    - contextPath: PassiveTotal.Domain.lastLoadedAt
      description: Last loaded date of WHOIS database.
      type: Date
    - contextPath: PassiveTotal.Domain.nameServers
      description: Name servers of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.organization
      description: The organization of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.name
      description: Name of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.telephone
      description: Telephone number fetched from whois details of the domain.
      type: String
    - contextPath: PassiveTotal.Domain.contactEmail
      description: Contact Email address of the domain owner
      type: String
    - contextPath: PassiveTotal.Domain.registrantEmail
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantFax
      description: The fax number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantName
      description: The name of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantOrganization
      description: The organizations of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantStreet
      description: The street of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantCity
      description: The city of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantState
      description: The state of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantPostalCode
      description: The postal code of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantCountry
      description: The country of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.registrantTelephone
      description: The telephone number of the domain registrant.
      type: String
    - contextPath: PassiveTotal.Domain.adminEmail
      description: The email address of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminFax
      description: The fax number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminName
      description: The name of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminOrganization
      description: The organizations of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminStreet
      description: The street of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminCity
      description: The city of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminState
      description: The state of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminPostalCode
      description: The postal code of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminCountry
      description: The country of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.adminTelephone
      description: The telephone number of the domain administrator.
      type: String
    - contextPath: PassiveTotal.Domain.billingEmail
      description: The email address of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingFax
      description: The fax number of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingName
      description: The name of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingOrganization
      description: The organizations of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingStreet
      description: The street of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingCity
      description: The city of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingState
      description: The state of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingPostalCode
      description: The postal code of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingCountry
      description: The country of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.billingTelephone
      description: The telephone number of the domain billing.
      type: String
    - contextPath: PassiveTotal.Domain.techEmail
      description: The email address of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techFax
      description: The fax number of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techName
      description: The name of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techOrganization
      description: The organizations of domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techStreet
      description: The street of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techCity
      description: The city of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techState
      description: The state of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techPostalCode
      description: The postal code of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techCountry
      description: The country of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.techTelephone
      description: The telephone number of the domain tech.
      type: String
    - contextPath: PassiveTotal.Domain.score
      description: Reputation score of the indicator.
      type: Number
    - contextPath: PassiveTotal.Domain.classification
      description: Reputation classification of the indicator. (Can be GOOD, SUSPICIOUS,
        MALICIOUS, or UNKNOWN)
      type: String
    - contextPath: PassiveTotal.Domain.rules.name
      description: Name of the rule that informed the reputation score of the indicator.
      type: String
    - contextPath: PassiveTotal.Domain.rules.description
      description: Description of the rule.
      type: String
    - contextPath: PassiveTotal.Domain.rules.severity
      description: Severity of the rule.
      type: Number
    - contextPath: PassiveTotal.Domain.rules.link
      description: Link to the rule.
      type: String
  - arguments:
    - description: 'Indicator value to search for in articles. For example: riskiq.com,
        1.1.1.1'
      name: query
      required: true
    - description: 'Type of the indicator. For example: domain, ip, url'
      name: type
    description: Retrieves information related to articles for a specific indicator.
    name: pt-get-articles
    outputs:
    - contextPath: PassiveTotal.Article.guid
      description: The global unique ID of the article.
      type: String
    - contextPath: PassiveTotal.Article.title
      description: The title of the article.
      type: String
    - contextPath: PassiveTotal.Article.summary
      description: The summary of the article.
      type: String
    - contextPath: PassiveTotal.Article.type
      description: The type of an article.
      type: String
    - contextPath: PassiveTotal.Article.publishedDate
      description: The date and time on which the article was published.
      type: Date
    - contextPath: PassiveTotal.Article.link
      description: The link of the article for getting more details.
      type: String
    - contextPath: PassiveTotal.Article.categories
      description: An array of categories of the article.
      type: Unknown
    - contextPath: PassiveTotal.Article.tags
      description: An array of tags for the article.
      type: Unknown
    - contextPath: PassiveTotal.Article.indicators.type
      description: The type of the indicator.
      type: String
    - contextPath: PassiveTotal.Article.indicators.count
      description: Total number of indicators of a particular type.
      type: Number
    - contextPath: PassiveTotal.Article.indicators.values
      description: An array of values related to indicators.
      type: Unknown
    - contextPath: PassiveTotal.Article.indicators.source
      description: The source of the indicator.
      type: String
  - arguments:
    - default: true
      description: IP address for which the user wants to search services for.
      name: ip
      required: true
    description: Retrieves exposed services on the recently open ports for an IP address.
    name: pt-get-services
    outputs:
    - contextPath: PassiveTotal.Service.ip
      description: IP address of the service.
      type: String
    - contextPath: PassiveTotal.Service.portNumber
      description: Port number on which recent services were running or current services
        are running.
      type: Number
    - contextPath: PassiveTotal.Service.firstSeen
      description: The date and time when the service was started for the first time
        on the port.
      type: Date
    - contextPath: PassiveTotal.Service.lastSeen
      description: The date and time when the service was most recently used on the
        port.
      type: Date
    - contextPath: PassiveTotal.Service.lastScan
      description: The date and time when the system performed the last scan to check
        whether any service is running on the port or not.
      type: Date
    - contextPath: PassiveTotal.Service.count
      description: The total number of times service was used on the port.
      type: Number
    - contextPath: PassiveTotal.Service.status
      description: The status of the service.
      type: String
    - contextPath: PassiveTotal.Service.protocol
      description: The protocol used by the service.
      type: String
    - contextPath: PassiveTotal.Service.banners.banner
      description: The description of the banner generated as a result of scanning.
        Can be in HTML format.
      type: String
    - contextPath: PassiveTotal.Service.banners.scanType
      description: The type of scan when the banner was generated.
      type: String
    - contextPath: PassiveTotal.Service.banners.firstSeen
      description: The date and time when the scan started.
      type: Date
    - contextPath: PassiveTotal.Service.banners.lastSeen
      description: The date and time when the scan ended.
      type: Date
    - contextPath: PassiveTotal.Service.banners.count
      description: The total number of times the same label was generated while scanning.
      type: Number
    - contextPath: PassiveTotal.Service.currentServices.firstSeen
      description: The date and time when the current service started.
      type: Date
    - contextPath: PassiveTotal.Service.currentServices.lastSeen
      description: The date and time when the current service was most recently used.
      type: Date
    - contextPath: PassiveTotal.Service.currentServices.version
      description: The version of the current service.
      type: String
    - contextPath: PassiveTotal.Service.currentServices.category
      description: The category of the current service.
      type: String
    - contextPath: PassiveTotal.Service.currentServices.label
      description: The label of the current service.
      type: String
    - contextPath: PassiveTotal.Service.recentServices.firstSeen
      description: The date and time when the recent service started.
      type: Date
    - contextPath: PassiveTotal.Service.recentServices.lastSeen
      description: The date and time when the recent service was most recently used.
      type: Date
    - contextPath: PassiveTotal.Service.recentServices.version
      description: The version of the recent service.
      type: String
    - contextPath: PassiveTotal.Service.recentServices.category
      description: The category of the recent service.
      type: String
    - contextPath: PassiveTotal.Service.recentServices.label
      description: The label of the recent service.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.firstSeen
      description: The timestamp in epoch when the most recent SSL certificate was
        identified by the system.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.lastSeen
      description: The timestamp in epoch when the most recent SSL certificate was
        last used.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.fingerprint
      description: A fingerprint detail from the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.sslVersion
      description: The version of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.expirationDate
      description: The expiry date and time  of the most recent SSL certificate in
        GMT.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issueDate
      description: The date and time in GMT when the most recent SSL certificate was
        issued.
      type: Date
    - contextPath: PassiveTotal.Service.mostRecentSslCert.sha1
      description: Sha1 of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.serialNumber
      description: The serial Number of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectCountry
      description: The name of the Country of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerCommonName
      description: The common name of the issuer of most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerProvince
      description: The province of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectStateOrProvinceName
      description: The state or province name of the subject of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectStreetAddress
      description: The street address of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerStateOrProvinceName
      description: The state or province name of the issuer of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectSurname
      description: The surname of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerCountry
      description: The country of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectLocalityName
      description: The subject locality name of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectAlternativeNames
      description: List of alternative names of the subject of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerOrganizationUnitName
      description: The name organization unit of the issuer of the most recent SSL
        certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerOrganizationName
      description: The  organization name of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectEmailAddress
      description: Email Address of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectOrganizationName
      description: The organization name of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerLocalityName
      description: The name of the locality of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectCommonName
      description: Common name of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectProvince
      description: The province of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerGivenName
      description: The given name of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectOrganizationUnitName
      description: Subject organization unit name of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerEmailAddress
      description: The email address of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectGivenName
      description: Given name of the subject of the the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.subjectSerialNumber
      description: The serial number of the subject of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerStreetAddress
      description: The street Address of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerSerialNumber
      description: The serial number of the issuer of the most recent SSL certificate.
      type: String
    - contextPath: PassiveTotal.Service.mostRecentSslCert.issuerSurname
      description: The surname of the issuer of the most recent SSL certificate.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: |-
        Search cookies information by name or domain.
        Valid values:
        1. get addresses by cookie domain
        2. get addresses by cookie name
        3. get hosts by cookie domain
        4. get hosts by cookie name
      name: search_by
      predefined:
      - get addresses by cookie domain
      - get addresses by cookie name
      - get hosts by cookie domain
      - get hosts by cookie name
      required: true
    - description: Name or domain of cookie the user wants to search for.
      name: query
      required: true
    - defaultValue: "0"
      description: Page number for paging through results. Each page contains 2000
        values.
      name: page
    - auto: PREDEFINED
      defaultValue: last seen
      description: 'Field to sort the results on. Valid values: last seen, first seen.'
      name: sort
      predefined:
      - last seen
      - first seen
    - auto: PREDEFINED
      defaultValue: desc
      description: 'Order to return the results in. Valid values: asc, desc'
      name: order
      predefined:
      - desc
      - asc
    description: Retrieves cookies addresses or hostname information based on cookie
      name or domain.
    name: pt-get-cookies
    outputs:
    - contextPath: PassiveTotal.Cookie.hostname
      description: The hostname/IP of the machine on which the cookie was found.
      type: String
    - contextPath: PassiveTotal.Cookie.cookieName
      description: The name of the cookie that was found on the host.
      type: String
    - contextPath: PassiveTotal.Cookie.cookieDomain
      description: The domain from which the cookie originated from.
      type: String
    - contextPath: PassiveTotal.Cookie.firstSeen
      description: The date and time when the cookie was first observed.
      type: Date
    - contextPath: PassiveTotal.Cookie.lastSeen
      description: The date and time when the cookie was most recently observed.
      type: Date
  - arguments:
    - description: 'The domain, host or IP address to be queried. For example: riskiq.com,
        1.1.1.1'
      name: query
      required: true
    description: Retrieves a summary data card associated with the given query.
    name: pt-get-data-card
    outputs:
    - contextPath: PassiveTotal.DataCard.type
      description: Type of the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.name
      description: Name of the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.link
      description: Link to the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.netblock
      description: Netblock associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.os
      description: Operating system associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.organization
      description: The organization of the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.asn
      description: Autonomous system number assigned to the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.hosting_provider
      description: Host provider of the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.resolutions.count
      description: Number of resolutions attached to the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.resolutions.link
      description: Link of the resolutions attached to the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.services.count
      description: Number of service records for the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.services.link
      description: Link to the service records of the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.certificates.count
      description: Number of certificates for the given indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.certificates.link
      description: Link to the certificates associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.hashes.count
      description: Number of hashes associated with the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.hashes.link
      description: Link to the hashes associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.projects.count
      description: Number of projects containing the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.projects.link
      description: Number of projects containing the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.articles.count
      description: Number of articles referencing the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.articles.link
      description: Link to the articles referencing the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.trackers.count
      description: Number of trackers associated with the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.trackers.link
      description: Link to the trackers associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.components.count
      description: Number of components associated with the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.components.link
      description: Link to the components associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.host_pairs.count
      description: Number of host pairs associated with the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.host_pairs.link
      description: Link to the host pairs associated with the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.reverse_dns.count
      description: Number of DNS records for the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.reverse_dns.link
      description: Link to the DNS records of the indicator.
      type: String
    - contextPath: PassiveTotal.DataCard.data_summary.cookies.count
      description: Number of available cookie records for the indicator.
      type: Number
    - contextPath: PassiveTotal.DataCard.data_summary.cookies.link
      description: Link to the cookie records for the indicator.
      type: String
  - arguments:
    - description: 'The domain, host or IP address to be queried. For example: riskiq.com,
        1.1.1.1'
      name: query
      required: true
    description: Gets reputation for a given domain, host or IP.
    name: pt-get-reputation
    outputs:
    - contextPath: PassiveTotal.Reputation.query
      description: The value of the indicator.
      type: String
    - contextPath: PassiveTotal.Reputation.score
      description: Reputation score of the indicator.
      type: Number
    - contextPath: PassiveTotal.Reputation.classification
      description: Reputation classification of the indicator. (Can be GOOD, SUSPICIOUS,
        MALICIOUS, or UNKNOWN)
      type: String
    - contextPath: PassiveTotal.Reputation.rules.name
      description: Name of the rule that informed the reputation score of the indicator.
      type: String
    - contextPath: PassiveTotal.Reputation.rules.description
      description: Description of the rule.
      type: String
    - contextPath: PassiveTotal.Reputation.rules.severity
      description: Severity of the rule.
      type: Number
    - contextPath: PassiveTotal.Reputation.rules.link
      description: Link to the rule.
      type: String
  - arguments:
    - default: true
      description: The IP address to check.
      isArray: true
      name: ip
    description: Checks the reputation of an IP address.
    name: ip
    outputs:
    - contextPath: PassiveTotal.IP.query
      description: The value of the indicator.
      type: String
    - contextPath: PassiveTotal.IP.score
      description: Reputation score of the indicator.
      type: Number
    - contextPath: PassiveTotal.IP.classification
      description: Reputation classification of the indicator. (Can be GOOD, SUSPICIOUS,
        MALICIOUS, or UNKNOWN)
      type: String
    - contextPath: PassiveTotal.IP.rules.name
      description: Name of the rule that informed the reputation score of the indicator.
      type: String
    - contextPath: PassiveTotal.IP.rules.description
      description: Description of the rule.
      type: String
    - contextPath: PassiveTotal.IP.rules.severity
      description: Severity of the rule.
      type: Number
    - contextPath: PassiveTotal.IP.rules.link
      description: Link to the rule.
      type: String
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Score
      description: The reputation score.
      type: Number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: IP.Address
      description: The IP Address.
      type: String
  - arguments:
    - description: |-
        Specify the ID of the profile to retrieve the specific profile.

        Note: If 'id' argument is provided, all other arguments will be neglected.
      name: id
    - description: 'Filter the result based on title or aliases. '
      name: query
    - auto: PREDEFINED
      description: "Filter the results based on the profile type. \n\nPossible values:
        actor, tool, backdoor."
      name: type
      predefined:
      - actor
      - tool
      - backdoor
    - description: "Specify the indicator value to retrieve the profiles containing
        the given indicator.\n\nNote: To retrieve the list of indicators, execute
        the \"pt-list-intel-profile-indicators\" command. \nWhen both indicator_value
        and query are provided, higher priority will be given to indicator_value."
      name: indicator_value
    - auto: PREDEFINED
      description: "Filter the result based on the indicator source. \n\nPossible
        values: osint, riskiq.\n\nNote: Requires 'indicator_value' argument."
      name: source
      predefined:
      - osint
      - riskiq
    - auto: PREDEFINED
      description: "Filter the result based on the indicator category. \n\nPossible
        values: host, network.\n\nNote: Requires 'indicator_value' argument."
      name: category
      predefined:
      - host
      - network
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is 1000.
      name: page_size
    description: Retrieves the list of all profiles.
    name: pt-list-intel-profiles
    outputs:
    - contextPath: PassiveTotal.IntelProfile.id
      description: ID of the intel profile.
      type: String
    - contextPath: PassiveTotal.IntelProfile.title
      description: Title of the intel profile.
      type: String
    - contextPath: PassiveTotal.IntelProfile.link
      description: Link to the intel profile.
      type: String
    - contextPath: PassiveTotal.IntelProfile.osintIndicatorsCount
      description: Count of the open source intelligence indicators referencing the
        intel profile.
      type: Number
    - contextPath: PassiveTotal.IntelProfile.riskIqIndicatorsCount
      description: Count of the riskiq indicators referencing the intel profile.
      type: Number
    - contextPath: PassiveTotal.IntelProfile.indicators
      description: Link to the indicators referencing the intel profile.
      type: String
    - contextPath: PassiveTotal.IntelProfile.aliases
      description: Aliases of the intel profile.
      type: String
    - contextPath: PassiveTotal.IntelProfile.tags.label
      description: Labels associated with the intel profile.
      type: String
    - contextPath: PassiveTotal.IntelProfile.tags.countryCode
      description: Country code of the tags associated with the intel profile.
      type: String
  - arguments:
    - description: |-
        Specify the ID of the profile to retrieve indicators for the specific profile.

        Note: To retrieve the list of profile IDs, execute the "pt-list-intel-profile" command.
      name: id
      required: true
    - auto: PREDEFINED
      description: "Filter the results based on the indicator type. \n\nPossible values:
        certificate_sha1, domain, email, hash_md5, hash_sha256, ip, pdb_path, soa_email,
        url, whois_email."
      name: type
      predefined:
      - certificate_sha1
      - domain
      - email
      - hash_md5
      - hash_sha256
      - ip
      - pdb_path
      - soa_email
      - url
      - whois_email
    - description: Specify the indicator value to retrieve the specific indicator.
      name: indicator_value
    - auto: PREDEFINED
      description: "Filter the result based on the indicator source. \n\nPossible
        values: osint, riskiq."
      name: source
      predefined:
      - osint
      - riskiq
    - auto: PREDEFINED
      description: "Filter the result based on the indicator category. \n\nPossible
        values: host, network."
      name: category
      predefined:
      - host
      - network
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the indicators for the given profile.
    name: pt-list-intel-profile-indicators
    outputs:
    - contextPath: PassiveTotal.IntelProfile.id
      description: Profile ID containing the indicator.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.id
      description: ID of the indicator.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.type
      description: Type of the indicator.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.value
      description: Value of the indicator.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.category
      description: Category of the indicator.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.firstSeen
      description: Date & time the record was first seen.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.lastSeen
      description: Date & time the record was most recently observed.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.osint
      description: Whether the indicator was published in open source intelligence
        articles.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.osintUrl
      description: Link to the osint source of the indicator.
      type: String
    - contextPath: PassiveTotal.IntelProfile.indicator.articleGuids
      description: List of RiskIQ OSINT article GUIDs associated with the indicator.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: |-
        Filter the results based on the priority level specified.

        Possible values: high, medium, low.
      name: priority
      predefined:
      - high
      - medium
      - low
      required: true
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is 1000.
      name: page_size
    description: Retrieves the attack surface insight  information of the individual's
      account.
    name: pt-list-my-attack-surface-insights
    outputs:
    - contextPath: PassiveTotal.Summary.Insight.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.Insight.activeInsightCount
      description: Total number of active insights.
      type: Number
    - contextPath: PassiveTotal.Summary.Insight.totalInsightCount
      description: Total number of insights.
      type: Number
    - contextPath: PassiveTotal.Summary.Insight.totalObservations
      description: Total number of observations.
      type: Number
    - contextPath: PassiveTotal.Insight.priorityLevel
      description: Priority level of insights.
      type: String
    - contextPath: PassiveTotal.Insight.insight.name
      description: Name of the insight.
      type: String
    - contextPath: PassiveTotal.Insight.insight.description
      description: Description of the insight.
      type: String
    - contextPath: PassiveTotal.Insight.insight.observationCount
      description: Number of observations for the given insight.
      type: Number
    - contextPath: PassiveTotal.Insight.insight.link
      description: Link to the insight.
      type: String
    - contextPath: PassiveTotal.Insight.insight.insightId
      description: ID of the third party insight.
      type: String
    - contextPath: PassiveTotal.Insight.insight.segmentBy
      description: Segment by of the insight.
      type: String
  - arguments:
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is 1000.
      name: page_size
    description: Retrieves the attack surface information of the individual's account.
    name: pt-list-my-attack-surfaces
    outputs:
    - contextPath: PassiveTotal.AttackSurface.id
      description: ID of the attack surface.
      type: Number
    - contextPath: PassiveTotal.AttackSurface.name
      description: Name of the attack surface.
      type: String
    - contextPath: PassiveTotal.AttackSurface.priority.high.observationCount
      description: Total observations of high priority attack surface.
      type: Number
    - contextPath: PassiveTotal.AttackSurface.priority.high.link
      description: Link to the high priority attack surface.
      type: String
    - contextPath: PassiveTotal.AttackSurface.priority.medium.observationCount
      description: Total observations of medium priority attack surface.
      type: Number
    - contextPath: PassiveTotal.AttackSurface.priority.medium.link
      description: Link to the medium priority attack surface.
      type: String
    - contextPath: PassiveTotal.AttackSurface.priority.low.observationCount
      description: Total observations of low priority attack surface.
      type: Number
    - contextPath: PassiveTotal.AttackSurface.priority.low.link
      description: Link to the low priority attack surface.
      type: String
  - arguments:
    - description: Specify the vendor ID to retrieve the attack surface third party
        information.
      name: id
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface observations by severity level for the
      given third-party account.
    name: pt-list-third-party-attack-surface
    outputs:
    - contextPath: PassiveTotal.ThirdParty.id
      description: ID of the vendor.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.name
      description: Name of the vendor.
      type: String
    - contextPath: PassiveTotal.ThirdParty.priority.high.observationCount
      description: Total observations of high priority attack surface.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.priority.high.link
      description: Link to the high priority attack surface.
      type: String
    - contextPath: PassiveTotal.ThirdParty.priority.medium.observationCount
      description: Total observations of medium priority attack surface.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.priority.medium.link
      description: Link to the medium priority attack surface.
      type: String
    - contextPath: PassiveTotal.ThirdParty.priority.low.observationCount
      description: Total observations of low priority attack surface.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.priority.low.link
      description: Link to the low priority attack surface.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyASI.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyASI.totalCount
      description: Total number of attack surfaces.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyASI.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyASI.nextPage
      description: Link to the next page.
      type: String
  - arguments:
    - description: |-
        Specify the vendor ID to retrieve the third-party insights information.

        Note: To retrieve the list of vendor IDs, execute the "pt-list-third-party-attack-surface" command.
      name: id
      required: true
    - auto: PREDEFINED
      description: |-
        Filter the results based on the priority level specified.

        Possible values: high, medium, low.
      name: priority
      predefined:
      - high
      - medium
      - low
      required: true
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is 1000.
      name: page_size
    description: Retrieves the attack surface insight information of the given third-party
      account.
    name: pt-list-third-party-attack-surface-insights
    outputs:
    - contextPath: PassiveTotal.Summary.ThirdPartyInsight.activeInsightCount
      description: Total number of active third party insights.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyInsight.totalInsightCount
      description: Total number of third party insights.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyInsight.totalObservations
      description: Total number of third party observations.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.id
      description: Vendor ID associated with the third party insights.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.priorityLevel
      description: Priority level of third party insights.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Insight.insight.name
      description: Name of the third party insight.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Insight.insight.description
      description: Description of the third party insight.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Insight.insight.observationCount
      description: Number of observations for the given third party insight.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.Insight.insight.link
      description: Link to the third party insight.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Insight.insight.insightId
      description: ID of the third party insight.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Insight.insight.segmentBy
      description: Segment by of the third party insight.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyInsight.name
      description: The command name.
      type: String
  - arguments:
    - description: |-
        Specify the insight ID to retrieve the assets.

        Note: To retrieve the list of insight IDs, execute the "pt-list-my-attack-surface-insights" command.
      name: id
      required: true
    - description: |-
        Specify the segment_by to retrieve the assets.

        Note: To retrieve the list of segment by, execute the "pt-list-my-attack-surface-insights" command.
      name: segment_by
      required: true
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface asset information of the individual's
      account.
    name: pt-list-my-attack-surface-assets
    outputs:
    - contextPath: PassiveTotal.Summary.Asset.totalCount
      description: Total number of available assets.
      type: Number
    - contextPath: PassiveTotal.Summary.Asset.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.Asset.nextPage
      description: Link to the next page.
      type: String
    - contextPath: PassiveTotal.Asset.insightId
      description: Insight ID for which assets are retrieved.
      type: String
    - contextPath: PassiveTotal.Asset.segmentBy
      description: Segment by for which assets are retrieved.
      type: String
    - contextPath: PassiveTotal.Asset.asset.type
      description: Type of the asset.
      type: String
    - contextPath: PassiveTotal.Asset.asset.name
      description: Name of the asset.
      type: String
    - contextPath: PassiveTotal.Asset.asset.firstSeen
      description: Date & time the record was first seen.
      type: Date
    - contextPath: PassiveTotal.Asset.asset.lastSeen
      description: Date & time the record was most recently observed.
      type: Date
    - contextPath: PassiveTotal.Summary.Asset.name
      description: The command name.
      type: String
  - arguments:
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface vulnerable component information of
      the individual's account.
    name: pt-list-my-attack-surface-vulnerable-components
    outputs:
    - contextPath: PassiveTotal.Summary.VulnerableComponent.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.VulnerableComponent.totalCount
      description: Total number of available vulnerable components.
      type: Number
    - contextPath: PassiveTotal.Summary.VulnerableComponent.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.VulnerableComponent.nextPage
      description: Link to the next page.
      type: String
    - contextPath: PassiveTotal.VulnerableComponent.name
      description: Name of the vulnerable component.
      type: String
    - contextPath: PassiveTotal.VulnerableComponent.type
      description: Type of the vulnerable component.
      type: String
    - contextPath: PassiveTotal.VulnerableComponent.severity
      description: Severity of the vulnerable component.
      type: String
    - contextPath: PassiveTotal.VulnerableComponent.count
      description: Number of assets affected.
      type: Number
  - arguments:
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface vulnerability information of the individual's
      account.
    name: pt-list-my-attack-surface-vulnerabilities
    outputs:
    - contextPath: PassiveTotal.Vulnerability.cveId
      description: ID of the CVE.
      type: String
    - contextPath: PassiveTotal.Vulnerability.cwes.cweId
      description: CWE ID associated with the CVE.
      type: String
    - contextPath: PassiveTotal.Vulnerability.priorityScore
      description: Priority score of the CVE.
      type: Number
    - contextPath: PassiveTotal.Vulnerability.observationCount
      description: Number of observations of CVE.
      type: Number
    - contextPath: PassiveTotal.Vulnerability.cveLink
      description: Link to the CVE.
      type: String
    - contextPath: PassiveTotal.Summary.Vulnerability.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.Vulnerability.totalCount
      description: Total number of vulnerabilities.
      type: Number
    - contextPath: PassiveTotal.Summary.Vulnerability.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.Vulnerability.nextPage
      description: Link to the next page.
      type: String
  - arguments:
    - description: |-
        Specify the CVE ID to retrieve observations of that CVE.

        Note: To retrieve the list of CVE IDs, execute the "pt-list-my-attack-surface-vulnerabilities" command.
      name: cve_id
      required: true
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface vulnerability observation information
      of the individual's account.
    name: pt-list-my-attack-surface-observations
    outputs:
    - contextPath: PassiveTotal.Observation.asset.type
      description: Type of the asset.
      type: String
    - contextPath: PassiveTotal.Observation.asset.name
      description: Name of the asset.
      type: String
    - contextPath: PassiveTotal.Observation.asset.firstSeen
      description: Date & time the record was first seen.
      type: Date
    - contextPath: PassiveTotal.Observation.asset.lastSeen
      description: Date & time the record was most recently observed.
      type: Date
    - contextPath: PassiveTotal.Observation.cveId
      description: ID of the CVE.
      type: String
    - contextPath: PassiveTotal.Observation.cwe.cweId
      description: CWE ID associated with the CVE.
      type: String
    - contextPath: PassiveTotal.Summary.Observation.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.Observation.totalCount
      description: Total number of vulnerabilities.
      type: Number
    - contextPath: PassiveTotal.Summary.Observation.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.Observation.nextPage
      description: Link to the next page.
      type: String
  - arguments:
    - description: |-
        Specify the insight ID to retrieve the assets.

        Note: To retrieve the list of insight IDs, execute the "pt-list-third-party-attack-surface-insights" command.
      name: id
      required: true
    - description: |-
        Specify the vendor ID to retrieve the assets of a specific vendor.

        Note: To retrieve the list of vendor IDs, execute the "pt-list-third-party-attack-surface" command.
      name: vendor_id
      required: true
    - description: |-
        Specify the segment_by to retrieve the assets.

        Note: To retrieve the list of segment by, execute the "pt-list-third-party-attack-surface-insights" command.
      name: segment_by
      required: true
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface asset information of the given third-party
      account.
    name: pt-list-third-party-attack-surface-assets
    outputs:
    - contextPath: PassiveTotal.ThirdParty.id
      description: ID of the vendor.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyInsightAsset.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyInsightAsset.totalCount
      description: Total number of available assets.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyInsightAsset.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyInsightAsset.nextPage
      description: Link to the next page.
      type: String
    - contextPath: PassiveTotal.ThirdParty.InsightAsset.insightId
      description: Insight ID for which assets are retrieved.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.InsightAsset.segmentBy
      description: Segment by for which assets are retrieved.
      type: String
    - contextPath: PassiveTotal.ThirdParty.InsightAsset.asset.type
      description: Type of the asset.
      type: String
    - contextPath: PassiveTotal.ThirdParty.InsightAsset.asset.name
      description: Name of the asset.
      type: String
    - contextPath: PassiveTotal.ThirdParty.InsightAsset.asset.firstSeen
      description: Date & time the record was first seen.
      type: Date
    - contextPath: PassiveTotal.ThirdParty.InsightAsset.asset.lastSeen
      description: Date & time the record was most recently observed.
      type: Date
  - arguments:
    - description: |-
        Specify the vendor ID to retrieve the vulnerable components for a particular vendor.

        Note: To retrieve the list of vendor IDs, execute the "pt-list-third-party-attack-surface" command.
      name: id
      required: true
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface vulnerable component information of
      the given third-party account.
    name: pt-list-third-party-attack-surface-vulnerable-components
    outputs:
    - contextPath: PassiveTotal.ThirdParty.id
      description: ID of the vendor.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerableComponent.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerableComponent.totalCount
      description: Total number of available vulnerable components.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerableComponent.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerableComponent.nextPage
      description: Link to the next page.
      type: String
    - contextPath: PassiveTotal.ThirdParty.VulnerableComponent.name
      description: Name of the vulnerable component.
      type: String
    - contextPath: PassiveTotal.ThirdParty.VulnerableComponent.type
      description: Type of the vulnerable component.
      type: String
    - contextPath: PassiveTotal.ThirdParty.VulnerableComponent.severity
      description: Severity of the vulnerable component.
      type: String
    - contextPath: PassiveTotal.ThirdParty.VulnerableComponent.count
      description: Number of assets affected.
      type: Number
  - arguments:
    - description: |-
        Specify the vendor ID to retrieve the vulnerabilities for a particular vendor.

        Note: To retrieve the list of vendor IDs, execute the "pt-list-third-party-attack-surface" command.
      name: id
      required: true
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface vulnerability information of the given
      third-party account.
    name: pt-list-third-party-attack-surface-vulnerabilities
    outputs:
    - contextPath: PassiveTotal.ThirdParty.id
      description: ID of the vendor.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.Vulnerability.cveId
      description: ID of the CVE.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Vulnerability.cwes.cweId
      description: CWE ID associated with the CVE.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Vulnerability.priorityScore
      description: Priority score of the CVE.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.Vulnerability.observationCount
      description: Number of observations of CVE.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.Vulnerability.cveLink
      description: Link to the CVE.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerability.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerability.totalCount
      description: Total number of vulnerabilities.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerability.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyVulnerability.nextPage
      description: Link to the next page.
      type: String
  - arguments:
    - description: |-
        Specify the vendor ID to retrieve the vulnerability observations for a particular vendor.

        Note: To retrieve the list of vendor IDs, execute the "pt-list-third-party-attack-surface" command.
      name: id
      required: true
    - description: |-
        Specify the CVE ID to retrieve observations of the CVE.

        Note: To retrieve the list of CVE IDs, execute the "pt-list-third-party-attack-surface-vulnerabilities" command.
      name: cve_id
      required: true
    - defaultValue: "0"
      description: |-
        Page number for paging through results.

        Note: The minimum value supported is 0 and maximum value supported is int32.
      name: page_number
    - defaultValue: "50"
      description: |-
        Maximum number of results to return per page.

        Note: The minimum value supported is 1 and maximum value supported is int32.
      name: page_size
    description: Retrieves the attack surface vulnerability observation information
      of the given third-party account.
    name: pt-list-third-party-attack-surface-observations
    outputs:
    - contextPath: PassiveTotal.ThirdParty.id
      description: ID of the vendor.
      type: Number
    - contextPath: PassiveTotal.ThirdParty.Observation.asset.type
      description: Type of the asset.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Observation.asset.name
      description: Name of the asset.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Observation.asset.firstSeen
      description: Date & time the record was first seen.
      type: Date
    - contextPath: PassiveTotal.ThirdParty.Observation.asset.lastSeen
      description: Date & time the record was most recently observed.
      type: Date
    - contextPath: PassiveTotal.ThirdParty.Observation.cveId
      description: ID of the CVE.
      type: String
    - contextPath: PassiveTotal.ThirdParty.Observation.cwe.cweId
      description: CWE ID associated with the CVE.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyObservation.name
      description: The command name.
      type: String
    - contextPath: PassiveTotal.Summary.ThirdPartyObservation.totalCount
      description: Total number of observations.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyObservation.totalPages
      description: Number of pages.
      type: Number
    - contextPath: PassiveTotal.Summary.ThirdPartyObservation.nextPage
      description: Link to the next page.
      type: String
  dockerimage: demisto/python3:3.9.8.24399
  runonce: false
  script: |
    register_module_line('PassiveTotal v2', 'start', __line__())


    ''' IMPORTS '''

    from typing import Dict, Any, List, Union, Tuple, Optional
    from requests import ConnectionError
    from requests.exceptions import MissingSchema, InvalidSchema
    import urllib3
    import traceback
    import re
    from urllib import parse

    # Disable insecure warnings
    urllib3.disable_warnings()

    ''' CONSTANTS '''
    DATE_TIME_FORMAT = '%Y-%m-%d %H:%M:%S'

    DATE_FORMAT = '%Y-%m-%d'

    INTEGRATION_NAME: str = 'PassiveTotal'

    DEFAULT_REQUEST_TIMEOUT = '20'

    PROFILE_TYPE = ["actor", "backdoor", "tool"]

    SOURCE = ["osint", "riskiq"]

    DEFAULT_PAGE_NUMBER = 0

    DEFAULT_SIZE = 50

    MESSAGES: Dict[str, str] = {
        'AUTHENTICATION_ERROR': 'Unauthenticated. Check the configured Username and API secret.',
        'PAGE_NOT_FOUND_ERROR': 'No record(s) found.',
        'INTERNAL_SERVER_ERROR': 'The server encountered an internal error for PassiveTotal and was unable to complete '
                                 'your request.',
        'BAD_REQUEST_ERROR': 'An error occurred while fetching the data.',
        'REQUEST_TIMEOUT_VALIDATION': 'HTTP(S) Request timeout parameter must be a positive integer.',
        'REQUEST_TIMEOUT_EXCEED_ERROR': 'Value is too large for HTTP(S) Request Timeout.',
        'NO_RECORDS_FOUND': 'No {0} were found for the given argument(s).',
        'EMPTY_WHOIS_ARGUMENT': 'query or field argument should not be empty.',
        'EMPTY_DOMAIN_ARGUMENT': 'domain argument should not be empty.',
        'INVALID_DIRECTION_VALUE': 'The given value for direction is invalid. Supported values: children, parents.',
        'INVALID_QUERY_VALUE': 'The given value for query is invalid.',
        'MISSING_SCHEMA_ERROR': 'Invalid API URL. No schema supplied: http(s).',
        'INVALID_SCHEMA_ERROR': 'Invalid API URL. Supplied schema is invalid, supports http(s).',
        'CONNECTION_ERROR': 'Connectivity failed. Check your internet connection, the API URL or try increasing the HTTP(s)'
                            ' Request Timeout.',
        'PROXY_ERROR': 'Proxy Error - cannot connect to proxy. Either try clearing the \'Use system proxy\' check-box or '
                       'check the host, authentication details and connection details for the proxy.',
        'INVALID_VALUE_IN_FIELD_ARG': 'Invalid field type {}. Valid field types are domain, email, name, organization, '
                                      'address, phone, nameserver.',
        'INVALID_IP': 'IP is not valid. Please enter a valid IP address.',
        'EMPTY_GET_WHOIS_ARGUMENT': 'query argument should not be empty.',
        'INVALID_VALUE_IN_HISTORY_ARG': 'Invalid history value {}. Valid history values are true, false.',
        'INVALID_WHOLE_NUMBER': 'Argument {} should be 0 or a positive integer.',
        'INVALID_SINGLE_SELECT': 'Invalid argument {}. Valid values are {}.',
        'INVALID_QUERY_COOKIE_DOMAIN': 'Argument query should be a valid domain that '
                                       'does not contain any special characters other than hyphen (-) and full stop (.)',
        'INVALID_QUERY_COOKIE_NAME': 'Argument query should be a valid cookie name that does not contain '
                                     'spaces, separator character or tabs.',
        "REQUIRED_ARGUMENT": "Invalid argument value. {} is a required argument.",
        "EMPTY_IP_ARGUMENT": "IP(s) not specified",
        "INVALID_IP_ARGUMENT": "Invalid IP - {}",
        'INVALID_INDICATOR_TYPE': 'Invalid indicator type {}. Valid values are certficate_sha1, certificate_sha1, domain, '
                                  'email, hash_md5, hash_sha256, ip, pdb_path, soa_email, url, whois_email.',
        'INVALID_SOURCE': 'Invalid indicator source {}. Valid values are osint, riskiq.',
        'INVALID_PAGE_SIZE': '{} is an invalid value for page size. Page size must be between 1 and int32.',
        'INVALID_PAGE_NUMBER': '{} is an invalid value for page number. Page number must be between 0 and int32.',
        "INVALID_PROFILE_TYPE": "Invalid profile type {}. Valid profile types are actor, backdoor, tool.",
        "REQUIRED_INDICATOR_VALUE": "'indicator_value' must be specified if the arguments 'source' or 'category' are used.",
        "INVALID_PRIORITY_LEVEL": "Invalid priority level {}. Valid priority level are low, medium, high.",
        "NOT_VALID_PAGE_SIZE": "{} is an invalid value for page size. Page size must be between 1 and 1000."
    }

    URL_SUFFIX: Dict[str, str] = {
        'TEST_MODULE': '/v2/account',
        'SSL_CERT_SEARCH': '/v2/ssl-certificate/search',
        'GET_PDNS_DETAILS': '/v2/dns/passive',
        'WHOIS_SEARCH': '/v2/whois/search',
        'WHOIS_GET': '/v2/whois',
        'GET_COMPONENTS': '/v2/host-attributes/components',
        'GET_TRACKERS': '/v2/host-attributes/trackers',
        'GET_ARTICLES': '/v2/articles/indicator',
        'GET_HOST_PAIRS': '/v2/host-attributes/pairs',
        'GET_SERVICES': '/v2/services',
        "GET_ADDRESSES_BY_COOKIE_NAME": "v2/cookies/name/{0}/addresses",
        "GET_ADDRESSES_BY_COOKIE_DOMAIN": "v2/cookies/domain/{0}/addresses",
        "GET_HOSTS_BY_COOKIE_NAME": "v2/cookies/name/{0}/hosts",
        "GET_HOSTS_BY_COOKIE_DOMAIN": "v2/cookies/domain/{0}/hosts",
        "GET_DATA_CARD_SUMMARY": "v2/cards/summary",
        "GET_REPUTATION": "v2/reputation",
        "LIST_INTEL_PROFILE_INDICATOR": "v2/intel-profiles/{}/indicators",
        "LIST_INTEL_PROFILE": "v2/intel-profiles",
        "LIST_INTEL_PROFILE_BY_INDICATOR": "v2/intel-profiles/indicator",
        "LIST_ASI_INSIGHTS": "/v2/attack-surface/priority",
        "LIST_ATTACK_SURFACE": "v2/attack-surface",
        "LIST_THIRD_PARTY_ASI": "v2/attack-surface/third-party",
        "LIST_ASI_ASSETS": "v2/attack-surface/insight",
        "THIRD_PARTY_ASI_INSIGHTS": "v2/attack-surface/third-party/{}/priority/{}",
        "LIST_ASI_VULNERABLE_COMPONENTS": "v2/attack-surface/vuln-intel/components",
        "LIST_ASI_VULNERABILITIES": "v2/attack-surface/vuln-intel/cves",
        "LIST_ASI_OBSERVATIONS": "v2/attack-surface/vuln-intel/cves/{}/observations",
        "LIST_THIRD_PARTY_ASI_ASSETS": "v2/attack-surface/third-party/{}/insight/{}",
        "LIST_THIRD_PARTY_ASI_VULNERABLE_COMPONENTS": "v2/attack-surface/vuln-intel/third-party/{}/components",
        "LIST_THIRD_PARTY_ASI_VULNERABILITIES": "v2/attack-surface/vuln-intel/third-party/{}/cves",
        "LIST_THIRD_PARTY_ASI_OBSERVATIONS": "v2/attack-surface/vuln-intel/third-party/{}/cves/{}/observations"
    }

    ISO_DATE: Dict[str, str] = {
        DATE_TIME_FORMAT: '"yyyy-mm-dd hh:mm:ss"',
        DATE_FORMAT: '"yyyy-mm-dd"'
    }

    VALID_DIRECTION_FOR_HOST_PAIRS = ['children', 'parents']

    REQUEST_TIMEOUT_MAX_VALUE = 9223372036

    COMPANY_NAME = "PaloAltoNetworks"

    PRODUCT_NAME = "XSOAR"

    INDICATOR_TYPE = ['certficate_sha1', 'certificate_sha1', 'domain', 'email', 'hash_md5', 'hash_sha256', 'ip',
                      'pdb_path', 'soa_email', 'url', 'whois_email']

    PRIORITY = ["high", "medium", "low"]

    UI_LINK = "https://community.riskiq.com/attack-surfaces/"


    class Client(BaseClient):
        """
        Client to use in integration with powerful http_request.
        It extends the base client and uses the http_request method for the API request.
        Handle some exceptions externally.
        """

        def __init__(self, base_url, request_timeout, verify, proxy, auth):
            super().__init__(base_url=base_url, verify=verify, proxy=proxy, auth=auth)
            self.request_timeout = request_timeout

        def http_request(self, method: str, url_suffix: str, json_data=None, params=None, headers=None) -> Dict[str, Any]:
            """
                Override http_request method from BaseClient class. This method will print an error based on status code
                and exceptions.

            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.

            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.

            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.

            :type params: ``dict``
            :param params: URL parameters to specify the query.

            :type headers: ``dict``
            :param headers: Headers to send in the request. If None, will use self._headers.

            :return: Depends on the resp_type parameter
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """
            try:
                if not headers:
                    headers = {}
                headers['X-RISKIQ'] = f"{COMPANY_NAME}-{PRODUCT_NAME}-{get_demisto_version_as_str()}"

                resp = self._http_request(method=method, url_suffix=url_suffix, json_data=json_data, params=params,
                                          headers=headers, timeout=self.request_timeout, resp_type='response',
                                          ok_codes=(200, 400, 401, 404, 407, 500), proxies=handle_proxy())
            except MissingSchema:
                raise ValueError(MESSAGES['MISSING_SCHEMA_ERROR'])
            except InvalidSchema:
                raise ValueError(MESSAGES['INVALID_SCHEMA_ERROR'])
            except DemistoException as e:
                if 'Proxy Error' in str(e):
                    raise ConnectionError(MESSAGES['PROXY_ERROR'])
                elif 'ConnectionError' in str(e) or 'ConnectTimeout' in str(e):
                    raise ConnectionError(MESSAGES['CONNECTION_ERROR'])
                else:
                    raise e

            # Providing errors based on status code
            status_code = resp.status_code

            if status_code != 200:
                error_message = ''
                if resp.json().get('message', ''):
                    error_message = 'Reason: {}'.format(resp.json().get('message', ''))
                status_code_message_map = {
                    400: '{} {}'.format(MESSAGES['BAD_REQUEST_ERROR'], error_message),
                    401: MESSAGES['AUTHENTICATION_ERROR'],
                    404: MESSAGES['PAGE_NOT_FOUND_ERROR'],
                    407: MESSAGES['PROXY_ERROR']
                }
                if status_code in status_code_message_map:
                    demisto.info('Response code: {}. Reason: {}'.format(status_code, status_code_message_map[status_code]))
                    raise ValueError(status_code_message_map[status_code])
                elif status_code >= 500:
                    demisto.info('Response code: {}. Reason: {}'.format(status_code, MESSAGES['INTERNAL_SERVER_ERROR']))
                    raise ValueError(MESSAGES['INTERNAL_SERVER_ERROR'])
                else:
                    resp.raise_for_status()

            return resp.json()


    ''' HELPER FUNCTIONS '''


    def get_request_timeout() -> Optional[Any]:
        """
        Validate and return the request timeout parameter.
        The parameter must be a positive integer.
        Default value is set to 20 seconds for API request timeout.

        :params req_timeout: Request timeout value.
        :return: boolean
        """
        try:
            request_timeout = demisto.params().get('request_timeout', DEFAULT_REQUEST_TIMEOUT)
            request_timeout = DEFAULT_REQUEST_TIMEOUT if not request_timeout else request_timeout
            request_timeout = int(request_timeout)
        except ValueError:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_VALIDATION'])

        if request_timeout <= 0:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_VALIDATION'])
        elif request_timeout > REQUEST_TIMEOUT_MAX_VALUE:
            raise ValueError(MESSAGES['REQUEST_TIMEOUT_EXCEED_ERROR'])

        return request_timeout


    def remove_empty_elements_for_context(src):
        """
         Recursively remove empty lists, empty dicts, empty string or None elements from a dictionary.

        :type src: ``dict``
        :param src: Input dictionary.

        :return: Dictionary with all empty lists,empty string and empty dictionaries removed.
        :rtype: ``dict``
        """

        def empty(x):
            return x is None or x == '' or x == {} or x == []

        if not isinstance(src, (dict, list)):
            return src
        elif isinstance(src, list):
            return [v for v in (remove_empty_elements_for_context(v) for v in src) if not empty(v)]
        else:
            return {k: v for k, v in ((k, remove_empty_elements_for_context(v))
                                      for k, v in src.items()) if not empty(v)}


    def get_host_attribute_context_data(records: List[Dict[str, Any]]) -> Tuple[list, list]:
        """
        Prepares context data for get components and get trackers command

        :param records: API response
        :return: standard entry command results list and custom entry context
        """
        custom_ec = createContext(data=records, removeNull=True)
        standard_results: List[CommandResults] = []
        for record in records:
            if record.get('hostname'):
                hostname = record.get('hostname')
                dbot_score = Common.DBotScore(indicator=hostname, indicator_type=DBotScoreType.DOMAIN,
                                              integration_name=INTEGRATION_NAME, score=Common.DBotScore.NONE)
                if auto_detect_indicator_type(hostname) == FeedIndicatorType.Domain:
                    domain_ioc = Common.Domain(domain=hostname, dbot_score=dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=domain_ioc,
                        readable_output=tableToMarkdown('', domain_ioc.to_context().get(Common.Domain.CONTEXT_PATH))
                    ))
            elif record.get('address'):
                address = record.get('address')
                dbot_score = Common.DBotScore(indicator=address, indicator_type=DBotScoreType.IP,
                                              integration_name=INTEGRATION_NAME, score=Common.DBotScore.NONE)
                if auto_detect_indicator_type(address) == FeedIndicatorType.IP:
                    ip_ioc = Common.IP(ip=address, dbot_score=dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=ip_ioc,
                        readable_output=tableToMarkdown('', ip_ioc.to_context().get(Common.IP.CONTEXT_PATH))
                    ))

        return standard_results, custom_ec


    def get_components_hr(components: List[Dict[str, Any]]) -> str:
        """
        Prepares human readable text for get components command

        :param components: Components data response
        :return: Human readable output for components
        """

        hr_table: List[Dict[str, Any]] = []

        for component in components:
            hr_row = {
                'Hostname': component.get('hostname', ''),
                'Address': component.get('address', ''),
                'First (GMT)': component.get('firstSeen', ''),
                'Last (GMT)': component.get('lastSeen', ''),
                'Category': component.get('category', ''),
                'Value': component.get('label', ''),
                'Version': component.get('version', ''),
            }
            hr_table.append(hr_row)

        hr_headers = ['Hostname', 'Address', 'First (GMT)', 'Last (GMT)', 'Category', 'Value', 'Version']
        hr = '### Total Retrieved Record(s): {0}\n'.format(len(components))
        return hr + tableToMarkdown('COMPONENTS', hr_table, hr_headers, removeNull=True)


    def get_trackers_hr(trackers: List[Dict[str, Any]]) -> str:
        """
        Prepares human readable text for get trackers command

        :param trackers: Trackers data response
        :return: Human readable output for trackers
        """

        hr_table: List[Dict[str, Any]] = []

        for tracker in trackers:
            hr_row = {
                'Hostname': tracker.get('hostname', ''),
                'Address': tracker.get('address', ''),
                'First (GMT)': tracker.get('firstSeen', ''),
                'Last (GMT)': tracker.get('lastSeen', ''),
                'Type': tracker.get('attributeType', ''),
                'Value': tracker.get('attributeValue', '')
            }
            hr_table.append(hr_row)

        hr_headers = ['Hostname', 'Address', 'First (GMT)', 'Last (GMT)', 'Type', 'Value']
        hr = '### Total Retrieved Record(s): {0}\n'.format(len(trackers))
        return hr + tableToMarkdown('TRACKERS', hr_table, hr_headers, removeNull=True)


    def get_host_pairs_hr(host_pairs: List[Dict[str, Any]]) -> str:
        """
        Prepares human readable text for get host pairs command

        :param host_pairs: Host pairs data response
        :return: Human readable output for host pairs
        """

        hr_table: List[Dict[str, Any]] = []

        for pair in host_pairs:
            hr_row = {
                'Parent Hostname': pair.get('parent', ''),
                'Child Hostname': pair.get('child', ''),
                'First (GMT)': pair.get('firstSeen', ''),
                'Last (GMT)': pair.get('lastSeen', ''),
                'Cause': pair.get('cause', '')
            }
            hr_table.append(hr_row)

        hr_headers = ['Parent Hostname', 'Child Hostname', 'First (GMT)', 'Last (GMT)', 'Cause']
        hr = '### Total Retrieved Record(s): {0}\n'.format(len(host_pairs))
        return hr + tableToMarkdown('HOST PAIRS', hr_table, hr_headers, removeNull=True)


    def get_common_arguments(args: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validates the common arguments and prepares parameter dictionary
        This method is used in commands "get-trackers", "get-components", "get-host-pairs"

        :param args: The general arguments
        :return: dict of params or message describing error in argument validation
        """
        params: Dict[str, Any] = {}

        if not args.get('query'):
            raise ValueError(MESSAGES['INVALID_QUERY_VALUE'])
        params['query'] = args.get('query')

        date_arguments = ['start', 'end']
        for argument in date_arguments:
            if args.get(argument):
                params[argument] = args.get(argument, '')

        return params


    def get_valid_whois_search_arguments(args: Dict[str, Any]) -> Tuple[str, str]:
        """
        Get and Validate arguments for pt-whois-search command.

        :param args: it contain arguments of pt-whois-search command
        :return: validated arguments 'query' and 'field'
        """
        query = args.get('query', '')
        field = args.get('field', '')
        if query.strip() == '' or field.strip() == '':
            raise ValueError(MESSAGES['EMPTY_WHOIS_ARGUMENT'])
        if field not in ('domain', 'email', 'name', 'organization', 'address', 'phone', 'nameserver'):
            raise ValueError(MESSAGES['INVALID_VALUE_IN_FIELD_ARG'].format(field))
        return query, field


    def get_valid_get_whois_arguments(args: Dict[str, Any]) -> Tuple[str, str]:
        """
        Get and Validate arguments for pt-get-whois command.

        :param args: it contain arguments of pt-get-whois command
        :return: validated arguments 'query' and 'history'
        """
        query = args.get('query', '').strip()
        arg_history = args.get('history', '').strip()
        history = arg_history.lower()
        if query == '':
            raise ValueError(MESSAGES['EMPTY_GET_WHOIS_ARGUMENT'])
        if history and history not in ('true', 'false'):
            raise ValueError(MESSAGES['INVALID_VALUE_IN_HISTORY_ARG'].format(arg_history))
        return query, history


    def nested_to_flat(src: Dict[str, Any], key: str) -> Dict[str, Any]:
        """
        Convert nested dictionary to flat by contact the keys. Also converts keys in pascal string format.

        :param src: sub-dictionary that needs to convert from nested to flat. (e.g. "foo": {"bar": "some-value"})
        :param key: main key of sub-dictionary (e.g "foo")
        :return: flat dictionary with pascal formatted keys (e.g. {"FooBar": "some-value"})
        """

        flat_dict: Dict[str, str] = {}
        for sub_key, sub_value in src.items():
            pascal_key = '{}{}'.format(key, sub_key[0].upper() + sub_key[1:])
            flat_dict[pascal_key] = sub_value

        return flat_dict


    def prepare_context_dict(response_dict: Dict[str, Any],
                             keys_with_hierarchy: tuple = (),
                             exclude_keys: tuple = ()) -> Dict[str, str]:
        """
        Prepare the context dictionary as per the standards.

        :param response_dict: dictionary getting from API response that contains sub-dictionaries
        :param keys_with_hierarchy: list of keys that contains sub-dictionary as its value.
        :param exclude_keys: keys need to exclude.
        :return: single level dictionary
        """
        simple_dict: Dict[str, str] = {}
        for key, value in response_dict.items():
            if key in keys_with_hierarchy:
                simple_dict.update(nested_to_flat(response_dict.get(key, {}), key))
            elif key not in exclude_keys:
                simple_dict[key] = value
        return simple_dict


    def get_context_for_whois_commands(domains: List[Dict[str, Any]], score=0) -> Tuple[list, list]:
        """
        Prepare context for whois and domain reputation commands.

        :param domains: list of domains return from response
        :param score:
        :return: command results for standard context and custom context for whois and domain reputation command
        """
        command_results: List[CommandResults] = []
        custom_context: List[Dict[str, Any]] = []
        # set domain standard context
        for domain in domains:
            # set domain standard context
            if auto_detect_indicator_type(domain.get('domain', '')) == FeedIndicatorType.Domain:
                standard_context_domain = Common.Domain(
                    domain=domain.get('domain', ''),
                    creation_date=domain.get('registered', ''),
                    updated_date=domain.get('registryUpdatedAt', ''),
                    expiration_date=domain.get('expiresAt', ''),
                    name_servers=domain.get('nameServers', ''),
                    organization=domain.get('organization', ''),
                    admin_name=domain.get('admin', {}).get('name', ''),
                    admin_email=domain.get('admin', {}).get('email', ''),
                    admin_phone=domain.get('admin', {}).get('telephone', ''),
                    admin_country=domain.get('admin', {}).get('country', ''),
                    registrar_name=domain.get('registrar', ''),
                    registrant_email=domain.get('registrant', {}).get('email', ''),
                    registrant_name=domain.get('registrant', {}).get('name', ''),
                    registrant_phone=domain.get('registrant', {}).get('telephone', ''),
                    registrant_country=domain.get('registrant', {}).get('country', ''),
                    dbot_score=Common.DBotScore(
                        indicator=domain.get('domain', ''),
                        indicator_type=DBotScoreType.DOMAIN,
                        integration_name=INTEGRATION_NAME,
                        score=score
                    )
                )
                # add standard output with standard readable output
                command_results.append(CommandResults(
                    indicator=standard_context_domain,
                    readable_output=tableToMarkdown('',
                                                    standard_context_domain.to_context().get(Common.Domain.CONTEXT_PATH))
                ))

            # set custom context for whois commands
            custom_context.append(
                prepare_context_dict(
                    response_dict=domain,
                    keys_with_hierarchy=('registrant', 'admin', 'billing', 'tech'),
                    exclude_keys=('zone', 'rawText')
                )
            )
        return command_results, createContext(custom_context, removeNull=True)


    def get_context_for_get_whois_commands(domains: List[Dict[str, Any]]) -> list:
        """
        Prepare context for pt-get-whois command.

        :param domains: list of domains return from response
        :return: command results for custom context for whois command
        """
        custom_context: List[Dict[str, Any]] = []
        # set domain standard context
        for domain in domains:
            custom_context.append(
                prepare_context_dict(
                    response_dict=domain,
                    keys_with_hierarchy=('registrant', 'admin', 'billing', 'tech'),
                    exclude_keys=('zone', 'rawText')
                )
            )
        return createContext(custom_context, removeNull=True)


    def prepare_hr_cell_for_whois_info(domain_info: Dict[str, Any]) -> str:
        """
        Prepare cell information for Registrant, Admin, Billing and Tech columns.

        :param domain_info: domain information as a directory
        :return: domain information as a readable format
        """
        hr_cell_info: List[str] = []
        for key, value in domain_info.items():
            hr_cell_info.append('**{}:** {}'.format(key[0].upper() + key[1:], value))
        return ',\n'.join(hr_cell_info)


    def get_human_readable_for_whois_commands(domains: List[Dict[str, Any]], is_reputation_command=False):
        """
        Prepare readable output for whois commands

        :param domains: list of domains return from response
        :param is_reputation_command: true if the command is execute for reputation command else false, default is false
        :return: markdown of whois commands based on domains passed
        """
        hr_table_content: List[Dict[str, Any]] = []
        table_name = 'Domain(s)'
        for domain in domains:
            hr_row = {
                'Domain': domain.get('domain', ''),
                'WHOIS Server': domain.get('whoisServer', ''),
                'Registrar': domain.get('registrar', ''),
                'Contact Email': domain.get('contactEmail', ''),
                'Name Servers': ', '.join(domain.get('nameServers', [])),
                'Creation Date (GMT)': domain.get('registered', ''),
                'Expire Date (GMT)': domain.get('expiresAt', ''),
                'Updated Date (GMT)': domain.get('registryUpdatedAt', ''),
                'Last Scanned (GMT)': domain.get('lastLoadedAt', ''),
                'Registrant': prepare_hr_cell_for_whois_info(domain.get('registrant', {})),
                'Admin': prepare_hr_cell_for_whois_info(domain.get('admin', {})),
                'Billing': prepare_hr_cell_for_whois_info(domain.get('billing', {})),
                'Tech': prepare_hr_cell_for_whois_info(domain.get('tech', {}))
            }
            hr_table_content.append(hr_row)

        hr = ''
        if not is_reputation_command:
            hr += '### Total Retrieved Record(s): ' + str(len(domains)) + '\n'
            table_name = 'Associated Domains'
        hr += tableToMarkdown(
            name=table_name,
            t=hr_table_content,
            headers=['Domain', 'WHOIS Server', 'Registrar', 'Contact Email', 'Name Servers', 'Registrant', 'Admin',
                     'Billing', 'Tech', 'Creation Date (GMT)', 'Expire Date (GMT)', 'Updated Date (GMT)',
                     'Last Scanned (GMT)'],
            removeNull=True
        )
        return hr


    def get_human_readable_for_articles_commands(articles: List[Dict[str, Any]]):
        """
        Prepare readable output for pt-get-articles command

        :param articles: list of articles return from response
        :return: markdown of article command based on articles passed
        """
        hr_table_content: List[Dict[str, Any]] = []
        table_name = 'Article(s)'
        for article in articles:
            hr_row = {
                'GUID': article.get('guid', ''),
                'Title': article.get('title', ''),
                'Summary': article.get('summary', ''),
                'Type': article.get('type', ''),
                'Tags': ', '.join(article.get('tags', [])) if article.get('tags', []) else '',
                'Categories': ', '.join(article.get('categories', [])) if article.get('categories', []) else '',
                'Article Link': article.get('link', ''),
                'Published Date (GMT)': article.get('publishedDate', '')
            }
            hr_table_content.append(hr_row)

        hr = '### Total Retrieved Record(s): ' + str(len(articles)) + '\n'
        hr += tableToMarkdown(
            name=table_name,
            t=hr_table_content,
            headers=['GUID', 'Title', 'Summary', 'Type', 'Tags', 'Categories', 'Article Link', 'Published Date (GMT)'],
            removeNull=True
        )
        return hr


    def get_human_readable_for_data_card_command(results: Dict[str, Any]) -> str:
        """
            Parse and convert the Data Card Summary in the response into human-readable markdown string.

            :type results: ``List[Dict[str, Any]]``
            :param results: Details of urls.

            :return: Human Readable string containing information of data card.
            :rtype: ``str``
            """
        hr_table_content: List[Dict[str, Any]] = []
        summary = results.get('data_summary', {})
        summary = {pascalToSpace(underscoreToCamelCase(k)): v for k, v in summary.items()}

        hr_row = {
            'Name': results.get('name', ''),
            'Type': results.get('type', ''),
            'Netblock': results.get('netblock', ''),
            'Autonomous System Number': results.get('asn', ''),
            'Host Provider': results.get('hosting_provider', ''),
            'Operating System': results.get('os', ''),
            'Data Card Summary': get_data_card_summary(summary)

        }
        hr_table_content.append(hr_row)

        return tableToMarkdown("Data Card Summary", hr_table_content,
                               headers=["Name", "Type", "Netblock", "Autonomous System Number", "Host Provider",
                                        "Operating System", "Data Card Summary"], removeNull=True)


    def get_human_readable_for_reputation_command(results: Dict[str, Any], query: str) -> str:
        """
            Parse and convert the response into human-readable markdown string.

            :type results: ``List[Dict[str, Any]]``
            :param results: Details of urls.

            :type query: ``str``
            :param query: Value of the indicator.

            :return: Human Readable string containing information.
            :rtype: ``str``
            """
        classification = results.get('classification', '')

        reputation_score = results.get('score', '')

        reputation_message = f"The reputation score for '{query}' is {reputation_score} and is classified as '{classification}'.\n"

        hr_table_content: List[Dict[str, Any]] = []

        rules = results.get('rules', [])
        for rule in rules:
            link = rule.get('link')
            if link:
                name = f"[{rule.get('name', '')}]({rule.get('link')})"
            else:
                name = rule.get('name', '')
            hr_row = {
                'Name': name,
                'Description': rule.get('description', ''),
                'Severity': rule.get('severity', '')

            }
            hr_table_content.append(hr_row)
        hr_table = tableToMarkdown("Reputation Rules", hr_table_content, headers=['Name', 'Description', 'Severity'])

        return reputation_message + hr_table


    def prepare_human_readable_dict_for_ssl(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Preparing human-readable dictionary for ssl certificate command.

        :param results: ssl certificates details
        :return: human-readable dict
        """
        return [{
            'First (GMT)': epochToTimestamp(result.get('firstSeen', '')) if result.get('firstSeen') else None,
            'Last (GMT)': epochToTimestamp(result.get('lastSeen', '')) if result.get('lastSeen') else None,
            'SSL Version': result.get('sslVersion', 0),
            'Expires (GMT)': result.get('expirationDate', ''),
            'Issued (GMT)': result.get('issueDate', ''),
            'Sha1': result.get('sha1', ''),
            'Serial Number': result.get('serialNumber', ''),
            'Subject Country': result.get('subjectCountry', ''),
            'Issuer Common Name': result.get('issuerCommonName', ''),
            'Issuer Province': result.get('issuerProvince', ''),
            'Subject State/Province Name': result.get('subjectStateOrProvinceName', ''),
            'Subject Street Address': result.get('subjectStreetAddress', ''),
            'Issuer State/Province Name': result.get('issuerStateOrProvinceName', ''),
            'Issuer Country': result.get('issuerCountry', ''),
            'Subject Locality Name': result.get('subjectLocalityName', ''),
            'Subject Alternative Names': ', '.join(result.get('subjectAlternativeNames', [])),
            'Issuer Organization Unit Name': result.get('issuerOrganizationUnitName', ''),
            'Issuer Organization Name': result.get('issuerOrganizationName', ''),
            'Subject Organization Name': result.get('subjectOrganizationName', ''),
            'Issuer Locality Name': result.get('issuerLocalityName', ''),
            'Subject Common Name': result.get('subjectCommonName', ''),
            'Subject Province': result.get('subjectProvince', ''),
            'Subject Organization Unit Name': result.get('subjectOrganizationUnitName', ''),
            'Issuer Street Address': result.get('issuerStreetAddress', '')
        } for result in results]


    def prepare_human_readable_dict_for_pdns(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Prepare human-readable dictionary for passive DNS command.

        :param results: passive DNS details.
        :return: human-readable dict
        """
        return [{
            'First (GMT)': result.get('firstSeen', ''),
            'Last (GMT)': result.get('lastSeen', ''),
            'Source': ', '.join(result.get('source', [])),
            'Value': result.get('value', ''),
            'Collected (GMT)': result.get('collected', ''),
            'Record Type': result.get('recordType', ''),
            'Resolve': result.get('resolve', ''),
            'Resolve Type': result.get('resolveType', ''),
            'Record Hash': result.get('recordHash', '')
        } for result in results]


    def get_ssl_cert_search_hr(results: List[Dict[str, Any]]) -> str:
        """
        Retrieved information of ssl certificates and convert it into human-readable markdown string.

        :param results: ssl certificates details
        :return: human-readable string
        """
        ssl_cert_search_hr: List[Dict[str, Any]] = prepare_human_readable_dict_for_ssl(results)

        hr = '### Total Retrieved Record(s): ' + str(len(results)) + '\n'
        hr += tableToMarkdown('SSL certificate(s)', ssl_cert_search_hr,
                              ['Sha1', 'Serial Number', 'Issued (GMT)', 'Expires (GMT)', 'SSL Version', 'First (GMT)',
                               'Last (GMT)', 'Issuer Common Name', 'Subject Common Name', 'Subject Alternative Names',
                               'Issuer Organization Name', 'Subject Organization Name', 'Issuer Locality Name',
                               'Subject Locality Name', 'Issuer State/Province Name', 'Subject State/Province Name',
                               'Issuer Country', 'Subject Country', 'Issuer Street Address', 'Subject Street Address',
                               'Issuer Organization Unit Name', 'Subject Organization Unit Name'], removeNull=True)

        return hr


    def get_pdns_details_hr(results: List[Dict[str, Any]], total_record: int) -> str:
        """
        Retrieved information of passive DNS and convert it into human-readable markdown string.

        :param results: passive DNS details
        :param total_record: number of record retrieved from response
        :return: human-readable string
        """
        pdns_details_hr: List[Dict[str, Any]] = prepare_human_readable_dict_for_pdns(results)

        table_headers = ['Resolve', 'Resolve Type', 'Record Type', 'Collected (GMT)', 'First (GMT)', 'Last (GMT)',
                         'Source', 'Record Hash']
        hr = '### Total Retrieved Record(s): ' + str(total_record) + '\n'
        hr += tableToMarkdown('PDNS detail(s)', pdns_details_hr, table_headers, removeNull=True)
        return hr


    def create_pdns_standard_context(results: List[Dict[str, Any]]) -> List[CommandResults]:
        """
        Preparing standard context and dbotScore for pdns command.
        here, standard context includes ip and domain model.

        :param results: pdns details from response
        :return: list of CommandResults of standard context
        """
        standard_results: List[CommandResults] = []
        for result in results:
            resolve_type = result.get('resolveType', '')
            resolve = result.get('resolve', '')

            if 'domain' == resolve_type:
                dbot_score = Common.DBotScore(resolve, resolve_type, INTEGRATION_NAME, Common.DBotScore.NONE)
                if auto_detect_indicator_type(resolve) == FeedIndicatorType.Domain:
                    domain_ioc = Common.Domain(resolve, dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=domain_ioc,
                        readable_output=tableToMarkdown('', domain_ioc.to_context().get(Common.Domain.CONTEXT_PATH))
                    ))
            elif 'ip' == resolve_type:
                dbot_score = Common.DBotScore(resolve, resolve_type, INTEGRATION_NAME, Common.DBotScore.NONE)
                if auto_detect_indicator_type(resolve) == FeedIndicatorType.IP:
                    ip_ioc = Common.IP(resolve, dbot_score)
                    # add standard output with standard readable output
                    standard_results.append(CommandResults(
                        indicator=ip_ioc,
                        readable_output=tableToMarkdown('', ip_ioc.to_context().get(Common.IP.CONTEXT_PATH))
                    ))

        return standard_results


    def get_services_hr(total_records: int, results: list) -> str:
        services_hr = []
        for result in results:
            current_services = result.get("currentServices", [])
            labels = []
            for services in current_services:
                if services.get("label"):
                    labels.append(services.get("label"))

            services_hr.append({
                "Port Number": result.get("portNumber"),
                "Protocol": result.get("protocol"),
                "Status": result.get("status"),
                "Current Service Labels": ", ".join(labels),
                "First Seen Date (GMT)": result.get("firstSeen"),
                "Last Seen Date (GMT)": result.get("lastSeen"),
                "Last Scanned Date (GMT)": result.get("lastScan")
            })

        table_output = tableToMarkdown("Services", services_hr,
                                       headers=["Port Number", "Protocol", "Status", "Current Service Labels",
                                                "First Seen Date (GMT)", "Last Seen Date (GMT)", "Last Scanned Date (GMT)"],
                                       removeNull=True)

        return f"### Total Retrieved Record(s) {total_records} \n {table_output}"


    def validate_get_cookies_arguments(args: Dict[str, Any]) -> None:
        """
        Validate arguments for get cookies command, raise ValueError on invalid arguments.

        :param args: stripped arguments provided by user
        """

        # check if page is a valid whole number
        try:
            if int(args.get("page", "0")) < 0:
                raise ValueError
        except ValueError:
            raise ValueError(MESSAGES['INVALID_WHOLE_NUMBER'].format('page'))

        # check if the single-select values of arguments are valid or not
        valid_values = {
            'search_by': [
                'get addresses by cookie domain',
                'get addresses by cookie name',
                'get hosts by cookie domain',
                'get hosts by cookie name'
            ],
            'order': [
                'desc',
                'asc'
            ],
            'sort': [
                'first seen',
                'last seen'
            ]
        }
        for argument_name, valid_value in valid_values.items():
            if args.get(argument_name) not in valid_value:
                raise ValueError(MESSAGES['INVALID_SINGLE_SELECT'].format(argument_name, ",".join(valid_value)))

        # validate query param based on search_by
        if "domain" in args['search_by']:
            # The domain should only contain the characters a-z, A-Z, hyphen (-) and fullstops (.).
            if not args["query"] or re.search("[^a-zA-Z0-9.-]", args['query']):
                raise ValueError(MESSAGES['INVALID_QUERY_COOKIE_DOMAIN'])
        else:
            """ Valid cookie name can be any US-ASCII characters,
                except control characters, spaces, separator character or tabs."""
            if not args["query"] or re.search(r'[?^()<>@,;:/="\[\]{}\\\t\n\s]', args["query"]):
                raise ValueError(MESSAGES['INVALID_QUERY_COOKIE_NAME'])


    def get_cookies_hr(results: List[Dict[str, Any]], hostname_header: str, total_records: int):
        """
        Retrieved information of cookies and convert it into human-readable markdown string.

        :param results: cookie details
        :param hostname_header: The header for the hostname column, should be either 'Hostname' or 'IP Address'
        :param total_records: Total number of available records
        :return: human-readable string
        """
        hr_results = [{
            hostname_header: result.get("hostname", ''),
            'Cookie Name': result.get("cookieName", ''),
            'Cookie Domain': result.get("cookieDomain", ''),
            'First Seen Date (GMT)': result.get("firstSeen", ''),
            'Last Seen Date (GMT)': result.get("lastSeen", '')
        } for result in results]

        table_headers = [hostname_header, 'Cookie Name', 'Cookie Domain', 'First Seen Date (GMT)', 'Last Seen Date (GMT)']

        hr = '### Total Record(s): ' + str(total_records) + '\n'
        hr += '### Total Retrieved Record(s): ' + str(len(hr_results)) + '\n'
        hr += tableToMarkdown('Cookies', hr_results, table_headers, removeNull=True)
        return hr


    def calculate_dbot_score(classification: str) -> int:
        """
        Calculate te dbot score according to the classification provided
        :param classification: The classification received from he api response
        :return: Dbot Score
        """
        if classification == "UNKNOWN":
            score = Common.DBotScore.NONE  # unknown
        elif classification == "MALICIOUS":
            score = Common.DBotScore.BAD  # bad
        elif classification == "SUSPICIOUS":
            score = Common.DBotScore.SUSPICIOUS  # suspicious
        else:
            score = Common.DBotScore.GOOD  # good
        return score


    def get_standard_context(score: int, ip: str) -> Common.IP:
        """
        Prepare standard context for ip reputation command
        :param score: The Dbot score
        :param ip: IP Address
        :return: IP indicator object
        """
        dbot_score = Common.DBotScore(
            indicator=ip,
            integration_name='PassiveTotal',
            indicator_type=DBotScoreType.IP,
            score=score
        )
        return Common.IP(
            ip=ip,
            dbot_score=dbot_score
        )


    def get_data_card_summary(summary: dict) -> str:
        """
        Prepare data card summary
        :param summary: data card summary response
        :return: human readable string
        """
        data_card_summary = ""
        for key, value in summary.items():
            if value.get("count") == 0:
                data_card_summary += "{}: {}, ".format(key, value.get("count"))
            else:
                data_card_summary += "{}: [{}]({}), ".format(key, value.get("count"), value.get("link"))

        return data_card_summary[:-2]


    def validate_list_intel_profile_args(args: Dict[str, str]) -> Tuple[Dict[str, Any], int]:
        """
        Validate arguments for pt-list-intel-profiles, raise ValueError on invalid arguments.

        :param args: The command arguments provided by the user.
        :return: Parameters to send in request

        """
        params: Dict[str, Any] = {}
        query = args.get('query', '')
        if query:
            params["query"] = query

        profile_type = args.get('type', '').lower()
        if profile_type:
            if profile_type not in PROFILE_TYPE:
                raise ValueError(MESSAGES["INVALID_PROFILE_TYPE"].format(profile_type))
            params["type"] = profile_type

        indicator_value = args.get("indicator_value", "")
        if indicator_value:
            params["query"] = indicator_value

        source = args.get('source', '').lower()
        if source:
            if not indicator_value:
                raise ValueError(MESSAGES["REQUIRED_INDICATOR_VALUE"])
            if source not in SOURCE:
                raise ValueError(MESSAGES["INVALID_SOURCE"].format(source))
            params["sources"] = source

        category = args.get('category', '').lower()
        if category:
            if not indicator_value:
                raise ValueError(MESSAGES["REQUIRED_INDICATOR_VALUE"])
            params["categories"] = category

        page_size = validate_page_size_args(args)

        return params, page_size


    def get_human_readable_for_intel_profile_command(results: List[Dict[str, Any]]) -> str:
        """
        Parse and convert the response into human-readable markdown string.

        :param results: Details of profiles.
        :return: Human Readable string containing information.
        """
        hr_list = []
        for profile in results:
            hr_record = {
                'ID': profile.get('id', ''),
                'Title': profile.get('title', ''),
                'Aliases': ", ".join("{}".format(i) for i in profile.get("aliases", [])),
                'Public Indicators': profile.get('osintIndicatorsCount', ''),
                'RiskIQ Indicators': profile.get('riskIqIndicatorsCount', '')
            }

            hr_list.append(hr_record)

        return tableToMarkdown('Profile(s)', hr_list, ['ID', 'Title', 'Aliases', 'Public Indicators', 'RiskIQ Indicators'],
                               removeNull=True)


    def validate_page_and_size_args(args: Dict[str, str]) -> dict:
        """
        Validate page and size arguments for all commands, raise ValueError on invalid arguments.
        :param args: The command arguments provided by the user.
        :return: Parameters to send in request
        """

        params: Dict[str, Any] = {}

        page_size = arg_to_number(args.get('page_size', DEFAULT_SIZE))

        if page_size is not None:
            if page_size < 1 or page_size > 2147483647:
                raise ValueError(MESSAGES["INVALID_PAGE_SIZE"].format(page_size))
        else:
            page_size = int(DEFAULT_SIZE)
        params["size"] = page_size

        page_number = arg_to_number(args.get('page_number', DEFAULT_PAGE_NUMBER))
        if page_number:
            if page_number < 0 or page_number > 2147483647:
                raise ValueError(MESSAGES["INVALID_PAGE_NUMBER"].format(page_number))
        else:
            page_number = int(DEFAULT_PAGE_NUMBER)
        params["page"] = page_number

        return params


    def validate_list_intel_profile_indicators_args(args: Dict[str, Any]) -> Tuple[str, dict]:
        """
        Validate arguments of list_intel_profile_indicators commands, raise ValueError on invalid arguments.
        :param args: The command arguments provided by the user.
        :return: Parameters to send in request
        """
        profile_id = args.get('id', '')
        if not profile_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('id'))

        params = validate_page_and_size_args(args)

        indicator_type = args.get('type', '').lower()
        if indicator_type:
            if indicator_type not in INDICATOR_TYPE:
                raise ValueError(MESSAGES["INVALID_INDICATOR_TYPE"].format(indicator_type))
            params['types'] = indicator_type

        indicator_value = args.get('indicator_value', '')
        if indicator_value:
            params['query'] = indicator_value

        source = args.get('source', '').lower()
        if source:
            if source not in SOURCE:
                raise ValueError(MESSAGES['INVALID_SOURCE'].format(source))
            params['sources'] = source

        category = args.get('category', '').lower()
        if category:
            params['categories'] = category

        return profile_id, params


    def get_human_readable_for_intel_profile_indicator_command(indicators: Dict[str, Any]) -> str:
        """
        Parse and convert the intel profile indicator list into human-readable markdown string.
        :param indicators: Details of indicators.
        :return: Human Readable string containing information of intel profile indicators.
        """
        hr_table_content: List[Dict[str, Any]] = []
        total_records = indicators.get('totalCount', 0)

        for indicator in indicators.get('results', []):
            hr_row = {
                'ID': indicator.get('id', ''),
                'Artifact Value': indicator.get('value', ''),
                'Type': indicator.get('type', ''),
                'First Seen (GMT)': indicator.get('firstSeen', ''),
                'Last Seen (GMT)': indicator.get('lastSeen', ''),
                'Source': 'OSINT' if indicator.get('osint', True) else 'RiskIQ',
            }
            hr_table_content.append(hr_row)

        hr = f"### Total Retrieved Indicator(s) {total_records}\n"
        hr += tableToMarkdown("Indicator(s)", hr_table_content,
                              headers=["ID", "Artifact Value", "Type", "First Seen (GMT)", "Last Seen (GMT)", "Source"],
                              removeNull=True)
        return hr


    def validate_list_my_asi_insights_args(args: Dict[str, Any]) -> Tuple[str, int]:
        """
        Validate arguments of pt-list-my-attack-surface-insights, pt-list-third-party-asi-insights command, raise ValueError
        on invalid arguments.

        :param args: The command arguments provided by the user.
        :return: Parameters to send in request
        """

        priority = args.get('priority', '').lower()

        if priority:
            if priority not in PRIORITY:
                raise ValueError(MESSAGES["INVALID_PRIORITY_LEVEL"].format(priority))
        else:
            raise ValueError(MESSAGES["REQUIRED_ARGUMENT"].format("priority"))

        page_size = validate_page_size_args(args)

        return priority, page_size


    def prepare_context_for_my_asi_insights(response, priority_level) -> Dict[str, Any]:
        """
        Prepare context data for pt-list-my-attack-surface-insights, pt-list-third-party-asi-insights command
        :param response: API response.
        :param priority_level: The priority level provided by the user.
        :return: context data
        """
        context_data = {"priorityLevel": priority_level}

        insights = response.get("insights", [])

        for insight in insights:
            link = insight.get("link", '')
            if link:
                # retrieve segment_by and insight_id from the link received from api response
                link_split = link.split('?')
                insight['insightId'] = link_split[0].split('/')[-1]
                query_parameters = parse.parse_qs(link_split[1])
                insight['segmentBy'] = query_parameters.get("segmentBy", '')[0]

        context_data["insight"] = insights

        return context_data


    def get_human_readable_for_my_asi_insights_command(results: Dict[str, Any], priority: str, active_insights: int,
                                                       total_insights: int, total_observations: int) -> str:
        """
        Parse and convert the asi insight list into human-readable markdown string.
        :param results: Details of insights.
        :param priority: Priority of insights.
        :param active_insights: Total active insights
        :param total_insights: Total number of insights
        :param total_observations: Total observations
        :return: Human Readable string containing information.
        """
        hr_table_content: List[Dict[str, Any]] = []

        insights = results.get('insight', {})
        for insight in insights:
            hr_row = {
                'Name': insight.get('name', ''),
                'Description': insight.get('description', ''),
                'Observations': insight.get('observationCount', ''),
                'Insight ID': insight.get('insightId', ''),
                'Segment By': insight.get('segmentBy', ''),
            }
            hr_table_content.append(hr_row)

        # sort on the basis of observation count
        sorted_hr_table = sorted(hr_table_content, key=lambda item: item['Observations'], reverse=True)

        table_heading = f"{priority.capitalize()} Severity Insights\n{active_insights} Active of {total_insights} " \
                        f"Insights - {total_observations} Observations\n"
        hr = tableToMarkdown(table_heading, sorted_hr_table,
                             headers=["Name", "Description", "Observations", "Insight ID", "Segment By"],
                             removeNull=True)
        return hr


    def get_human_readable_for_attack_surface_command(response: List[Dict[str, Any]]) -> str:
        """
        Parse and convert the attack surface list into human-readable markdown string.
        :param response: Details of attack surface.
        :return: Human Readable string containing information of attack surface.
        """
        hr_table_content: List[Dict[str, Any]] = []

        for result in response:
            hr_row = {
                'ID': result.get('id', ''),
                'Name': f"[{result.get('name', '')}]({UI_LINK}{result.get('id', '')})",
                'High Severity': f"{result.get('priorities', {}).get('high', {}).get('observationCount', 0)} observations",
                'Medium Severity': f"{result.get('priorities', {}).get('medium', {}).get('observationCount', 0)} observations",
                'Low Severity': f"{result.get('priorities', {}).get('low', {}).get('observationCount', 0)} observations",
            }
            hr_table_content.append(hr_row)

        return tableToMarkdown("Attack Surface(s)", hr_table_content,
                               headers=["ID", "Name", "High Severity", "Medium Severity", "Low Severity"], removeNull=True)


    def validate_list_my_asi_assets_args(args: Dict[str, Any]) -> Tuple[str, dict]:
        """
        Validate arguments of list_my_asi_assets_command commands, raise ValueError on invalid arguments.
        :param args: The command arguments provided by the user.
        :return: Parameters to send in request
        """
        insight_id = args.get('id', '')
        if not insight_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('id'))

        segment_by = args.get('segment_by', '')
        if not segment_by:
            raise ValueError(MESSAGES["REQUIRED_ARGUMENT"].format("segment_by"))

        params = validate_page_and_size_args(args)
        params["segmentBy"] = segment_by

        return insight_id, params


    def get_human_readable_for_my_asi_assets_command(results: Dict[str, Any]) -> str:
        """
        Parse and convert the asi asset list into human-readable markdown string.
        :param results: Details of assets.
        :return: Human Readable string containing information.
        """
        hr_table_content: List[Dict[str, Any]] = []
        assets = results.get('assets', [])
        for asset in assets:
            hr_row = {
                'Name': asset.get('name', ''),
                'Type': asset.get('type', ''),
                'First Seen (GMT)': asset.get('firstSeen', ''),
                'Last Seen (GMT)': asset.get('lastSeen', ''),
            }
            hr_table_content.append(hr_row)

        hr = tableToMarkdown("Asset(s)", hr_table_content,
                             headers=["Name", "Type", "First Seen (GMT)", "Last Seen (GMT)"],
                             removeNull=True)
        return hr


    def get_human_readable_for_my_asi_vulnerable_components_command(results: List[Dict[str, Any]]) -> str:
        """
        Parse and convert the asi vulnerable component list into human-readable markdown string.
        :param results: Details of vulnerable component.
        :return: Human Readable string containing information.
        """
        hr_table_content: List[Dict[str, Any]] = []
        for component in results:
            hr_row = {
                'Name': component.get('name', ''),
                'Type': component.get('type', ''),
                'Severity': component.get('severity', ''),
                'Asset Count': component.get('count', ''),
            }
            hr_table_content.append(hr_row)

        hr = tableToMarkdown("Vulnerable Component(s)", hr_table_content,
                             headers=["Name", "Type", "Severity", "Asset Count"],
                             removeNull=True)
        return hr


    def get_human_readable_for_my_asi_vulnerabilities_command(results: List[Dict[str, Any]]) -> str:
        """
        Parse and convert the asi vulnerabilities list into human-readable markdown string.
        :param results: Details of vulnerability.
        :return: Human Readable string containing information.
        """
        hr_table_content: List[Dict[str, Any]] = []
        for component in results:
            hr_row = {
                'CVE ID': component.get('cveId', ''),
                'CWE ID': f'{", ".join("{}".format(i.get("cweId")) for i in component.get("cwes", []))} ',
                'RiskIQ Priority Score': component.get('priorityScore', ''),
                'Asset Count': component.get('observationCount', ''),
            }
            hr_table_content.append(hr_row)

        hr = tableToMarkdown("Vulnerabilities", hr_table_content,
                             headers=["CVE ID", "CWE ID", "RiskIQ Priority Score", "Asset Count"],
                             removeNull=True)
        return hr


    def get_human_readable_for_my_asi_observations_command(results: Dict[str, Any]) -> str:
        """
        Parse and convert the asi observations list into human-readable markdown string.
        :param results: Details of observations.
        :return: Human Readable string containing information.
        """
        hr_table_content: List[Dict[str, Any]] = []
        assets = results.get('assets', [])
        for asset in assets:
            hr_row = {
                'Name': asset.get('name', ''),
                'Type': asset.get('type', ''),
                'First Seen (GMT)': asset.get('firstSeen', ''),
                'Last Seen (GMT)': asset.get('lastSeen', ''),
            }
            hr_table_content.append(hr_row)

        hr = tableToMarkdown("Observation(s)", hr_table_content,
                             headers=["Name", "Type", "First Seen (GMT)", "Last Seen (GMT)"],
                             removeNull=True)
        return hr


    def validate_page_size_args(args: Dict[str, str]) -> int:
        """
        Validate page_size argument for all command which does not supports pagination, raise ValueError on invalid
        arguments.
        :param args: The command arguments provided by the user.
        :return: Validated page_size argument
        """

        page_size = arg_to_number(args.get('page_size', DEFAULT_SIZE))

        if page_size is not None:
            if page_size < 1 or page_size > 1000:
                raise ValueError(MESSAGES["NOT_VALID_PAGE_SIZE"].format(page_size))
        else:
            page_size = int(DEFAULT_SIZE)

        return page_size


    ''' REQUESTS FUNCTIONS '''


    def test_function(client: Client) -> str:
        """
        Performs test connectivity by valid http response

        :param client: client object which is used to get response from api
        :return: raise ValueError if any error occurred during connection
        """
        client.http_request(method='GET', url_suffix=URL_SUFFIX['TEST_MODULE'])

        return 'ok'


    @logger
    def get_components_command(client: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Retrieves the host attribute components for a domain or IP address.

        :param client: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Trim the arguments
        for argument in args:
            args[argument] = args[argument].strip()

        # Retrieve arguments and prepare query data
        params = get_common_arguments(args)

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_COMPONENTS'], params=params)

        total_records = resp.get('totalRecords', 0)
        if total_records == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('component(s)')

        results = resp.get('results', [])

        # Creating entry context
        command_results, custom_ec = get_host_attribute_context_data(results)

        # Creating human-readable
        hr = get_components_hr(results)

        command_results.insert(0, CommandResults(
            outputs_prefix='PassiveTotal.Component',
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        ))

        return command_results


    @logger
    def pt_whois_search_command(client_obj: Client, args: Dict[str, Any]) -> Union[List[CommandResults], str]:
        """
        Gets WHOIS information records based on field matching queries

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-whois-search
        :return: command output
        """
        # Retrieve arguments
        query, field = get_valid_whois_search_arguments(args)
        params = {
            'query': query,
            'field': field
        }

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['WHOIS_SEARCH'], params=params)

        domains = response.get('results', [])
        if len(domains) <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('domain information')

        # Creating entry context
        command_results, custom_ec = get_context_for_whois_commands(domains)

        # Creating human-readable
        hr = get_human_readable_for_whois_commands(domains)

        command_results.insert(0, CommandResults(
            outputs_prefix='PassiveTotal.WHOIS',
            outputs_key_field=['domain', 'lastLoadedAt'],
            outputs=custom_ec,
            readable_output=hr,
            raw_response=response
        ))

        return command_results


    @logger
    def get_trackers_command(client: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Retrieves the host attribute trackers for a domain or IP address.

        :param client: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Trim the arguments
        for argument in args:
            args[argument] = args[argument].strip()

        # Retrieve arguments and prepare query data
        params = get_common_arguments(args)

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_TRACKERS'], params=params)

        total_records = resp.get('totalRecords', 0)
        if total_records == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('tracker(s)')

        results = resp.get('results', [])

        # Creating entry context
        command_results, custom_ec = get_host_attribute_context_data(results)

        # Creating human-readable
        hr = get_trackers_hr(results)

        command_results.insert(0, CommandResults(
            outputs_prefix='PassiveTotal.Tracker',
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp,
        ))

        return command_results


    @logger
    def ssl_cert_search_command(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Retrieve SSL certificates based on various field and its value.

        :param client: client object.
        :param args: Demisto argument(s) provided by the user.
        :return: standard command result
        """
        # Retrieve arguments
        field: str = args.get('field', '')
        query: str = args.get('query', '')

        # Building url
        url_suffix: str = URL_SUFFIX['SSL_CERT_SEARCH']

        # Prepare query data
        request_data: Dict[str, Any] = {
            'field': field,
            'query': query
        }

        # http call
        resp: Dict[str, Any] = client.http_request("GET", url_suffix, request_data)

        results: List[Dict[str, Any]] = resp.get('results', [])
        if len(results) <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('SSL certificate(s)')

        # Creating entry context
        custom_ec = createContext(results, removeNull=True)

        # Creating human-readable
        hr = get_ssl_cert_search_hr(results)

        return CommandResults(
            outputs_prefix='PassiveTotal.SSL',
            outputs_key_field='sha1',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp
        )


    @logger
    def get_pdns_details_command(client: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Retrieve passive DNS details based on ip or host.

        :param client: client object.
        :param args: Demisto argument(s) provided by the user.
        :return: standard command result
        """
        # Retrieve arguments
        params = get_common_arguments(args)
        params['timeout'] = args.get('timeout', 7)

        # http call
        resp = client.http_request("GET", url_suffix=URL_SUFFIX['GET_PDNS_DETAILS'], params=params)
        total_record = resp.get('totalRecords', 0)
        if total_record <= 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('PDNS Record(s)')

        # Creating entry context
        results = resp.get('results', [])
        custom_ec = createContext(results, removeNull=True)
        command_results = create_pdns_standard_context(results)

        # Creating human-readable
        hr = get_pdns_details_hr(results, total_record)

        # Building custom output path
        output_path = 'PassiveTotal.PDNS(val.{0} == obj.{0} && val.{1} == obj.{1} && val.{2} == obj.{2})' \
            .format('resolve', 'recordType', 'resolveType')

        command_results.insert(0, CommandResults(
            outputs_prefix=output_path,
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp
        ))

        return command_results


    @logger
    def get_host_pairs_command(client: Client, args: Dict[str, Any]) -> Union[str, CommandResults]:
        """
        Retrieves the host attribute pairs related to a domain or IP address.

        :param client: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Trim the arguments
        for argument in args:
            args[argument] = args[argument].strip()

        # Retrieve arguments and prepare query data
        params = get_common_arguments(args)

        if args.get('direction') not in VALID_DIRECTION_FOR_HOST_PAIRS:
            raise ValueError(MESSAGES['INVALID_DIRECTION_VALUE'])
        params['direction'] = args.get('direction')

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_HOST_PAIRS'], params=params)

        total_records = resp.get('totalRecords', 0)
        if total_records == 0:
            return MESSAGES['NO_RECORDS_FOUND'].format('host pair(s)')

        results = resp.get('results', [])

        # Creating entry context
        custom_ec = createContext(data=results, removeNull=True)

        # Creating human-readable
        hr = get_host_pairs_hr(results)

        return CommandResults(
            outputs_prefix='PassiveTotal.HostPair',
            outputs_key_field='',
            outputs=custom_ec,
            readable_output=hr,
            raw_response=resp
        )


    @logger
    def domain_reputation_command(client_obj: Client, args: Dict[str, Any]) -> Union[str, List[CommandResults]]:
        """
        Reputation command for domain.

        :param client_obj: Client object
        :param args: The command arguments provided by user
        :return: Standard command result or no records found message
        """
        # Retrieve arguments
        domains = argToList(args.get('domain', ''))

        # argument validation
        if len(domains) == 0:
            raise ValueError('domain(s) not specified')

        command_results: List[CommandResults] = []
        custom_domain_context: List[Dict[str, Any]] = []
        domain_responses: List[Dict[str, Any]] = []
        custom_reputation_response = []
        for domain in domains:
            # argument validation
            if domain.strip() == '':
                raise ValueError(MESSAGES['EMPTY_DOMAIN_ARGUMENT'])

            params = {
                'query': domain,
                'field': 'domain'
            }

            # http call
            response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['WHOIS_SEARCH'], params=params)
            reputation_response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX["GET_REPUTATION"],
                                                          params=params)
            hr_response = get_human_readable_for_reputation_command(reputation_response, domain)
            custom_reputation_response.append(hr_response)
            custom_reputation_context = remove_empty_elements(reputation_response)

            domains_response = response.get('results', [])
            if len(domains_response) <= 0:
                continue

            classification = reputation_response.get('classification', '')
            dbot_score = calculate_dbot_score(classification)
            # Creating entry context
            standard_results, custom_context = get_context_for_whois_commands(domains_response, dbot_score)

            # Preparing context data
            command_results.extend(standard_results)
            custom_context.append(custom_reputation_context)
            final_context = {k: v for x in custom_context for k, v in x.items()}
            custom_domain_context.append(final_context)

            domain_responses += domains_response

        # Creating human-readable
        domain_standard_hr = get_human_readable_for_whois_commands(
            domain_responses,
            is_reputation_command=True
        )

        final_hr = domain_standard_hr
        for x in custom_reputation_response:
            final_hr += x

        command_results.insert(0, CommandResults(
            readable_output=final_hr,
            outputs_prefix='PassiveTotal.Domain',
            outputs_key_field='domain',
            outputs=custom_domain_context
        ))

        return command_results


    @logger
    def get_services_command(client: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the services for the specified IP address.

        :param client: Client object.
        :param args: The command arguments provided by user.
        :return: Standard command result or no records found message.
        """

        # Trim the argument and remove ' quotes surrounding ip
        ip = args['ip'].strip().strip("'")

        # Checking whether ip is valid or not
        if not is_ip_valid(ip, accept_v6_ips=True):
            raise ValueError(MESSAGES['INVALID_IP'])

        # http call
        resp = client.http_request(method="GET", url_suffix=URL_SUFFIX['GET_SERVICES'], params={'query': ip})

        total_records = resp.get('totalRecords', 0)

        if total_records == 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('services'))

        results = [{**response, 'ip': ip} for response in resp.get('results', [])]

        # Creating context
        context_output = remove_empty_elements(results)

        # Creating human-readable
        hr = get_services_hr(total_records, results)

        return CommandResults(
            outputs_prefix='PassiveTotal.Service',
            outputs_key_field=['ip', 'portNumber'],
            outputs=context_output,
            readable_output=hr,
            raw_response=resp,
        )


    @logger
    def pt_get_whois_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets WHOIS information records based on queries

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-get-whois
        :return: command output
        """
        # Retrieve arguments
        query, history = get_valid_get_whois_arguments(args)
        params = {
            'query': query,
            'history': history
        }

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['WHOIS_GET'], params=params)

        domains = response.get('results', [])
        if len(domains) <= 0 and 'domain' in response:
            domains = [response]

        if len(domains) <= 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('domain information'))

        # Creating entry context
        custom_context = get_context_for_get_whois_commands(domains)

        # Creating human-readable
        hr = get_human_readable_for_whois_commands(domains)

        return CommandResults(
            outputs_prefix='PassiveTotal.WHOIS',
            outputs_key_field=['domain', 'lastLoadedAt'],
            outputs=custom_context,
            readable_output=hr,
            raw_response=response
        )


    @logger
    def get_cookies_command(client: Client, args: Dict[str, str]) -> Union[str, CommandResults]:
        """
        Retrieve cookies with hostnames or addresses based on cookie name or cookie domain.

        :param client: Client object
        :param args: The command arguments provided by user

        :return: Standard command result or no records found message
        """

        default_values = {
            'page': "0",
            'sort': "last seen",
            'order': 'desc'
        }
        # Trim the arguments and fill empty optional args with default values
        for argument in args:
            args[argument] = args[argument].strip()
            if not args[argument] and argument in list(default_values.keys()):
                args[argument] = default_values[argument]

        # Validate arguments
        validate_get_cookies_arguments(args)

        # Prepare params for http request
        params = {
            "page": args.get("page"),
            "sort": 'lastSeen' if args.get("sort") == "last seen" else 'firstSeen',
            "order": args.get("order")
        }

        # Prepare the url suffix as per search_by and query argument
        url_suffix = URL_SUFFIX["_".join(args["search_by"].upper().split())].format(args["query"])

        # Make the http request
        resp = client.http_request(method="GET", url_suffix=url_suffix, params=params)

        # Get results from response
        results = resp.get("results", [])

        # Get total records from response
        total_records = resp.get("totalRecords", 0)
        # return standard no records found message on empty results
        if len(results) <= 0:
            return 'Total Record(s): ' + str(total_records) + '\n' + MESSAGES['NO_RECORDS_FOUND'].format('cookies')

        # creating entry context
        entry_context = createContext(results, removeNull=True)

        # create human readable by providing it results and the first column header name
        human_readable = get_cookies_hr(results, "Hostname" if "hosts" in url_suffix else "IP Address", total_records)

        # return CommandResults objects
        return CommandResults(
            outputs_prefix="PassiveTotal.Cookie",
            outputs_key_field=['hostname', 'cookieName', 'cookieDomain'],
            outputs=entry_context,
            readable_output=human_readable,
            raw_response=resp
        )


    @logger
    def pt_get_articles_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets an article information based on queries

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-get-articles
        :return: command output
        """
        # Retrieve arguments
        query = args.get('query', '').strip()
        article_type = args.get('type', '').strip()
        if query == '':
            raise ValueError(MESSAGES['EMPTY_GET_WHOIS_ARGUMENT'])

        params = {
            'query': query
        }

        if article_type != '':
            params['type'] = article_type

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['GET_ARTICLES'], params=params)

        articles = response.get('articles', [])

        if not articles or len(articles) <= 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('articles'))

        # Creating entry context
        custom_ec_for_articles = remove_empty_elements(articles)

        # Creating human-readable
        hr = get_human_readable_for_articles_commands(articles)

        return CommandResults(
            outputs_prefix='PassiveTotal.Article',
            outputs_key_field='guid',
            outputs=custom_ec_for_articles,
            readable_output=hr,
            raw_response=response
        )


    @logger
    def get_data_card_summary_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves a summary data card associated with the given query.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-data-card-get
        :return: command output
        """
        # Retrieve arguments
        query = args.get('query', '').strip()
        if not query:
            raise ValueError(MESSAGES["REQUIRED_ARGUMENT"].format("query"))

        params = {
            'query': query
        }

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['GET_DATA_CARD_SUMMARY'], params=params)
        context_data = remove_empty_elements(response)
        hr_response = get_human_readable_for_data_card_command(response)

        return CommandResults(
            outputs_prefix='PassiveTotal.DataCard',
            outputs_key_field='name',
            outputs=context_data,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def get_reputation_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Gets reputation for a given domain, host or IP.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-reputation-get
        :return: command output
        """
        # Retrieve arguments
        query = args.get('query', '').strip()

        if not query:
            raise ValueError(MESSAGES["REQUIRED_ARGUMENT"].format("query"))

        params = {
            'query': query
        }

        # http call
        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX["GET_REPUTATION"], params=params)
        context_data = remove_empty_elements(response)
        context_data['query'] = query
        hr_response = get_human_readable_for_reputation_command(response, query)

        return CommandResults(
            outputs_prefix='PassiveTotal.Reputation',
            outputs_key_field='query',
            outputs=context_data,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def ip_reputation_command(client_obj: Client, args: Dict[str, Any]) -> List[CommandResults]:
        """
        Reputation command for IP.

        :param client_obj: Client object
        :param args: The command arguments provided by user
        :return: Standard command result
        """
        # Retrieve arguments
        ips = args.get('ip', '')
        ips = argToList(",".join([x.strip() for x in ips.split(",") if x.strip()]))

        # argument validation
        if len(ips) == 0:
            raise ValueError(MESSAGES["EMPTY_IP_ARGUMENT"])

        command_results: List[CommandResults] = []

        for ip in ips:
            if not is_ip_valid(ip, True):
                raise ValueError(MESSAGES["INVALID_IP_ARGUMENT"].format(ip))
            params = {
                'query': ip,
            }
            # http call
            response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX["GET_REPUTATION"], params=params)

            classification = response.get('classification', '')
            dbot_score = calculate_dbot_score(classification)
            standard_context = get_standard_context(dbot_score, ip)

            context_data = remove_empty_elements(response)
            context_data['query'] = ip

            human_readable = get_human_readable_for_reputation_command(response, ip)

            command_results.append(CommandResults(
                readable_output=human_readable,
                outputs_prefix='PassiveTotal.IP',
                outputs_key_field='query',
                outputs=context_data,
                indicator=standard_context
            ))
        return command_results


    @logger
    def get_intel_profile_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the list of all profiles.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-intel-profiles
        :return: command output
        """
        # Retrieve arguments
        params, page_size = validate_list_intel_profile_args(args)

        profile_id = args.get("id")

        if profile_id:
            url_suffix = f'{URL_SUFFIX["LIST_INTEL_PROFILE"]}/{profile_id}'

        elif args.get("indicator_value"):
            url_suffix = URL_SUFFIX["LIST_INTEL_PROFILE_BY_INDICATOR"]

        else:
            url_suffix = URL_SUFFIX["LIST_INTEL_PROFILE"]

        # http call
        response = client_obj.http_request(method='GET', url_suffix=url_suffix, params=params)

        if profile_id:
            profiles = [response]
        else:
            profiles = response.get("results", [])

        if not profiles:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format("profiles"))

        profiles = profiles[:page_size]
        context_data = remove_empty_elements_for_context(profiles)

        hr_response = get_human_readable_for_intel_profile_command(profiles)

        return CommandResults(
            outputs_prefix='PassiveTotal.IntelProfile',
            outputs_key_field='id',
            outputs=context_data,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_intel_profile_indicators_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the indicators for the given profile.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-intel-profile-indicator
        :return: command output
        """
        profile_id, params = validate_list_intel_profile_indicators_args(args)

        response = client_obj.http_request(method='GET',
                                           url_suffix=URL_SUFFIX['LIST_INTEL_PROFILE_INDICATOR'].format(profile_id),
                                           params=params)
        indicators = response.get('results', [])
        if not indicators or len(indicators) <= 0:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('indicators'))

        for indicator in indicators:
            del indicator['profileId']

        context_data = {'indicator': remove_empty_elements(indicators), 'id': profile_id}
        hr_response = get_human_readable_for_intel_profile_indicator_command(response)

        return CommandResults(
            outputs_prefix='PassiveTotal.IntelProfile',
            outputs_key_field='id',
            outputs=context_data,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_my_asi_insights_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface insight information of the individual's account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-my-attack-surface-insights
        :return: command output
        """
        priority_level, page_size = validate_list_my_asi_insights_args(args)

        url_suffix = f'{URL_SUFFIX["LIST_ASI_INSIGHTS"]}/{priority_level}'

        response = client_obj.http_request(method='GET', url_suffix=url_suffix)

        insights = response.get('insights', [])
        response['insights'] = insights[:page_size]
        context_data = prepare_context_for_my_asi_insights(response, priority_level)
        summary = {
            "name": "pt-list-my-attack-surface-insights",
            "activeInsightCount": response.get("activeInsightCount", ''),
            "totalInsightCount": response.get("totalInsightCount", ''),
            "totalObservations": response.get("totalObservations", '')

        }
        outputs = {
            "PassiveTotal.Insight(val.priorityLevel == obj.priorityLevel)": context_data,
            "PassiveTotal.Summary.Insight(val.name == obj.name)": summary
        }

        hr_response = get_human_readable_for_my_asi_insights_command(context_data, priority_level,
                                                                     summary['activeInsightCount'],
                                                                     summary['totalInsightCount'],
                                                                     summary['totalObservations'])
        outputs = remove_empty_elements_for_context(outputs)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_third_party_asi_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface observations by severity level for the given third-party account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-third-party-attack-surface
        :return: command output
        """
        params = validate_page_and_size_args(args)

        vendor_id = arg_to_number(args.get('id'))

        url_suffix = URL_SUFFIX['LIST_THIRD_PARTY_ASI']
        if vendor_id:
            url_suffix = f"{URL_SUFFIX['LIST_THIRD_PARTY_ASI']}/{vendor_id}"
            params = {}

        response = client_obj.http_request(method='GET', url_suffix=url_suffix, params=params)

        if vendor_id:
            context_data = [remove_empty_elements(response)]
        else:
            context_data = remove_empty_elements(response.get('vendors', []))

        hr_response = get_human_readable_for_attack_surface_command(context_data)

        for data in context_data:
            data['priority'] = data.pop('priorities')

        summary = {
            "name": "pt-list-third-party-attack-surface",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.ThirdParty(val.id == obj.id)": context_data,
            "PassiveTotal.Summary.ThirdPartyASI(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_my_attack_surfaces_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface information of the individual's account.

        :param client_obj: client object which is used to get response from API
        :param args: It contain arguments of pt-list-my-attack-surfaces
        :return: command output
        """
        page_size = validate_page_size_args(args)

        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX['LIST_ATTACK_SURFACE'])
        if isinstance(response, dict):
            response = [response]  # type: ignore

        response = response[:page_size]  # type: ignore
        context_data = remove_empty_elements_for_context(response)
        for data in context_data:
            data['priority'] = data.pop('priorities')

        hr_response = get_human_readable_for_attack_surface_command(response)  # type: ignore

        return CommandResults(
            outputs_prefix='PassiveTotal.AttackSurface',
            outputs_key_field='id',
            outputs=context_data,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_third_party_asi_insights_command(client_obj: Client, args: Dict[str, Any]):
        """
        Retrieves the attack surface insight information of the given third-party account.

        :param client_obj: client object which is used to get response from API
        :param args: It contain arguments of pt-list-third-party-attack-surface-insights
        :return: command output
        """
        vendor_id = arg_to_number(args.get("id", ''))
        if not vendor_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('id'))

        priority, page_size = validate_list_my_asi_insights_args(args)

        url_suffix = URL_SUFFIX['THIRD_PARTY_ASI_INSIGHTS'].format(vendor_id, priority)
        response = client_obj.http_request(method='GET', url_suffix=url_suffix)

        insights = response.get('insights', [])
        response['insights'] = insights[:page_size]

        context_data_out = prepare_context_for_my_asi_insights(response, priority)
        context_data_out.pop("priorityLevel")
        context_data = {
            "Insight": context_data_out,
            "id": vendor_id,
            "priorityLevel": priority
        }

        summary = {
            "name": "pt-list-third-party-attack-surface-insights",
            "activeInsightCount": response.get("activeInsightCount", ''),
            "totalInsightCount": response.get("totalInsightCount", ''),
            "totalObservations": response.get("totalObservations", '')
        }
        outputs = {
            "PassiveTotal.ThirdParty(val.id == obj.id)": context_data,
            "PassiveTotal.Summary.ThirdPartyInsight(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        hr_response = get_human_readable_for_my_asi_insights_command(context_data["Insight"], priority,  # type:ignore
                                                                     summary['activeInsightCount'],
                                                                     summary['totalInsightCount'],
                                                                     summary['totalObservations'])

        return CommandResults(
            outputs=outputs,
            raw_response=response,
            readable_output=hr_response
        )


    @logger
    def list_my_asi_assets_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface asset information of the individual's account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-attack-surface-assets
        :return: command output
        """
        insight_id, params = validate_list_my_asi_assets_args(args)

        url_suffix = f'{URL_SUFFIX["LIST_ASI_ASSETS"]}/{insight_id}'

        response = client_obj.http_request(method='GET', url_suffix=url_suffix, params=params)

        context_data = {
            "asset": response.get("assets", []),
            "insightId": insight_id,
            "segmentBy": params["segmentBy"]}

        summary = {
            "name": "pt-list-my-attack-surface-assets",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.Asset(val.insightId == obj.insightId && val.segmentBy == obj.segmentBy)": context_data,
            "PassiveTotal.Summary.Asset(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        hr_response = get_human_readable_for_my_asi_assets_command(response)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_my_asi_vulnerable_components_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface vulnerable component information of the individual's account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-my-attack-surface-vulnerable-components
        :return: command output
        """
        params = validate_page_and_size_args(args)

        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX["LIST_ASI_VULNERABLE_COMPONENTS"],
                                           params=params)

        result = response.get("vulnerableComponents")
        if not result:
            return CommandResults(readable_output=MESSAGES["NO_RECORDS_FOUND"].format("vulnerable components"))

        summary = {
            "name": "pt-list-my-attack-surface-vulnerable-components",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.VulnerableComponent(val.name == obj.name && val.type == obj.type)": result,
            "PassiveTotal.Summary.VulnerableComponent(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)
        hr_response = get_human_readable_for_my_asi_vulnerable_components_command(result)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_my_asi_vulnerabilities_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface vulnerable component information of the individual's account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-my-attack-surface-vulnerabilities
        :return: command output
        """
        params = validate_page_and_size_args(args)

        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX["LIST_ASI_VULNERABILITIES"],
                                           params=params)

        result = response.get("cves")
        if not result:
            return CommandResults(readable_output=MESSAGES["NO_RECORDS_FOUND"].format("vulnerabilities"))

        summary = {
            "name": "pt-list-my-attack-surface-vulnerabilities",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.Vulnerability(val.cveId == obj.cveId)": result,
            "PassiveTotal.Summary.Vulnerability(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)
        hr_response = get_human_readable_for_my_asi_vulnerabilities_command(result)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_third_party_asi_vulnerable_components_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface vulnerable component information of the given third-party account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-third-party-attack-surface-vulnerable-components
        :return: command output
        """
        vendor_id = arg_to_number(args.get("id", ''))
        if not vendor_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('id'))

        params = validate_page_and_size_args(args)

        response = client_obj.http_request(method='GET',
                                           url_suffix=URL_SUFFIX["LIST_THIRD_PARTY_ASI_VULNERABLE_COMPONENTS"].format(
                                               vendor_id),
                                           params=params)

        result = response.get("vulnerableComponents")
        if not result:
            return CommandResults(readable_output=MESSAGES["NO_RECORDS_FOUND"].format("third party vulnerable components"))

        context_data = {
            "id": vendor_id,
            "VulnerableComponent": result
        }

        summary = {
            "name": "pt-list-third-party-attack-surface-vulnerable-components",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.ThirdParty(val.id == obj.id)": context_data,
            "PassiveTotal.Summary.ThirdPartyVulnerableComponent(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        hr_response = get_human_readable_for_my_asi_vulnerable_components_command(result)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_my_asi_observations_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface vulnerability observation information of the individual's account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-my-attack-surface-observations
        :return: command output
        """
        cve_id = args.get("cve_id")
        if not cve_id:
            raise ValueError(MESSAGES["REQUIRED_ARGUMENT"].format("cve_id"))

        params = validate_page_and_size_args(args)

        response = client_obj.http_request(method='GET', url_suffix=URL_SUFFIX["LIST_ASI_OBSERVATIONS"].format(cve_id),
                                           params=params)
        result = response.get("assets")
        if not result:
            return CommandResults(readable_output=MESSAGES["NO_RECORDS_FOUND"].format("observations"))

        summary = {
            "name": "pt-list-my-attack-surface-observations",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        result = {
            "cveId": response.get("cveId", ''),
            "cwe": response.get("cwes", []),
            "asset": response.get("assets", [])
        }
        outputs = {
            "PassiveTotal.Observation(val.cveId == obj.cveId)": result,
            "PassiveTotal.Summary.Observation(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)
        hr_response = get_human_readable_for_my_asi_observations_command(response)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_third_party_asi_assets_command(client_obj: Client, args: Dict[str, Any]):
        """
        Retrieves the attack surface asset information of the given third-party account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-third-party-attack-surface-assets
        :return: command output
        """
        vendor_id = arg_to_number(args.get("vendor_id", ''))
        if not vendor_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('vendor_id'))

        insight_id, params = validate_list_my_asi_assets_args(args)

        response = client_obj.http_request(method='GET',
                                           url_suffix=URL_SUFFIX["LIST_THIRD_PARTY_ASI_ASSETS"].format(vendor_id,
                                                                                                       insight_id),
                                           params=params)

        context_data = {
            "id": vendor_id,
            "InsightAsset": {
                "asset": response.get("assets", []),
                "insightId": insight_id,
                "segmentBy": params["segmentBy"]
            }
        }

        summary = {
            "name": "pt-list-third-party-attack-surface-assets",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.ThirdParty(val.id == obj.id)": context_data,
            "PassiveTotal.Summary.ThirdPartyInsightAsset(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        hr_response = get_human_readable_for_my_asi_assets_command(response)

        return CommandResults(
            outputs=outputs,
            raw_response=response,
            readable_output=hr_response
        )


    @logger
    def list_third_party_asi_observations_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface vulnerability observation information of the given third-party account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-third-party-attack-surface-observations
        :return: command output
        """
        vendor_id = arg_to_number(args.get("id", ''))
        if not vendor_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('id'))

        cve_id = args.get("cve_id")
        if not cve_id:
            raise ValueError(MESSAGES["REQUIRED_ARGUMENT"].format("cve_id"))

        params = validate_page_and_size_args(args)

        response = client_obj.http_request(method='GET',
                                           url_suffix=URL_SUFFIX["LIST_THIRD_PARTY_ASI_OBSERVATIONS"].format(vendor_id,
                                                                                                             cve_id),
                                           params=params)

        result = response.get("assets")
        if not result:
            return CommandResults(readable_output=MESSAGES["NO_RECORDS_FOUND"].format("third party observations"))

        # prepare context
        summary = {
            "name": "pt-list-third-party-attack-surface-observations",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        result = {
            "id": vendor_id,
            "Observation": {
                "cveId": response.get("cveId", ''),
                "cwe": response.get("cwes", []),
                "asset": response.get("assets", [])
            }
        }
        outputs = {
            "PassiveTotal.ThirdParty(val.id == obj.id)": result,
            "PassiveTotal.Summary.ThirdPartyObservation(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        hr_response = get_human_readable_for_my_asi_observations_command(response)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    @logger
    def list_third_party_attack_surface_vulnerabilities_command(client_obj: Client, args: Dict[str, Any]) -> CommandResults:
        """
        Retrieves the attack surface vulnerability information of the given third party account.

        :param client_obj: client object which is used to get response from API
        :param args: it contain arguments of pt-list-third-party-attack-surface-vulnerabilities
        :return: command output
        """
        vendor_id = arg_to_number(args.get("id", ''))
        if not vendor_id:
            raise ValueError(MESSAGES['REQUIRED_ARGUMENT'].format('id'))

        params = validate_page_and_size_args(args)

        response = client_obj.http_request(method='GET',
                                           url_suffix=URL_SUFFIX["LIST_THIRD_PARTY_ASI_VULNERABILITIES"].format(
                                               vendor_id),
                                           params=params)

        result = response.get("cves")
        if not result:
            return CommandResults(readable_output=MESSAGES["NO_RECORDS_FOUND"].format("third party vulnerabilities"))

        context_data = {
            "id": vendor_id,
            "Vulnerability": result
        }

        summary = {
            "name": "pt-list-third-party-attack-surface-vulnerabilities",
            "totalCount": response.get("totalCount", ''),
            "totalPages": response.get("totalPages", ''),
            "nextPage": response.get("nextPage", '')

        }
        outputs = {
            "PassiveTotal.ThirdParty(val.id == obj.id)": context_data,
            "PassiveTotal.Summary.ThirdPartyVulnerability(val.name == obj.name)": summary
        }
        outputs = remove_empty_elements_for_context(outputs)

        hr_response = get_human_readable_for_my_asi_vulnerabilities_command(result)

        return CommandResults(
            outputs=outputs,
            readable_output=hr_response,
            raw_response=response
        )


    def main() -> None:
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # Commands dict
        commands = {
            'pt-ssl-cert-search': ssl_cert_search_command,
            'pt-get-pdns-details': get_pdns_details_command,
            'pt-whois-search': pt_whois_search_command,
            'pt-get-components': get_components_command,
            'pt-get-trackers': get_trackers_command,
            'pt-get-host-pairs': get_host_pairs_command,
            'pt-get-services': get_services_command,
            'domain': domain_reputation_command,
            'pt-get-whois': pt_get_whois_command,
            'pt-get-cookies': get_cookies_command,
            'pt-get-articles': pt_get_articles_command,
            'pt-get-data-card': get_data_card_summary_command,
            'pt-get-reputation': get_reputation_command,
            'ip': ip_reputation_command,
            'pt-list-intel-profiles': get_intel_profile_command,
            'pt-list-intel-profile-indicators': list_intel_profile_indicators_command,
            'pt-list-third-party-attack-surface': list_third_party_asi_command,
            'pt-list-my-attack-surface-insights': list_my_asi_insights_command,
            'pt-list-third-party-attack-surface-insights': list_third_party_asi_insights_command,
            'pt-list-my-attack-surface-assets': list_my_asi_assets_command,
            'pt-list-my-attack-surface-vulnerable-components': list_my_asi_vulnerable_components_command,
            'pt-list-my-attack-surface-vulnerabilities': list_my_asi_vulnerabilities_command,
            'pt-list-my-attack-surface-observations': list_my_asi_observations_command,
            'pt-list-third-party-attack-surface-assets': list_third_party_asi_assets_command,
            'pt-list-third-party-attack-surface-vulnerable-components': list_third_party_asi_vulnerable_components_command,
            'pt-list-third-party-attack-surface-vulnerabilities': list_third_party_attack_surface_vulnerabilities_command,
            'pt-list-third-party-attack-surface-observations': list_third_party_asi_observations_command,
            'pt-list-my-attack-surfaces': list_my_attack_surfaces_command
        }

        command = demisto.command()
        demisto.debug(f'Command being called is {command}')
        try:
            # Retrieve XSOAR params
            base_url = demisto.params().get('url')
            username = demisto.params().get('username')
            secret = demisto.params().get('secret')
            verify_certificate = not demisto.params().get('insecure', False)
            proxy = demisto.params().get('proxy', False)
            request_timeout = get_request_timeout()

            # prepare client class object
            client = Client(base_url=base_url, request_timeout=request_timeout, verify=verify_certificate, proxy=proxy,
                            auth=(username, secret))

            # This is the call made when pressing the integration Test button.
            if demisto.command() == 'test-module':
                result = test_function(client)
                demisto.results(result)

            elif command in commands:
                args = {key: value.strip() for key, value in demisto.args().items()}
                return_results(commands[command](client, args))

        # Log exceptions
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Error: {str(e)}')


    def init():
        if __name__ in ('__main__', '__builtin__', 'builtins'):
            main()


    init()

    register_module_line('PassiveTotal v2', 'end', __line__())
  subtype: python3
  type: python
system: true
