category: Data Enrichment & Threat Intelligence
commonfields:
  id: Flashpoint
  version: -1
configuration:
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- additionalinfo: Server URL to connect to Flashpoint.
  defaultvalue: https://fp.tools
  display: Server URL
  name: url
  required: true
  type: 0
- display: API Key
  name: api_key
  required: true
  type: 4
- additionalinfo: The maximum limit is 100 for alerts and 1000 for compromised credentials.
  defaultvalue: "15"
  display: Maximum number of incidents per fetch
  name: max_fetch
  required: false
  type: 0
- additionalinfo: 'Date or relative timestamp to start fetching the incidents from.
    (Formats accepted: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd,
    yyyy-mm-ddTHH:MM:SSZ, etc).'
  defaultvalue: 3 days
  display: First fetch time interval
  name: first_fetch
  required: false
  type: 0
- additionalinfo: Whether to fetch the Flashpoint alerts or the compromised credentials.
    Would choose "Compromised Credentials" if nothing selected.
  defaultvalue: Compromised Credentials
  display: Fetch Type
  name: fetch_type
  options:
  - Compromised Credentials
  - Alerts
  required: false
  type: 15
- additionalinfo: Adds the 'is_fresh' flag to compromised credential queries so it
    only ingests username/password combinations if they haven't been seen before.
  defaultvalue: "true"
  display: Fetch fresh compromised credentials alerts
  name: is_fresh_compromised_credentials
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: Create relationships between indicators as part of Enrichment.
  defaultvalue: "true"
  display: Create relationships
  name: create_relationships
  required: false
  type: 8
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.3.3
    packID: Flashpoint
    packName: Flashpoint
    packPropagationLabels:
    - all
    propagationLabels: []
    toServerVersion: ""
description: Use the Flashpoint integration to reduce business risk. Flashpoint allows
  users to ingest alerts and compromised credentials as incident alerts and executes
  commands such as search intelligence report, ip, url, get events, and more.
detaileddescription: "### Partner Contributed Integration\n#### Integration Author:
  Flashpoint\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email**: [demisto_support@flashpoint-intel.com](mailto:demisto_support@flashpoint-intel.com)\n***\nConfigure
  an API account on Flashpoint\n-------------------------------\n - Login/Register
  at [Flashpoint](https://fp.tools/) platform. \n - Navigate to API & Integrations
  and select the **Manage API Tokens**.\n - Click on \"GENERATE TOKEN\" button and
  enter the required details to generate\n    token. (i.e- token label,username and
  password)\n - Click on GENERATE button once all required data are entered.\n\n\nAn
  integration instance contains the compromised credential playbook, IOC & report
  lookup commands and either Automated Keyword Alert ingestion or Compromised Credential
  ingestion.  If your Flashpoint subscription does not include Compromised Credentials,
  just follow the instructions below for creating Flashpoint Alerts integration.  \n**Please
  Note:** If you want Flashpoint Alerts and Compromised Credentials, you will need
  to create two integration instances, one for each setting.\n\n### Recommended settings
  for Compromised Credentials fetch:\n\nIn order to fetch compromised credentials
  alerts from Flashpoint, you need to enable the Fetch Incident. Fill out the required
  fields along with the below-recommended settings:\n\n- Enable \"Fetches incidents\"
  option.\n- Choose option \"Flashpoint Compromised Credentials\" for setting \"Incident
  type (if classifier doesn't exist)\".\n- Choose option \"Flashpoint Compromised
  Credentials - Incoming Mapper\" for setting \"Mapper (incoming)\".\n- To get the
  number of incidents per minute you can set max 1000 for setting \"Maximum number
  of incidents per fetch\".\n- Choose option \"Compromised Credentials\" for setting
  \"Fetch Type\".\n\n### Recommended settings for Flashpoint Alerts fetch:\n\nIn order
  to fetch Flashpoint alerts, you need to enable the Fetch Incident. Fill out the
  required fields along with below-recommended settings:\n\n- Enable \"Fetches incidents\"
  option.\n- Choose option \"Flashpoint Alerts\" for setting \"Incident type (if classifier
  doesn't exist)\".\n- Choose option \"Flashpoint Alerts - Incoming Mapper\" for setting
  \"Mapper (incoming)\".\n- To get the number of incidents per minute you can set
  max 100 for setting \"Maximum number of incidents per fetch\".\n- Choose option
  \"Alerts\" for setting \"Fetch Type\".\n\n\nIf you don't want to enable alert or
  credential handling, create an integration instance with the appropriate settings
  described below.\n### Recommended settings for integration instance without fetch
  incident capability:\n\n- Click on \"Add instance\".\n- By default, \"Do not fetch\"
  option would be selected.\n- Add \"API Key\" and save the instance.\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/flashpoint)"
display: Flashpoint (Partner Contribution)
image: data:image/png;base64,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
name: Flashpoint
script:
  commands:
  - arguments:
    - default: true
      description: The IP address to check.
      isArray: true
      name: ip
    description: Looks up details of an IP indicator. The reputation of the IP address
      is considered malicious if there's at least one IOC event in the Flashpoint
      database that matches the IP indicator. Alternatively, the IP address is considered
      suspicious if it matches any one of the Torrent's Peer IP Address or Forum Visit's
      Peer IP Address.
    name: ip
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: IP.Address
      description: The IP address.
      type: string
    - contextPath: IP.Malicious.Description
      description: The description of the malicious indicator.
      type: string
    - contextPath: IP.Malicious.Vendor
      description: The vendor used to calculate the severity of the IP address.
      type: string
    - contextPath: Flashpoint.IP.Event.Href
      description: A list of reference links of the indicator.
      type: string
    - contextPath: Flashpoint.IP.Event.Address
      description: The IP address of the indicator.
      type: string
    - contextPath: Flashpoint.IP.Event.EventDetails
      description: The event details in which the indicator was observed.
      type: string
    - contextPath: Flashpoint.IP.Event.Category
      description: The category of the indicator.
      type: string
    - contextPath: Flashpoint.IP.Event.Fpid
      description: The Flashpoint ID of the indicator.
      type: string
    - contextPath: Flashpoint.IP.Event.Timestamp
      description: The time and date that the indicator was observed.
      type: string
    - contextPath: Flashpoint.IP.Event.Type
      description: The indicator type.
      type: string
    - contextPath: Flashpoint.IP.Event.Uuid
      description: The UUID of the indicator.
      type: string
    - contextPath: Flashpoint.IP.Event.Comment
      description: The comment that was provided when the indicator was observed.
      type: string
    - contextPath: IP.Relationships.EntityA
      description: The source of the relationship.
      type: string
    - contextPath: IP.Relationships.EntityB
      description: The destination of the relationship.
      type: string
    - contextPath: IP.Relationships.Relationship
      description: The name of the relationship.
      type: string
    - contextPath: IP.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: string
    - contextPath: IP.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: string
  - arguments:
    - default: true
      description: The domain name to check.
      isArray: true
      name: domain
    description: Lookup the "Domain" type indicator details. The reputation of Domain
      is considered Malicious if there's at least one IOC event in Flashpoint database
      matching the Domain indicator.
    name: domain
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: Flashpoint.Domain.Event.Href
      description: A list of reference links of the indicator.
      type: string
    - contextPath: Flashpoint.Domain.Event.Domain
      description: The domain of the indicator.
      type: string
    - contextPath: Flashpoint.Domain.Event.EventDetails
      description: The event details in which the indicator was observed.
      type: string
    - contextPath: Flashpoint.Domain.Event.Category
      description: The category of the indicator.
      type: string
    - contextPath: Flashpoint.Domain.Event.Fpid
      description: The Flashpoint ID of the indicator.
      type: string
    - contextPath: Flashpoint.Domain.Event.Timestamp
      description: The time and date that the indicator was observed.
      type: string
    - contextPath: Flashpoint.Domain.Event.Type
      description: The indicator type.
      type: string
    - contextPath: Flashpoint.Domain.Event.Uuid
      description: The UUID of the indicator.
      type: string
    - contextPath: Flashpoint.Domain.Event.Comment
      description: The comment that was provided when the indicator was observed.
      type: string
    - contextPath: Domain.Malicious.Description
      description: The description of the malicious indicator.
      type: string
    - contextPath: Domain.Malicious.Vendor
      description: Vendor of malicious indicator.
      type: string
    - contextPath: Domain.Name
      description: Name of domain.
      type: string
    - contextPath: Domain.Relationships.EntityA
      description: The source of the relationship.
      type: string
    - contextPath: Domain.Relationships.EntityB
      description: The destination of the relationship.
      type: string
    - contextPath: Domain.Relationships.Relationship
      description: The name of the relationship.
      type: string
    - contextPath: Domain.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: string
    - contextPath: Domain.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: string
  - arguments:
    - default: true
      description: The file name to check.
      isArray: true
      name: filename
    description: Lookup the "Filename" type indicator details. The reputation of Filename
      is considered Malicious if there's at least one IOC event in Flashpoint database
      matching the Filename indicator.
    name: filename
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: Flashpoint.Filename.Event.Href
      description: A list of reference links of the indicator.
      type: string
    - contextPath: Flashpoint.Filename.Event.Filename
      description: Filename of the indicator
      type: string
    - contextPath: Flashpoint.Filename.Event.EventDetails
      description: The event details in which the indicator was observed.
      type: string
    - contextPath: Flashpoint.Filename.Event.Category
      description: The category of the indicator.
      type: string
    - contextPath: Flashpoint.Filename.Event.Fpid
      description: The Flashpoint ID of the indicator.
      type: string
    - contextPath: Flashpoint.Filename.Event.Timestamp
      description: The time and date that the indicator was observed.
      type: string
    - contextPath: Flashpoint.Filename.Event.Type
      description: The indicator type.
      type: string
    - contextPath: Flashpoint.Filename.Event.Uuid
      description: The UUID of the indicator.
      type: string
    - contextPath: Flashpoint.Filename.Event.Comment
      description: The comment that was provided when the indicator was observed.
      type: string
  - arguments:
    - default: true
      description: The url to check.
      isArray: true
      name: url
    description: Lookup the "URL" type indicator details. The reputation of Url is
      considered Malicious if there's at least one IOC event in Flashpoint database
      matching the Url indicator.
    name: url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: Flashpoint.Url.Event.Href
      description: A list of reference links of the indicator.
      type: string
    - contextPath: Flashpoint.Url.Event.Url
      description: Url of the indicator
      type: string
    - contextPath: Flashpoint.Url.Event.EventDetails
      description: The event details in which the indicator was observed.
      type: string
    - contextPath: Flashpoint.Url.Event.Category
      description: The category of the indicator.
      type: string
    - contextPath: Flashpoint.Url.Event.Fpid
      description: The Flashpoint ID of the indicator.
      type: string
    - contextPath: Flashpoint.Url.Event.Timestamp
      description: The time and date that the indicator was observed.
      type: string
    - contextPath: Flashpoint.Url.Event.Type
      description: The indicator type.
      type: string
    - contextPath: Flashpoint.Url.Event.Uuid
      description: The UUID of the indicator.
      type: string
    - contextPath: Flashpoint.Url.Event.Comment
      description: The comment that was provided when the indicator was observed.
      type: string
    - contextPath: URL.Malicious.Description
      description: The description of the malicious indicator.
      type: string
    - contextPath: URL.Malicious.Vendor
      description: Vendor of malicious url.
      type: string
    - contextPath: URL.Data
      description: The URL
      type: string
    - contextPath: URL.Relationships.EntityA
      description: The source of the relationship.
      type: string
    - contextPath: URL.Relationships.EntityB
      description: The destination of the relationship.
      type: string
    - contextPath: URL.Relationships.Relationship
      description: The name of the relationship.
      type: string
    - contextPath: URL.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: string
    - contextPath: URL.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: string
  - arguments:
    - default: true
      description: A list of hashes of the file to query. Supports MD5, SHA1 and SHA256.
      isArray: true
      name: file
    description: Lookup the "File" type indicator details. The reputation of File-hash
      is considered Malicious if there's at least one IOC event in Flashpoint database
      matching the File-hash indicator.
    name: file
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: Flashpoint.File.Event.Href
      description: A list of reference links of the indicator.
      type: string
    - contextPath: Flashpoint.File.Event.MD5
      description: MD5 file hash of the indicator
      type: string
    - contextPath: Flashpoint.File.Event.SHA1
      description: SHA1 file hash of the indicator
      type: string
    - contextPath: Flashpoint.File.Event.SHA256
      description: SHA256 file hash of the indicator
      type: string
    - contextPath: Flashpoint.File.Event.EventDetails
      description: The event details in which the indicator was observed.
      type: string
    - contextPath: Flashpoint.File.Event.Category
      description: The category of the indicator.
      type: string
    - contextPath: Flashpoint.File.Event.Fpid
      description: The Flashpoint ID of the indicator.
      type: string
    - contextPath: Flashpoint.File.Event.Timestamp
      description: The time and date that the indicator was observed.
      type: string
    - contextPath: Flashpoint.File.Event.Type
      description: The indicator type.
      type: string
    - contextPath: Flashpoint.File.Event.Uuid
      description: The UUID of the indicator.
      type: string
    - contextPath: Flashpoint.File.Event.Comment
      description: The comment that was provided when the indicator was observed.
      type: string
    - contextPath: File.Malicious.Description
      description: The description of the malicious indicator.
      type: string
    - contextPath: File.Malicious.Vendor
      description: Vendor of malicious file.
      type: string
    - contextPath: File.MD5
      description: MD5 type file.
      type: string
    - contextPath: File.SHA1
      description: SHA1 type file.
      type: string
    - contextPath: File.SHA256
      description: SHA256 type file.
      type: string
    - contextPath: File.Relationships.EntityA
      description: The source of the relationship.
      type: string
    - contextPath: File.Relationships.EntityB
      description: The destination of the relationship.
      type: string
    - contextPath: File.Relationships.Relationship
      description: The name of the relationship.
      type: string
    - contextPath: File.Relationships.EntityAType
      description: The type of the source of the relationship.
      type: string
    - contextPath: File.Relationships.EntityBType
      description: The type of the destination of the relationship.
      type: string
  - arguments:
    - default: true
      description: The email to check.
      isArray: true
      name: email
    description: Lookup the "Email" type indicator details. The reputation of Email
      is considered Malicious if there's at least one IOC event in Flashpoint database
      matching the Email indicator.
    name: email
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
    - contextPath: Flashpoint.Email.Event.Href
      description: A list of reference links of the indicator.
      type: string
    - contextPath: Flashpoint.Email.Event.EventDetails
      description: The event details in which the indicator was observed.
      type: string
    - contextPath: Flashpoint.Email.Event.Category
      description: The category of the indicator.
      type: string
    - contextPath: Flashpoint.Email.Event.Fpid
      description: The Flashpoint ID of the indicator.
      type: string
    - contextPath: Flashpoint.Email.Event.Timestamp
      description: The time and date that the indicator was observed.
      type: string
    - contextPath: Flashpoint.Email.Event.Type
      description: The indicator type.
      type: string
    - contextPath: Flashpoint.Email.Event.Uuid
      description: The UUID of the indicator.
      type: string
    - contextPath: Flashpoint.Email.Event.Comment
      description: The comment that was provided when the indicator was observed.
      type: string
    - contextPath: Account.Email.Malicious.Description
      description: The description of the malicious indicator.
      type: string
    - contextPath: Account.Email.Malicious.Vendor
      description: Vendor of Malicious email.
      type: string
    - contextPath: Account.Email.Name
      description: Name of indicator.
      type: string
  - arguments:
    - description: Search report using keyword or text
      name: report_search
      required: true
    description: Search for the Intelligence Reports using a keyword
    name: flashpoint-search-intelligence-reports
    outputs:
    - contextPath: Flashpoint.Report
      description: List of reports based on specified search query or keyword
  - arguments:
    - description: The report id of the report for which the details are to be fetched.
        The report id can be known from output context path (Flashpoint.Report.ReportId)
        of report-search command or some other investigation.
      name: report_id
      required: true
    description: Get single report details using the report id. The report id can
      be known from output context path (Flashpoint.Report.ReportId) of report-search
      command or some other investigation.
    name: flashpoint-get-single-intelligence-report
    outputs:
    - contextPath: Flashpoint.Report.NotifiedAt
      description: Notify date of report.
      type: string
    - contextPath: Flashpoint.Report.PlatformUrl
      description: Platform url of report. It helps to redirect flashpoint platform.
      type: string
    - contextPath: Flashpoint.Report.PostedAt
      description: posted date of report.
      type: number
    - contextPath: Flashpoint.Report.Summary
      description: Summary of report.
      type: string
    - contextPath: Flashpoint.Report.Title
      description: Title of the report.
      type: string
    - contextPath: Flashpoint.Report.UpdatedAt
      description: Last updated date of report.
      type: string
    - contextPath: Flashpoint.Report.ReportId
      description: Unique id of the report.
      type: string
  - arguments:
    - description: The report-id of the report of which the related reports are to
        be fetched. The report id can be known from output context path (Flashpoint.Report.ReportId)
        of report-search command or some other investigation.
      name: report_id
      required: true
    description: Get related reports for a particular report using the report-id.
      The report id can be known from output context path (Flashpoint.Report.ReportId)
      of report-search command or some other investigation.
    name: flashpoint-get-related-reports
    outputs:
    - contextPath: Flashpoint.Report
      description: Display list of related report based on report fpid.
  - arguments:
    - description: The UUID or FPID that identifies a particular event. The event
        id can be fetched from output context path (Flashpoint.Event.EventId) get-events
        command or indicator reputation command response or some other investigation.
      name: event_id
      required: true
    description: Retrieves the details of a single event using event UUID or FPID.
      To retrieve the event id, run the get-events command and see the value under
      the Flashpoint.Event.EventId context path. or indicator reputation command response
      or some other investigation.
    name: flashpoint-get-single-event
    outputs:
    - contextPath: Flashpoint.Event.ObservedTime
      description: The date that the event was triggered.
      type: string
    - contextPath: Flashpoint.Event.EventCreatorEmail
      description: The email address of the event creator.
      type: string
    - contextPath: Flashpoint.Event.Href
      description: The display event reference.
      type: string
    - contextPath: Flashpoint.Event.MalwareDescription
      description: The description of the malware.
      type: string
    - contextPath: Flashpoint.Event.Tags
      description: The display event tags.
    - contextPath: Flashpoint.Event.EventId
      description: The display event ID (event fpid).
      type: string
    - contextPath: Flashpoint.Event.Name
      description: The name of the event.
      type: string
  - arguments:
    - description: The time period for the search.
      name: time_period
    - description: The report fpid. To retrieve the report fpid, run the related-reports
        command.
      name: report_fpid
    - defaultValue: "10"
      description: Specify the limit on the no. of record.
      name: limit
    - description: A comma-separated list of attack IDs for which to search. Attack
        IDs can be found in event information or on the Flashpoint platform by filtering
        events by attack IDs.
      name: attack_ids
    description: Searches for events within the specified time-period, the report
      fpid, or attack IDs.
    name: flashpoint-get-events
    outputs:
    - contextPath: Flashpoint.Event
      description: A list of multiple events.
  - arguments:
    - default: true
      description: The indicator type, for example, domain, ip, email, url, and so
        on.
      isArray: true
      name: indicator
    description: Lookup any type of indicator
    name: flashpoint-common-lookup
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: string
    - contextPath: DBotScore.Score
      description: The actual score.
      type: number
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: string
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: string
  - arguments:
    - description: Specify forum id of the forum for which the details are to be fetched.
        The forum id can be known from context path (Flashpoint.Forum.ForumId or Flashpoint.Forum.Post.Forum.id)
        of flashpoint-search-forum-posts command or some other investigation.
      name: forum_id
      required: true
    description: Retrieves forum details using the forum ID. To retrieve the forum
      ID run the flashpoint-search-forum-posts command and see the value under the
      following context paths, Flashpoint.Forum.ForumId or Flashpoint.Forum.Post.Forum.id.
    name: flashpoint-get-forum-details
    outputs:
    - contextPath: Flashpoint.Forum.Description
      description: Detailed information of the supplied forum ID.
      type: string
    - contextPath: Flashpoint.Forum.Hostname
      description: Host details of the supplied forum ID.
      type: string
    - contextPath: Flashpoint.Forum.Name
      description: The name of forum.
      type: string
    - contextPath: Flashpoint.Forum.Stats
      description: Statistical information such as the number of posts, rooms, threads,
        and users details.
    - contextPath: Flashpoint.Forum.Tags
      description: A list of forum tags, including id, name, parent_tag, and UUID.
    - contextPath: Flashpoint.Forum.ForumId
      description: The Forum ID.
      type: string
  - arguments:
    - description: The room ID for which to retrieve room information in a forum.
        To retrieve the room ID run the flashpoint-search-forum-posts command and
        see the value under the Flashpoint.Forum.Post.Room.id context path.
      name: room_id
      required: true
    description: Retrieves forum room details using the room ID. To retrieve the room
      ID run the flashpoint-search-forum-posts command and see the value under the
      Flashpoint.Forum.Post.Room.id context path.
    name: flashpoint-get-forum-room-details
    outputs:
    - contextPath: Flashpoint.Forum.Room.Forum
      description: Forum details, including forum name, hostname, platform url, stats,
        tags, and so on.
    - contextPath: Flashpoint.Forum.Room.Title
      description: The room title. You can use the same title in the forum search
        command.
      type: string
    - contextPath: Flashpoint.Forum.Room.Url
      description: The forum room URL.
      type: string
    - contextPath: Flashpoint.Forum.Room.RoomId
      description: The forum room ID.
      type: string
  - arguments:
    - description: The user ID used to retrieve a user's information. To retrieve
        the user ID, run the flashpoint-search-forum-posts command and see the value
        under the Flashpoint.Forum.Post.User.id context path.
      name: user_id
      required: true
    description: Retrieves user details using the user-id. To retrieve the user ID,
      run the flashpoint-search-forum-posts command and see the value under the Flashpoint.Forum.Post.User.id
      context path.
    name: flashpoint-get-forum-user-details
    outputs:
    - contextPath: Flashpoint.Forum.User.Forum
      description: Forum details, including id, hostname, description, stats, tags,
        and so on.
    - contextPath: Flashpoint.Forum.User.Name
      description: The name of the user.
      type: string
    - contextPath: Flashpoint.Forum.User.PlatformUrl
      description: The platform URL of the user which is redirected to Flashpoint
        platform.
      type: string
    - contextPath: Flashpoint.Forum.User.Url
      description: The URL of user.
      type: string
    - contextPath: Flashpoint.Forum.User.UserId
      description: The unique ID of the forum user.
      type: string
  - arguments:
    - description: The post ID, which gives post information embedded within the forum,
        room, user, and so on. To retrieve the post ID, run the flashpoint-search-forum-posts
        and see the value under the Flashpoint.Forum.Post.PostId context path.
      name: post_id
      required: true
    description: Retrieves post details using the post-id. To retrieve the post ID,
      run the flashpoint-search-forum-posts command and see the value under the Flashpoint.Forum.Post.PostId
      context path. command or some other investigation.
    name: flashpoint-get-forum-post-details
    outputs:
    - contextPath: Flashpoint.Forum.Post.Forum
      description: Forum details of the post, including id, hostname, stats, description,
        tags, and so on.
    - contextPath: Flashpoint.Forum.Post.Room
      description: Room details of the post, including room title, id, url, platform
        url, and so on.
    - contextPath: Flashpoint.Forum.Post.User
      description: User details of the post, including user id, name, url, platform
        url, and so on.
    - contextPath: Flashpoint.Forum.Post.PlatformUrl
      description: Using platform URL user can redirect to Flashpoint platform.
      type: string
    - contextPath: Flashpoint.Forum.Post.PublishedAt
      description: The date that the post was published.
    - contextPath: Flashpoint.Forum.Post.Url
      description: The display URL of the post.
    - contextPath: Flashpoint.Forum.Post.PostId
      description: The forum post ID.
      type: string
  - arguments:
    - description: The site keyword or text for which to search. This keyword is used
        for search information in forum sites. This keyword or text is known by Flashpoint
        users.
      name: site_search
      required: true
    description: Searches forum sites using a keyword. it will search in site content
      like name, title, descripion etc.
    name: flashpoint-search-forum-sites
    outputs:
    - contextPath: Flashpoint.Forum.Site
      description: A list of forum site details based on the search keyword.
  - arguments:
    - description: The post keyword or text which is used for search information in
        forum posts, and is known by Flashpoint users.
      name: post_search
      required: true
    description: Search forum posts using a keyword
    name: flashpoint-search-forum-posts
    outputs:
    - contextPath: Flashpoint.Forum.Post
      description: A list of forum posts based on the search keyword.
  - arguments:
    - description: |-
        Filters the alerts based on the earliest date when the alerts were created.

        Formats accepted: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ, etc.
      name: since
    - description: |-
        Filters the alerts based on the latest date when the alerts were created.

        Formats accepted: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ, etc.
      name: until
    - description: |-
        Retrieves the next batch of alerts.

        Note: User can get the "scroll_id" from the HR of the same command "flashpoint-alert-list".
      name: scroll_id
    - defaultValue: "50"
      description: Number of alerts to retrieve in the response. (Maximum allowed
        size is 100).
      name: size
    description: Retrieves an alert or a list of alerts based on the filter values
      provided in the command arguments. Yields the alerts from Flashpoint collected
      sources and the alerts from data exposure.
    name: flashpoint-alert-list
    outputs:
    - contextPath: Flashpoint.Alerts.alert_id
      description: The ID of the alert.
      type: String
    - contextPath: Flashpoint.Alerts.fpid
      description: The ID of the resource that triggered the alert.
      type: String
    - contextPath: Flashpoint.Alerts.keyword.keyword_id
      description: The ID of the keyword.
      type: String
    - contextPath: Flashpoint.Alerts.keyword.keyword_text
      description: The value of the keyword.
      type: String
    - contextPath: Flashpoint.Alerts.highlights
      description: Snippets of the resource with the keywords highlighted.
      type: Unknown
    - contextPath: Flashpoint.Alerts.basetypes
      description: The data types of the resource.
      type: Unknown
    - contextPath: Flashpoint.Alerts.ts
      description: The timestamp of when the alert was created.
      type: Number
    - contextPath: Flashpoint.Alerts.tags.archived
      description: Whether the alert was archived or not.
      type: Boolean
    - contextPath: Flashpoint.Alerts.tags.flagged
      description: Whether the alert was starred or not.
      type: Boolean
    - contextPath: Flashpoint.Alerts.source.basetypes
      description: The data types of the resource.
      type: Unknown
    - contextPath: Flashpoint.Alerts.source.body.text/plain
      description: The body of the alert in text/plain format.
      type: String
    - contextPath: Flashpoint.Alerts.source.container.basetypes
      description: The data types for the thread or channel in which the content was
        posted.
      type: Unknown
    - contextPath: Flashpoint.Alerts.source.container.container.title
      description: The title of the container.
      type: String
    - contextPath: Flashpoint.Alerts.source.container.container.name
      description: The name of the container.
      type: String
    - contextPath: Flashpoint.Alerts.source.container.fpid
      description: The ID of the thread or channel in which the content was posted.
      type: String
    - contextPath: Flashpoint.Alerts.source.container.title
      description: The title of the thread or channel in which the content was posted.
      type: String
    - contextPath: Flashpoint.Alerts.source.created_at.date-time
      description: When the content was originally posted by its author.
      type: Date
    - contextPath: Flashpoint.Alerts.source.created_at.raw
      description: When the content was originally posted by its author, as raw format.
      type: String
    - contextPath: Flashpoint.Alerts.source.created_at.timestamp
      description: When the content was originally posted by its author, as a timestamp.
      type: Number
    - contextPath: Flashpoint.Alerts.source.first_observed_at.date-time
      description: The first time this piece of data was observed by Flashpoint.
      type: Date
    - contextPath: Flashpoint.Alerts.source.first_observed_at.raw
      description: The first time this piece of data was observed by Flashpoint, as
        raw format.
      type: String
    - contextPath: Flashpoint.Alerts.source.first_observed_at.timestamp
      description: The first time this piece of data was observed by Flashpoint, as
        a timestamp.
      type: Number
    - contextPath: Flashpoint.Alerts.source.fpid
      description: The ID of the resource.
      type: String
    - contextPath: Flashpoint.Alerts.source.last_observed_at.date-time
      description: The last time this piece of data was observed by Flashpoint.
      type: Date
    - contextPath: Flashpoint.Alerts.source.last_observed_at.raw
      description: The last time this piece of data was observed by Flashpoint, as
        raw format.
      type: String
    - contextPath: Flashpoint.Alerts.source.last_observed_at.timestamp
      description: The last time this piece of data was observed by Flashpoint, as
        a timestamp.
      type: Number
    - contextPath: Flashpoint.Alerts.source.native_id
      description: The ID used by the original site for the resource.
      type: String
    - contextPath: Flashpoint.Alerts.source.parent_message._schema
      description: The schema of the parent of this resource.
      type: String
    - contextPath: Flashpoint.Alerts.source.parent_message.basetypes
      description: The data types of the parent of this resource.
      type: Unknown
    - contextPath: Flashpoint.Alerts.source.parent_message.fpid
      description: The ID of the parent of this resource.
      type: String
    - contextPath: Flashpoint.Alerts.source.parent_message.native_id
      description: The ID used by the original site for the parent of this resource.
      type: String
    - contextPath: Flashpoint.Alerts.source.parent_message.type
      description: The type of the parent of this resource.
      type: String
    - contextPath: Flashpoint.Alerts.source.site.title
      description: The original site or platform where the resource was published.
      type: String
    - contextPath: Flashpoint.Alerts.source.site_actor.names.aliases
      description: The alias of the user who created the message, authored the blog
        post, or posted a product for sale.
      type: Unknown
    - contextPath: Flashpoint.Alerts.source.site_actor.names.handle
      description: The handle of the user who created the message, authored the blog
        post, or posted a product for sale.
      type: String
    - contextPath: Flashpoint.Alerts.source.sort_date
      description: Sort date of the alert.
      type: Date
    - contextPath: Flashpoint.Alerts.source.title
      description: The title of the alert.
      type: String
    - contextPath: Flashpoint.Alerts.source.file
      description: File name for the matched alert.
      type: String
    - contextPath: Flashpoint.Alerts.source.owner
      description: Author of the repo.
      type: String
    - contextPath: Flashpoint.Alerts.source.repo
      description: Repository name.
      type: String
    - contextPath: Flashpoint.Alerts.source.snippet
      description: Small blob of code/text that matched the keyword.
      type: String
    - contextPath: Flashpoint.Alerts.source.source
      description: Code repository platform.
      type: String
    - contextPath: Flashpoint.Alerts.source.url
      description: Link to the alerted source.
      type: String
    - contextPath: Flashpoint.PageToken.Alert.scroll_id
      description: The scroll_id for the next page.
      type: String
    - contextPath: Flashpoint.PageToken.Alert.size
      description: The size for the next page.
      type: String
    - contextPath: Flashpoint.PageToken.Alert.since
      description: The since date for the next page.
      type: String
    - contextPath: Flashpoint.PageToken.Alert.until
      description: The until date for the next page.
      type: String
    - contextPath: Flashpoint.PageToken.Alert.name
      description: The command name.
      type: String
  - arguments:
    - description: |-
        Filters the data based on the start date of the breach (UTC). Note: Will consider current time as default for end_date if start_date is initialized.

        Formats accepted: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ, etc.
      name: start_date
    - description: |-
        Filters the data based on the end date of the breach (UTC). Note: Requires start_date along with the given argument.

        Formats accepted: 2 minutes, 2 hours, 2 days, 2 weeks, 2 months, 2 years, yyyy-mm-dd, yyyy-mm-ddTHH:MM:SSZ, etc.
      name: end_date
    - auto: PREDEFINED
      description: |-
        Filters the compromised credential's breach data by either created or first observed date.
        Note: Requires the argument value for at least 'start_date' and 'end_date'.
      name: filter_date
      predefined:
      - created_at
      - first_observed_at
    - defaultValue: "50"
      description: 'The maximum number of result objects to return per page. Note:
        The maximum value is 1,000.'
      name: page_size
    - defaultValue: "1"
      description: 'Specify a page number to retrieve the compromised credentials.
        Note: The multiplication of page_size and page_number parameters cannot exceed
        10,000.'
      name: page_number
    - auto: PREDEFINED
      description: 'Sort the compromised credential''s breach data by either created
        or first observed date. Note: Will consider ascending as default for sort_order
        if sort_date is initialized.'
      name: sort_date
      predefined:
      - created_at
      - first_observed_at
    - auto: PREDEFINED
      description: 'Specify the order to sort the data in. Note: Requires sort_date
        along with the given argument.'
      name: sort_order
      predefined:
      - asc
      - desc
    - auto: PREDEFINED
      description: 'Whether to fetch the fresh compromised credentials or not. Possible
        values are: true, false.'
      name: is_fresh
      predefined:
      - "true"
      - "false"
    description: Retrieves the compromised credentials based on the filter values
      provided in the command arguments.
    name: flashpoint-compromised-credentials-list
    outputs:
    - contextPath: Flashpoint.CompromisedCredential._id
      description: ID of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.affected_domain
      description: Affected domain of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.basetypes
      description: The array contains the underlying type of the credentials object,
        in this case  ["credential-sighting"].
      type: Unknown
    - contextPath: Flashpoint.CompromisedCredential._source.body.raw
      description: This is the raw content captured from the breach Flashpoint discovered.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach._header
      description: This is the breach header object.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach.basetypes
      description: Array containing underlying base type of breach object, i.e. ["breach"].
      type: Unknown
    - contextPath: Flashpoint.CompromisedCredential._source.breach.breach_type
      description: Constant for future use.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach.created_at.date-time
      description: Datetime object formatted as YYYY-mm-ddTHH:MM:SSZ.
      type: Date
    - contextPath: Flashpoint.CompromisedCredential._source.breach.created_at.timestamp
      description: UNIX timestamp.
      type: Number
    - contextPath: Flashpoint.CompromisedCredential._source.breach.first_observed_at.date-time
      description: Datetime object formatted as YYYY-mm-ddTHH:MM:SSZ.
      type: Date
    - contextPath: Flashpoint.CompromisedCredential._source.breach.first_observed_at.timestamp
      description: UNIX timestamp.
      type: Number
    - contextPath: Flashpoint.CompromisedCredential._source.breach.fpid
      description: Flashpoint ID of the breach.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach.source
      description: Data source of breach (i.e. Analyst Research, CredentialStealer,
        etc.).
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach.source_type
      description: Type of source of the breach.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach.title
      description: Title of breach.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.breach.victim
      description: Victim of the breach.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.credential_record_fpid
      description: This is the Flashpoint ID of the associated record object. This
        is used to retrieve sightings for a credential.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.customer_id
      description: Customer ID of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.domain
      description: This is the domain object extracted off of the email address.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.email
      description: The email address for the compromised credential.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.extraction_id
      description: Extraction ID of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.extraction_record_id
      description: Extraction record ID of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.fpid
      description: The Flashpoint ID of this credentials object.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.header_.indexed_at
      description: Timestamp for when this document was indexed into the Flashpoint
        database.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.header_.pipeline_duration
      description: Pipeline duration header information of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.is_fresh
      description: This will be "true" if the credential has not been seen before,
        and it hasn't been marked "not fresh" by an analyst. (Historical breaches
        are not "fresh".).
      type: Boolean
    - contextPath: Flashpoint.CompromisedCredential._source.last_observed_at.date-time
      description: If exists, time object for when the credential was previously observed.
        Datetime object formatted as YYYY-mm-ddTHH:MM:SSZ.
      type: Date
    - contextPath: Flashpoint.CompromisedCredential._source.last_observed_at.timestamp
      description: UNIX timestamp.
      type: Number
    - contextPath: Flashpoint.CompromisedCredential._source.password
      description: The password for the credential (in plain text, if possible).
      type: String
    - contextPath: Flashpoint.CompromisedCredential._source.password_complexity.has_lowercase
      description: Boolean true/false if lowercase letters are present.
      type: Boolean
    - contextPath: Flashpoint.CompromisedCredential._source.password_complexity.has_number
      description: Boolean true/false if numbers are present.
      type: Boolean
    - contextPath: Flashpoint.CompromisedCredential._source.password_complexity.has_symbol
      description: Boolean true/false if symbols are present.
      type: Boolean
    - contextPath: Flashpoint.CompromisedCredential._source.password_complexity.has_uppercase
      description: Boolean true/false if uppercase letters are present.
      type: Boolean
    - contextPath: Flashpoint.CompromisedCredential._source.password_complexity.length
      description: Integer value that represents number of characters in password.
      type: Number
    - contextPath: Flashpoint.CompromisedCredential._source.password_complexity.probable_hash_algorithms
      description: List of possible hash algorithms suspected based on textpattern
        of the password (May include values like "MD5", "SHA-1", "SHA-256", "bcrypt",
        etc.)
      type: Unknown
    - contextPath: Flashpoint.CompromisedCredential._source.times_seen
      description: Integer representing the number of times the credential has been
        seen at Flashpoint.
      type: Number
    - contextPath: Flashpoint.CompromisedCredential._type
      description: Type of the IoC.
      type: String
    - contextPath: Flashpoint.CompromisedCredential.matched_queries
      description: Matching queries of the IoC.
      type: Unknown
    - contextPath: Flashpoint.CompromisedCredential.sort
      description: Sort value of the IoC.
      type: Unknown
  dockerimage: demisto/python3:3.10.4.29342
  isfetch: true
  runonce: false
  script: |
    register_module_line('Flashpoint', 'start', __line__())
    """Flashpoint Main File."""

    import re
    import ipaddress
    import requests
    import urllib.parse
    from typing import Dict, Tuple, List, Any

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    """ CONSTANTS """
    INTEGRATION_VERSION = "v1.3.3"
    INTEGRATION_PLATFORM = "XSOAR Cortex"
    FIRST_FETCH = "3 days"
    MAX_FETCH = 15
    DEFAULT_PAGE_SIZE = 50
    MAX_PAGE_SIZE = 1000
    MAX_PRODUCT = 10000
    DEFAULT_SORT_ORDER = 'asc'
    DEFAULT_FETCH_TYPE = 'Compromised Credentials'
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'  # ISO8601 format with UTC, default in XSOAR
    READABLE_DATE_FORMAT = '%b %d, %Y  %H:%M'
    BRAND = 'Flashpoint'

    IS_FRESH_VALUES = ['true', 'false']
    SORT_ORDER_VALUES = ['asc', 'desc']
    SORT_DATE_VALUES = ['created_at', 'first_observed_at']
    FILTER_DATE_VALUES = ['created_at', 'first_observed_at']

    DATE_OBSERVED = "Date Observed (UTC)"
    STRING_FORMAT = "[{}]({})"
    TIME_OBSERVED = "Observed time (UTC)"
    QUERY = r'+type:("ip-src","ip-dst","ip-dst|port") +value.\*:"'
    HR_TITLE = '### Flashpoint IP address reputation for '
    REPUTATION_MALICIOUS = 'Reputation: Malicious\n\n'
    TABLE_TITLE = 'Events in which this IOC observed'
    ALL_DETAILS_LINK = '\nAll events and details (fp-tools): [{}]({})\n'
    MALICIOUS_DESCRIPTION = 'Found in malicious indicators dataset'
    STIX_ATTACK_PATTERN = 'STIX Attack Pattern'
    REPUTATION_UNKNOWN = 'Reputation: Unknown\n\n'
    FORUM_NAME = 'Forum Name'
    ROOM_TITLE = 'Room Title'
    AUTHOR_NAME = 'Author Name'
    THREAD_TITLE = 'Thread Title'

    FLASHPOINT_PATHS = {
        'IP': 'Flashpoint.IP.Event(val.Fpid && val.Fpid == obj.Fpid)',
        'Url': 'Flashpoint.URL.Event(val.Fpid && val.Fpid == obj.Fpid)',
        'Domain': 'Flashpoint.Domain.Event(val.Fpid && val.Fpid == obj.Fpid)',
        'Email': 'Flashpoint.Email.Event(val.Fpid && val.Fpid == obj.Fpid)',
        'File': 'Flashpoint.File.Event(val.Fpid && val.Fpid == obj.Fpid)',
        'Filename': 'Flashpoint.Filename.Event(val.Fpid && val.Fpid == obj.Fpid)',
        'Event': 'Flashpoint.Event(val.EventId == obj.EventId)',
        'Report': 'Flashpoint.Report(val.ReportId == obj.ReportId)',
        'Forum': 'Flashpoint.Forum(val.ForumId == obj.ForumId)',
        'Room': 'Flashpoint.Forum.Room(val.RoomId == obj.RoomId)',
        'User': 'Flashpoint.Forum.User(val.UserId == obj.UserId)',
        'Post': 'Flashpoint.Forum.Post(val.PostId == obj.PostId)',
        'Site': 'Flashpoint.Forum.Site(val.SiteId == obj.SiteId)',
        'ALERT': 'Flashpoint.Alerts(val.alert_id == obj.alert_id && val.fpid == obj.fpid)',
        'TOKEN': 'Flashpoint.PageToken.Alert(val.name == obj.name)',
    }

    URL_SUFFIX = {
        'COMPROMISED_CREDENTIALS': '/all/search'
    }

    URL_SUFFIX_V1 = {
        'ALERTS': '/api/alerting/v1/alerts'
    }

    MESSAGES = {
        "INVALID_MAX_FETCH": "{} is an invalid value for maximum fetch. Maximum fetch must be between 1 to 100 for alerts "
                             "and between 1 to 1000 for compromised credentials.",
        "INVALID_FIRST_FETCH": "Argument 'First fetch time interval' should be a valid date or relative timestamp such as "
                               "'2 days', '2 months', 'yyyy-mm-dd', 'yyyy-mm-ddTHH:MM:SSZ'",
        "SIZE_ERROR": "{} is an invalid value for size. Size must be between 1 to 100.",
        "NO_RECORDS_FOUND": "No {} were found for the given argument(s).",
        "PAGE_SIZE_ERROR": "{} is an invalid value for the page size. The page size must be between 1 to {}.",
        "PAGE_NUMBER_ERROR": "{} is an invalid value for the page number. The page number must be greater than 0.",
        "PRODUCT_ERROR": "The multiplication of the page_size and the page_number parameters cannot exceed {}. "
                         "Current multiplication is {}.",
        "START_DATE_ERROR": "Requires the start_date argument along with the end_date argument.",
        "FILTER_DATE_ERROR": "{} is an invalid value for filter date. Filter date value must be of {}.",
        "SORT_DATE_ERROR": "{} is an invalid value for the sort date. The sort date value must be of {}.",
        "SORT_ORDER_ERROR": "{} is an invalid value for the sort order. The sort order value must be of {}.",
        "MISSING_DATE_ERROR": "Requires the argument value for at least the 'start_date' argument.",
        "MISSING_FILTER_DATE_ERROR": "Requires the filter_date argument's value when the start_date or the "
                                     "end_date argument is provided.",
        "MISSING_SORT_DATE_ERROR": "Requires sort_date value when sort_order is provided.",
        "IS_FRESH_ERROR": "{} is an invalid value for is fresh. Is fresh value must be of {}.",
        "MISSING_DATA": "{} response contains incorrect or missing data.",
        "TIME_RANGE_ERROR": "The maximum records to fetch in first fetch can not exceed 10000. Current records are {}. "
                            "Try decreasing the time interval."
    }


    class Client:
        """
        Client to use in integration with powerful http_request.

        :type api_key: ``str``
        :param api_key: Use to authenticate request in header

        :type url: ``str``
        :param url: Base server address with suffix, for example: https://example.com.

        :type verify: ``Boolean``
        :param verify: Use to indicate secure/insecure http request

        :type proxies: ``dict``
        :param proxies: proxies dict for http request

        :type create_relationships: ``bool``
        :param create_relationships: True if integration will create relationships

        :return response of request
        :rtype ``dict``
        """

        def __init__(self, api_key, url, verify, proxies, create_relationships):
            """Initialize class object."""
            self.url = url
            self.api_key = api_key
            self.verify = verify
            self.proxies = proxies
            self.create_relationships = create_relationships

        def http_request(self, method, url_suffix, params=None):
            """
            Get http response based on url and given parameters.

            :param method: Specify http methods
            :param url_suffix: url encoded url suffix
            :param params: None
            :return: http response on json
            """
            base_url = self.url + "/api/v4"
            full_url = base_url + url_suffix

            # over writing full URL as we are adding support for v1 endpoints
            if url_suffix in URL_SUFFIX_V1.values():
                full_url = self.url + url_suffix

            headers = {
                'Authorization': f"Bearer {self.api_key}",
                'X-FP-IntegrationPlatform': INTEGRATION_PLATFORM,
                'X-FP-IntegrationPlatformVersion': get_demisto_version_as_str(),
                'X-FP-IntegrationVersion': INTEGRATION_VERSION
            }

            resp = requests.request(
                method,
                full_url,
                verify=self.verify,
                proxies=self.proxies,
                params=params,
                headers=headers
            )

            status_code = resp.status_code

            resp_json = resp.json()

            if status_code != 200:
                if status_code == 400:
                    raise ValueError(
                        "Invalid argument value while trying to get information from Flashpoint: " + resp_json.get(
                            'detail', resp_json.get('message', 'N/A')))
                elif status_code == 401:
                    raise ValueError(
                        "Encountered error while trying to get information from Flashpoint: Invalid API Key is "
                        "configured")
                elif status_code == 404:
                    raise ValueError("No record found for given argument(s): Not Found")
                elif status_code in (521, 403):
                    raise ValueError("Test connectivity failed. Please provide valid input parameters.")
                else:
                    resp.raise_for_status()

            return resp_json


    ''' HELPER FUNCTIONS '''


    def get_apikey():
        """Get API Key from the command argument."""
        api_key = demisto.params()["api_key"]

        return api_key


    def get_url_suffix(query):
        """
        Create url-suffix using the query value with url encoding.

        :param query: value of query param
        :return: url-encoded url-suffix
        """
        return r'/indicators/simple?query=' + urllib.parse.quote(query.encode('utf8'))


    def prepare_args_for_fetch_alerts(max_fetch: int, start_time: str, last_run: dict) -> dict:
        """
        Prepare arguments for fetching alerts.

        :param max_fetch: Maximum number of incidents per fetch
        :param start_time: Date time to start fetching incidents from
        :param last_run: Dictionary containing last run objects

        :return: Dictionary of fetch arguments
        """
        fetch_params: Dict[str, Any] = {}

        if max_fetch < 1 or max_fetch > 100:
            raise ValueError(MESSAGES['INVALID_MAX_FETCH'].format(max_fetch))

        fetch_params['size'] = max_fetch
        fetch_params['since'] = last_run.get('since', start_time)
        fetch_params['scroll_id'] = last_run.get('scroll_id')

        return fetch_params


    def prepare_args_for_fetch_compromised_credentials(max_fetch: int, start_time: str, is_fresh: bool,
                                                       last_run: dict) -> dict:
        """
        Prepare arguments for fetching compromised credentials.

        :param max_fetch: Maximum number of incidents per fetch
        :param start_time: Date time to start fetching incidents from
        :param is_fresh: Boolean value showing whether to fetch the fresh compromised credentials or not
        :param last_run: Dictionary containing last run objects

        :return: Dictionary of fetch arguments
        """
        fetch_params: Dict[str, Any] = {}

        if max_fetch < 1 or max_fetch > MAX_PAGE_SIZE:
            raise ValueError(MESSAGES['INVALID_MAX_FETCH'].format(max_fetch))
        fetch_params['limit'] = max_fetch

        if not last_run.get('fetch_count'):
            last_run['fetch_count'] = 0

        if not last_run.get('fetch_sum'):
            last_run['fetch_sum'] = 0

        fetch_params['skip'] = last_run['fetch_sum']

        total = last_run.get('total')
        if total:
            fetch_sum = fetch_params['limit'] + fetch_params['skip']
            if fetch_sum > total:
                fetch_params['limit'] = total - fetch_params['skip']
        last_run['fetch_sum'] = fetch_params['limit'] + fetch_params['skip']

        start_time = arg_to_datetime(start_time)
        start_time = datetime.timestamp(start_time)  # type: ignore

        if last_run['fetch_count'] == 0:
            end_time = arg_to_datetime('now')
            last_run['end_time'] = end_time.strftime(DATE_FORMAT)  # type: ignore
        else:
            end_time = last_run['end_time']
            end_time = arg_to_datetime(end_time)
        end_time = datetime.timestamp(end_time)  # type: ignore

        query = '+basetypes:(credential-sighting)'
        query += f' +header_.indexed_at: [{int(start_time)} TO {int(end_time)}]'  # type: ignore

        if is_fresh:
            query += ' +is_fresh:true'

        fetch_params['query'] = query
        fetch_params['sort'] = 'header_.indexed_at:asc'

        return fetch_params


    def validate_fetch_incidents_params(params: dict, last_run: dict) -> Dict:
        """
        Validate the parameter list for fetch incidents.

        :param params: Dictionary containing demisto configuration parameters
        :param last_run: last run returned by function demisto.getLastRun

        :return: Dictionary containing validated configuration parameters in proper format.
        """
        fetch_params = {}

        fetch_type = params.get('fetch_type', DEFAULT_FETCH_TYPE)
        if not fetch_type:
            fetch_type = DEFAULT_FETCH_TYPE

        first_fetch = arg_to_datetime(params.get('first_fetch', FIRST_FETCH))
        if first_fetch is None:
            raise ValueError(MESSAGES['INVALID_FIRST_FETCH'])
        start_time = first_fetch.strftime(DATE_FORMAT)

        if last_run and 'start_time' in last_run:
            start_time = last_run.get('start_time')  # type: ignore

        is_fresh = argToBoolean(params.get('is_fresh_compromised_credentials', 'true'))

        max_fetch = arg_to_number(params.get('max_fetch', MAX_FETCH))
        if max_fetch is None:
            raise ValueError(MESSAGES['INVALID_MAX_FETCH'].format(max_fetch))

        if fetch_type == 'Alerts':
            fetch_params = prepare_args_for_fetch_alerts(max_fetch, start_time, last_run)
        elif fetch_type == DEFAULT_FETCH_TYPE:
            fetch_params = prepare_args_for_fetch_compromised_credentials(max_fetch, start_time,
                                                                          is_fresh, last_run)  # type: ignore

        remove_nulls_from_dictionary(fetch_params)

        return {
            'fetch_type': fetch_type,
            'start_time': start_time,
            'fetch_params': fetch_params
        }


    def parse_indicator_response(indicators):
        """
        Extract Flashpoint event details and href values from each of the indicator in an indicator list.

        :param indicators: list of indicators
        :return: dict containing event details and href
        """
        events = []
        hrefs = []
        attack_ids = []
        for indicator in indicators:
            hrefs.append(indicator.get('Attribute', {}).get('href', ''))

            event = indicator.get('Attribute', {}).get('Event', {})
            attack_ids = event.get('attack_ids', [])
            tags_list = [tag for tag in event['Tags']]
            tags_value = ', '.join(tags_list)

            observed_time = time.strftime(READABLE_DATE_FORMAT, time.gmtime(float(event['timestamp'])))

            events.append({
                DATE_OBSERVED: observed_time,
                'Name': event.get('info', ''),
                'Tags': tags_value,
            })

        return {'events': events, 'href': hrefs, 'attack_ids': attack_ids}


    def parse_event_response(client, event, fpid, href):
        """
        Prepare required event json object from event response.

        :param href: reference link of event
        :param fpid: unique id of event. i.e EventId
        :param client: object of client class
        :param event: event indicator from response
        :return: required event json object
        """
        observed_time = time.strftime(READABLE_DATE_FORMAT, time.gmtime(float(event['timestamp'])))
        name = event.get('info', '')
        uuid = event.get('uuid', '')
        if uuid:
            fp_link = client.url + '/home/technical_data/iocs/items/' + uuid
            name_str = STRING_FORMAT.format(name, fp_link)
        else:
            name_str = name

        tags_list = [tag['name'] for tag in event.get('Tag', [])]
        tags_value = ', '.join(tags_list)

        event_creator_email = event.get('event_creator_email', '')

        event = {
            TIME_OBSERVED: observed_time,
            'Name': name_str,
            'Tags': tags_value,
            'EventCreatorEmail': event_creator_email,
            'EventId': fpid,
            'Href': href
        }

        return event


    def parse_forum_response(resp):
        """
        Prepare forum json object from forum response.

        :param resp: forum response
        :return: required forum json object
        """
        name = resp.get('name', '')
        hostname = resp.get('hostname', '')

        tags_list = [tag['name'] for tag in resp['tags']]
        tags_value = ', '.join(tags_list)

        forum_details = {
            'Name': name,
            'Hostname': hostname,
            'Tags': tags_value
        }

        return forum_details


    def get_post_context(resp):
        """
        Prepare context data for forum post.

        :param resp: forum post api response
        :return: dict object
        """
        post_ec = {
            'PostId': resp['id'],
            'PublishedAt': resp.get('published_at', ''),
            'Url': resp.get('url', ''),
            'PlatformUrl': resp.get('platform_url', ''),
            'Forum': resp['embed']['forum'],
            'Room': resp['embed']['room'],
            'User': resp['embed']['author']
        }

        return post_ec


    def reputation_operation_command(client, indicator, func, command_results=False):
        """
        Call specific function for all reputation commands from this common method.

        :param client: object of client class
        :param indicator: comma-separated values or single value
        :param func: reputation command function. i.e file_lookup, domain_lookup etc.
        :param command_results: if the result of the func returns CommandResults object.
        :return: output of all value according to specified function.
        """
        args = argToList(indicator, ',')
        for arg in args:
            if command_results:
                return_results(func(client, arg))
            else:
                return_outputs(*func(client, arg))


    def replace_key(dictionary, new_key, old_key):
        """
        Replace key in dictionary.

        :param dictionary: dictionary object on which we wan to replace key.
        :param new_key: key which will replace in dictionary
        :param old_key: existing key in dictionary
        :return: dict object
        """
        if dictionary.get(old_key):
            dictionary[new_key] = dictionary.pop(old_key)
        return dictionary


    def validate_alert_list_args(args: dict) -> dict:
        """
        Validate arguments for flashpoint-alert-list command.

        :param args: The command arguments

        :return: Validated dictionary of arguments
        :raises: ValueError for invalid arguments
        """
        params = {}

        size = arg_to_number(args.get('size', 50))
        if size is None or size < 1 or size > 100:  # type: ignore
            raise ValueError(MESSAGES['SIZE_ERROR'].format(size))
        params['size'] = size

        since = arg_to_datetime(args.get('since'))
        if since:
            params['since'] = since.strftime(DATE_FORMAT)  # type: ignore

        until = arg_to_datetime(args.get('until'))
        if until:
            params['until'] = until.strftime(DATE_FORMAT)  # type: ignore

        params['scroll_id'] = args.get('scroll_id')  # type: ignore

        remove_nulls_from_dictionary(params)

        return params


    def prepare_hr_for_alerts(alerts: List) -> str:
        """
        Prepare human readable format for alerts.

        :param alerts: List of alerts

        :return: Human readable format of alerts
        """
        table1_hr = []
        table2_hr = []

        for alert in alerts:
            fpid = alert.get('fpid', '')
            keyword_text = alert.get('keyword', {}).get('keyword_text')
            source_created_at = alert.get("source", {}).get("created_at", {}).get('date-time')
            source_last_observed_at = alert.get("source", {}).get("last_observed_at", {}).get('date-time')

            # For Flashpoint Collected sources, created_at or last_observed_at would be present under source.
            if source_created_at or source_last_observed_at:
                source_created_at = arg_to_datetime(source_created_at)
                if source_created_at:
                    source_created_at = source_created_at.strftime(READABLE_DATE_FORMAT)

                source_last_observed_at = arg_to_datetime(source_last_observed_at)
                if source_last_observed_at:
                    source_last_observed_at = source_last_observed_at.strftime(READABLE_DATE_FORMAT)

                data = {
                    'FPID': fpid,
                    'Keyword Text': keyword_text,
                    'Site Title': alert.get('source', {}).get('site', {}).get('title'),
                    'Created Date (UTC)': source_created_at,
                    'Last Observed Date (UTC)': source_last_observed_at
                }
                table1_hr.append(data)
            source_file = alert.get("source", {}).get("file")
            source_repo = alert.get("source", {}).get("repo")

            # Flashpoint Alerts with Data exposures expects file or repo under source
            if source_file or source_repo:
                data = {
                    'FPID': fpid,
                    'Keyword Text': keyword_text,
                    'File': alert.get('source', {}).get('file'),
                    'Owner': alert.get('source', {}).get('owner'),
                    'Repo': alert.get('source', {}).get('repo'),
                    'Source': alert.get('source', {}).get('source'),
                }
                table2_hr.append(data)

            elif not source_created_at and not source_last_observed_at and not source_file and not source_repo:
                raise ValueError(MESSAGES['MISSING_DATA'].format('Alerts'))

        headers1 = ['FPID', 'Keyword Text', 'Site Title', 'Created Date (UTC)', 'Last Observed Date (UTC)']
        headers2 = ['FPID', 'Keyword Text', 'File', 'Owner', 'Repo', 'Source']
        table1 = tableToMarkdown("Alerts from Flashpoint collected sources.", table1_hr, headers1, removeNull=True)
        table2 = tableToMarkdown("Alerts with data exposures.", table2_hr, headers2, removeNull=True)
        return table1 + table2


    def validate_page_parameters_for_compromised_credentials(args: dict, params: dict) -> None:
        """
        Validate page_size and page_number for flashpoint-compromised-credentials-list command.

        :param args: The command arguments
        :param params: Dictionary of parameters

        :return: None
        """
        page_size = arg_to_number(args.get('page_size', DEFAULT_PAGE_SIZE))
        if page_size is None or page_size < 1 or page_size > MAX_PAGE_SIZE:
            raise ValueError(MESSAGES['PAGE_SIZE_ERROR'].format(page_size, MAX_PAGE_SIZE))

        page_number = arg_to_number(args.get('page_number', 1))
        if page_number is None or page_number < 1:
            raise ValueError(MESSAGES['PAGE_NUMBER_ERROR'].format(page_number))

        product = page_size * page_number
        if product > MAX_PRODUCT:
            raise ValueError(MESSAGES['PRODUCT_ERROR'].format(MAX_PRODUCT, product))

        params['skip'] = page_size * (page_number - 1)  # type: ignore
        params['limit'] = page_size  # type: ignore


    def validate_date_parameters_for_compromised_credentials(args: dict, params: dict) -> None:
        """
        Validate date params for flashpoint-compromised-credentials-list command.

        :param args: The command arguments
        :param params: Dictionary of parameters

        :return: None
        """
        start_date = arg_to_datetime(args.get('start_date'))
        end_date = arg_to_datetime(args.get('end_date'))

        if end_date and not start_date:
            raise ValueError(MESSAGES['START_DATE_ERROR'])

        if start_date and not end_date:
            end_date = arg_to_datetime('now')

        filter_date = args.get('filter_date')
        if filter_date:
            if filter_date not in FILTER_DATE_VALUES:
                raise ValueError(MESSAGES['FILTER_DATE_ERROR'].format(filter_date, FILTER_DATE_VALUES))
            if not (start_date or end_date):
                raise ValueError(MESSAGES['MISSING_DATE_ERROR'])
            date_query = ' +breach.{}.date-time: [{} TO {}]'.format(filter_date,
                                                                    start_date.strftime(DATE_FORMAT),  # type: ignore
                                                                    end_date.strftime(DATE_FORMAT))  # type: ignore
            params['query'] += date_query
        elif start_date or end_date:
            raise ValueError(MESSAGES['MISSING_FILTER_DATE_ERROR'])


    def validate_sort_parameters_for_compromised_credentials(args: dict, params: dict) -> None:
        """
        Validate sort_order and sort_date for flashpoint-compromised-credentials-list command.

        :param args: The command arguments
        :param params: Dictionary of parameters

        :return: None
        """
        sort_order = args.get('sort_order')
        if sort_order and sort_order not in SORT_ORDER_VALUES:
            raise ValueError(MESSAGES['SORT_ORDER_ERROR'].format(sort_order, SORT_ORDER_VALUES))

        sort_date = args.get('sort_date')
        if sort_date:
            if sort_date not in SORT_DATE_VALUES:
                raise ValueError(MESSAGES['SORT_DATE_ERROR'].format(sort_date, SORT_DATE_VALUES))
            if not sort_order:
                sort_order = DEFAULT_SORT_ORDER
            params['sort'] = f'breach.{sort_date}.timestamp:{sort_order}'
        elif sort_order:
            raise ValueError(MESSAGES['MISSING_SORT_DATE_ERROR'])


    def validate_compromised_credentials_list_args(args: dict) -> dict:
        """
        Validate arguments for flashpoint-compromised-credentials-list command.

        :param args: The command arguments

        :return: Validated dictionary of arguments
        :raises: ValueError on invalid arguments
        """
        params = {'query': '+basetypes:(credential-sighting)'}

        validate_page_parameters_for_compromised_credentials(args, params)

        validate_date_parameters_for_compromised_credentials(args, params)

        validate_sort_parameters_for_compromised_credentials(args, params)

        is_fresh = args.get('is_fresh')
        if is_fresh:
            if is_fresh not in IS_FRESH_VALUES:
                raise ValueError(MESSAGES['IS_FRESH_ERROR'].format(is_fresh, IS_FRESH_VALUES))
            params['query'] += f' +is_fresh:{is_fresh}'

        remove_nulls_from_dictionary(params)

        return params


    def prepare_hr_for_compromised_credentials(hits: list) -> str:
        """
        Prepare human readable format for compromised credentials.

        :param hits: List of compromised credentials

        :return: Human readable format of compromised credentials
        """
        hr = []
        for hit in hits:
            source = hit.get('_source', {})
            created_date = source.get('breach', {}).get('created_at', {}).get('date-time')
            created_date = arg_to_datetime(created_date)
            if created_date:
                created_date = created_date.strftime(READABLE_DATE_FORMAT)  # type: ignore

            first_observed_date = source.get('breach', {}).get('first_observed_at', {}).get('date-time')
            first_observed_date = arg_to_datetime(first_observed_date)
            if first_observed_date:
                first_observed_date = first_observed_date.strftime(READABLE_DATE_FORMAT)  # type: ignore

            data = {
                'FPID': source.get('fpid', ''),
                'Email': source.get('email', ''),
                'Breach Source': source.get('breach', {}).get('source'),
                'Breach Source Type': source.get('breach', {}).get('source_type'),
                'Password': source.get('password'),
                'Created Date (UTC)': created_date,
                'First Observed Date (UTC)': first_observed_date
            }
            hr.append(data)

        return tableToMarkdown("Compromised Credential(s)", hr, ['FPID', 'Email', 'Breach Source', 'Breach Source Type',
                                                                 'Password', 'Created Date (UTC)',
                                                                 'First Observed Date (UTC)'], removeNull=True)


    def remove_duplicate_records(records: List, fetch_type: str, next_run: dict) -> List:
        """
        Check for duplicate records and remove them from the list.

        :param records: List of records
        :param fetch_type: Type of the records
        :param next_run: Dictionary to set in last run

        :return: Updated list of alerts
        """
        last_run_key = ''
        id_key = ''
        if fetch_type == 'Alerts':
            last_run_key = 'alert_ids'
            id_key = 'alert_id'
        elif fetch_type == DEFAULT_FETCH_TYPE:
            last_run_key = 'hit_ids'
            id_key = '_id'

        if next_run.get(last_run_key):
            prev_alert_ids = next_run[last_run_key]
            records = [i for i in records if i[id_key] not in prev_alert_ids]

        return records


    def update_alert_body(alert: dict) -> None:
        """
        Add highlight to keyword text.

        :param alert: The alert object

        :return: None
        """
        # Plain text might not contain quotes (and spaces) present in peripherals, thus stripping them
        keyword = alert.get("keyword", {}).get("keyword_text", "").strip("\" ")
        body = alert.get("source", {}).get("body", {}).get("text/plain")
        if body:
            alert["source"]["body"]["text/plain"] = re.sub(re.escape(keyword), f"<mark>{keyword}</mark>", body,
                                                           flags=re.IGNORECASE)


    def prepare_context_from_next_href(links: str) -> Dict:
        """
        Prepare context from href.

        :param links: Link with the arguments

        :return: Context data made from link
        """
        arg_split = links.split('?')
        context = urllib.parse.parse_qs(arg_split[1])
        return context


    def prepare_incidents_from_alerts_data(response: dict, next_run: dict, start_time: str) -> Tuple[dict, list]:
        """
        Prepare incidents from the alerts data.

        :param response: Response from the alerts API
        :param next_run: Dictionary to set in last run
        :param start_time: Date time saved of the latest alert

        :return: Tuple of dictionary of next run and list of fetched incidents
        """
        incidents = []
        alerts = response.get('data', [])

        alert_ids = [alert['alert_id'] for alert in alerts]
        alerts = remove_duplicate_records(alerts, 'Alerts', next_run)

        for alert in alerts:
            created_timestamp = alert.get("ts")
            if created_timestamp:
                update_alert_body(alert)
                created_at = datetime.utcfromtimestamp(float(created_timestamp))
                created_at = created_at.strftime(DATE_FORMAT)  # type: ignore

                keyword_text = alert.get('keyword', {}).get('keyword_text', 'Flashpoint Alert')

                incidents.append({
                    'name': f"{keyword_text}",
                    'occurred': created_at,
                    'rawJSON': json.dumps(alert)
                })

                if created_at >= start_time:
                    start_time = created_at
            else:
                demisto.error("The incident was ignored because it doesn't contain 'ts' timestamp")

        if alerts:
            next_run['start_time'] = start_time
            if not next_run.get('scroll_id'):
                next_run['alert_ids'] = alert_ids

        links = response.get('links', {}).get('next', {}).get('href')
        if links:
            context = prepare_context_from_next_href(links)
            for con in context:
                next_run[con] = context[con][0]
        else:
            # When no more data is present for current request. So, update the start time and make scroll_id as null.
            next_run['scroll_id'] = None
            next_run['since'] = start_time

        return next_run, incidents


    def check_value_of_total_records(total: Any, next_run: dict) -> None:
        """
        Check if total number of records are more than the limit or not.

        :param total: Total number of records
        :param next_run: Dictionary to set in last run

        :return: None
        """
        if total:
            if total > MAX_PRODUCT:  # type: ignore
                raise ValueError(MESSAGES['TIME_RANGE_ERROR'].format(total))
            next_run['total'] = total


    def prepare_checkpoint_and_related_objects(hits: List, hit_ids: List, next_run: dict) -> None:
        """
        Prepare checkpoint and related objects for incidents of type compromised credentials.

        :param hits: List of compromised credentials
        :param hit_ids: List of ids of compromised credentials
        :param next_run: Dictionary to set in last run

        :return: None
        """
        indexed_at = hits[-1].get('_source', {}).get('header_', {}).get('indexed_at')
        indexed_at_date = datetime.utcfromtimestamp(float(indexed_at))
        indexed_at_date = indexed_at_date.strftime(DATE_FORMAT)
        next_run['last_time'] = indexed_at_date

        if next_run.get('last_timestamp'):
            if next_run['last_timestamp'] == indexed_at:
                next_run['hit_ids'] += hit_ids
            else:
                next_run['hit_ids'] = hit_ids
        else:
            next_run['hit_ids'] = hit_ids

        next_run['last_timestamp'] = indexed_at


    def prepare_next_run_when_data_is_present(next_run: dict, start_time: str) -> None:
        """
        Prepare next run when data is present.

        :param next_run: Dictionary to set in last run
        :param start_time:  Date time saved of the last fetch

        :return: None
        """
        next_run['start_time'] = start_time
        next_run['fetch_count'] = next_run['fetch_count'] + 1


    def prepare_next_run_when_data_is_empty(next_run: dict, hits: List) -> None:
        """
        Prepare next run when data is present.

        :param next_run: Dictionary to set in last run
        :param hits: List of compromised credentials

        :return: None
        """
        if hits:
            next_run['start_time'] = next_run['last_time']
        next_run['fetch_count'] = 0
        next_run['fetch_sum'] = 0
        next_run['total'] = None


    def prepare_incidents_from_compromised_credentials_data(response: dict, next_run: dict,
                                                            start_time: str) -> Tuple[dict, list]:
        """
        Prepare incidents from the compromised credentials data.

        :param response: Response from the compromised credentials API
        :param next_run: Dictionary to set in last run
        :param start_time: Date time saved of the last fetch

        :return: Tuple of dictionary of next run and list of fetched incidents
        """
        incidents = []
        total = arg_to_number(response.get('hits', {}).get('total'))
        check_value_of_total_records(total, next_run)

        hits = response.get('hits', {}).get('hits', [])

        hit_ids = [hit['_id'] for hit in hits]
        hits = remove_duplicate_records(hits, DEFAULT_FETCH_TYPE, next_run)

        for hit in hits:
            name = hit.get('_source', {}).get('email')
            if not name:
                name = hit.get('_source', {}).get('fpid', 'Compromised Credential Alert')
            incidents.append({
                'name': name,
                'occurred': hit.get('_source', {}).get('breach', {}).get('created_at', {}).get('date-time'),
                'rawJSON': json.dumps(hit)
            })

        if hits:
            prepare_checkpoint_and_related_objects(hits, hit_ids, next_run)

        if total > next_run['fetch_sum']:
            # If more records are available, then increase the fetch count
            prepare_next_run_when_data_is_present(next_run, start_time)
        else:
            prepare_next_run_when_data_is_empty(next_run, hits)

        return next_run, incidents


    def remove_space_from_args(args):
        """Remove space from args."""
        for key in args.keys():
            if isinstance(args[key], str):
                args[key] = args[key].strip()
        return args


    def create_relationships_list(client, events_details, ip):
        """Create relationships list from given data."""
        relationships = []
        if client.create_relationships and events_details.get('attack_ids'):
            for attack_id in events_details.get('attack_ids'):
                relationships.append(
                    EntityRelationship(name='indicator-of',
                                       entity_a=ip,
                                       entity_a_type=FeedIndicatorType.IP,
                                       entity_b=attack_id,
                                       entity_b_type=FeedIndicatorType.indicator_type_by_server_version(
                                           STIX_ATTACK_PATTERN),
                                       brand=BRAND))
        return relationships


    ''' FUNCTIONS '''


    def test_module(client: Client, params: Dict) -> None:
        """
        Test the Flashpoint instance configuration.

        :param: client: Object of Client class
        :param: params: Dictionary containing demisto configuration parameters
        :return: None
        """
        client.http_request(method="GET", url_suffix='/indicators/simple', params={"limit": 1})
        is_fetch = params.get('isFetch')
        if is_fetch:
            fetch_incidents(client, {}, params)


    def ip_lookup_command(client, ip):
        """
        Lookup a particular ip-address.

        This command searches for the ip in Flashpoint's IOC Dataset. If found, mark it as Malicious.
        If not found, lookup in Torrents for matching peer ip. If found, mark it as Suspicious.
        If not found, lookup in Forums for matching ip. If found, mark it as Suspicious.

        :param client: object of client class
        :param ip: ip-address
        :return: command output
        """
        if not is_ip_valid(ip, True):
            raise ValueError("Invalid ip - " + ip)

        query = QUERY + urllib.parse.quote(ip.encode('utf-8')) + '"'
        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        indicators = []
        if isinstance(resp, list):
            indicators = resp

        if len(indicators) > 0:

            hr = HR_TITLE + ip + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            # Constructing FP Deeplink
            fp_link = \
                client.url + '/home/search/iocs?group=indicator&ioc_type=ip-dst%2Cip-src%2Cip-dst%7Cport&ioc_value=' + ip
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)
            dbot_score = Common.DBotScore(
                indicator=ip,
                indicator_type=DBotScoreType.IP,
                integration_name=BRAND,
                score=3,
                malicious_description=MALICIOUS_DESCRIPTION

            )
            relationships = create_relationships_list(client, events_details, ip)
            ip_ioc = Common.IP(ip=ip, dbot_score=dbot_score, relationships=relationships)

            flashpoint_ip_context = []
            for indicator in resp:
                indicator = indicator.get("Attribute", {})
                event = {
                    'Address': ip,
                    'EventDetails': indicator.get('Event'),
                    'Category': indicator.get('category', ''),
                    'Fpid': indicator.get('fpid', ''),
                    'Href': indicator.get('href', ''),
                    'Timestamp': indicator.get('timestamp', ''),
                    'Type': indicator.get('type', ''),
                    'Uuid': indicator.get('uuid', ''),
                    'Comment': indicator['value'].get('comment', '')
                }
                flashpoint_ip_context.append(event)

            command_results = CommandResults(
                outputs_prefix='Flashpoint.IP.Event',
                outputs_key_field='Fpid',
                outputs=flashpoint_ip_context,
                readable_output=hr,
                indicator=ip_ioc,
                raw_response=resp,
                relationships=relationships
            )
            return command_results

        else:
            # Search for IP in torrents
            torrent_search_url_suffix = '/all/search?query=+basetypes:(+torrent) +is_verified:true ' \
                                        '+ip_address:("' + urllib.parse.quote(ip.encode('utf-8')) + \
                                        '")&limit=10&_source_includes=ip_address'
            torrent_resp = client.http_request("GET", url_suffix=torrent_search_url_suffix)
            torrent_result = torrent_resp.get('hits').get('hits', [])

            if torrent_result:
                torrent_search_link = client.url + '/home/search/torrents?ip_address=' + ip

                hr = HR_TITLE + ip + '\n'
                hr += 'Reputation: Suspicious\n\n'
                hr += 'FP tools link to torrent search: [{}]({})\n'.format(torrent_search_link, torrent_search_link)

                ec = {
                    FLASHPOINT_PATHS['IP']: {
                        "Address": ip
                    },
                    'DBotScore': {
                        'Indicator': ip,
                        'Type': 'ip',
                        'Vendor': 'Flashpoint',
                        'Score': 2
                    }
                }
                command_results = CommandResults(
                    outputs=ec,
                    readable_output=hr,
                    raw_response=resp,
                )
            else:
                # Search for IP in Forums
                forum_search_url_suffix = '/forums/visits?ip_address=' + urllib.parse.quote(ip.encode('utf-8'))
                forum_resp = client.http_request("GET", url_suffix=forum_search_url_suffix)
                forum_result = forum_resp.get('data', [])

                if forum_result:
                    forum_search_link = client.url + '/home/search/visits?exclude_tor_nodes_and_known_proxies=true' \
                                                     '&ip_address=' + ip

                    hr = HR_TITLE + ip + '\n'
                    hr += 'Reputation: Suspicious\n\n'
                    hr += 'FP tools link to Forum-visit search: [{}]({})\n'.format(forum_search_link, forum_search_link)

                    ec = {
                        FLASHPOINT_PATHS['IP']: {
                            "Address": ip
                        },
                        'DBotScore': {
                            'Indicator': ip,
                            'Type': 'ip',
                            'Vendor': 'Flashpoint',
                            'Score': 2
                        }
                    }
                    command_results = CommandResults(
                        outputs=ec,
                        readable_output=hr,
                        raw_response=resp,
                    )
                else:
                    hr = HR_TITLE + ip + '\n'
                    hr += REPUTATION_UNKNOWN
                    ec = {
                        'DBotScore': {
                            'Indicator': ip,
                            'Type': 'ip',
                            'Vendor': 'Flashpoint',
                            'Score': 0
                        }
                    }
                    command_results = CommandResults(
                        outputs=ec,
                        readable_output=hr,
                        raw_response=resp,
                    )

            return command_results


    def domain_lookup_command(client, domain):
        """
        Lookup a particular domain.

        :param client: object of client class
        :param domain: domain
        :return: command output
        """
        query = r'+type:("domain") +value.\*.keyword:"' + domain + '"'
        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        if isinstance(resp, list):
            indicators = resp
        else:
            indicators = []

        if len(indicators) > 0:

            hr = '### Flashpoint Domain reputation for ' + domain + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            fp_link = client.url + '/home/search/iocs?group=indicator&ioc_type=domain&ioc_value=' + domain
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            dbot_score = Common.DBotScore(
                indicator=domain,
                indicator_type=DBotScoreType.DOMAIN,
                integration_name=BRAND,
                score=3,
                malicious_description=MALICIOUS_DESCRIPTION

            )
            relationships = []
            if client.create_relationships:
                if events_details.get('attack_ids'):
                    for attack_id in events_details.get('attack_ids'):
                        relationships.append(
                            EntityRelationship(name='indicator-of',
                                               entity_a=domain,
                                               entity_a_type=FeedIndicatorType.Domain,
                                               entity_b=attack_id,
                                               entity_b_type=FeedIndicatorType.indicator_type_by_server_version(
                                                   STIX_ATTACK_PATTERN),
                                               brand=BRAND))

            domain_ioc = Common.Domain(domain=domain, dbot_score=dbot_score, relationships=relationships)

            flashpoint_domain_context = []
            for indicator in resp:
                indicator = indicator.get("Attribute", {})
                event = {
                    'Domain': domain,
                    'Category': indicator.get('category', ''),
                    'Fpid': indicator.get('fpid', ''),
                    'Href': indicator.get('href', ''),
                    'Timestamp': indicator.get('timestamp', ''),
                    'Type': indicator.get('type'),
                    'Uuid': indicator.get('uuid', ''),
                    'EventDetails': indicator.get('Event', []),
                    'Comment': indicator['value'].get('comment', '')
                }
                flashpoint_domain_context.append(event)

            command_results = CommandResults(
                outputs_prefix='Flashpoint.Domain.Event',
                outputs_key_field='Fpid',
                outputs=flashpoint_domain_context,
                readable_output=hr,
                indicator=domain_ioc,
                raw_response=resp,
                relationships=relationships
            )
            return command_results

        else:
            hr = '### Flashpoint Domain reputation for ' + domain + '\n'
            hr += REPUTATION_UNKNOWN
            ec = {
                'DBotScore': {
                    'Indicator': domain,
                    'Type': 'domain',
                    'Vendor': 'Flashpoint',
                    'Score': 0
                }
            }
            command_results = CommandResults(
                outputs=ec,
                readable_output=hr,
                raw_response=resp,
            )

            return command_results


    def filename_lookup_command(client, filename):
        """
        Lookup a particular filename.

        :param client: object of client class
        :param filename: filename
        :return: command output
        """
        query = r'+type:("filename") +value.\*.keyword:"' + filename.replace('\\', '\\\\') + '"'
        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        if isinstance(resp, list):
            indicators = resp
        else:
            indicators = []

        if len(indicators) > 0:

            hr = '### Flashpoint Filename reputation for ' + filename + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            fp_link = client.url + '/home/search/iocs?query_i18n=en&query=%22' + urllib.parse.quote(
                filename.replace('\\', '\\\\').encode('utf8')) + '%22'
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            dbot_context = {
                'Indicator': filename,
                'Type': 'filename',
                'Vendor': 'Flashpoint',
                'Score': 3
            }

            filename_context = {
                'Name': filename,
                'Malicious': {
                    'Vendor': 'Flashpoint',
                    'Description': MALICIOUS_DESCRIPTION
                }

            }

            flashpoint_filename_context = []
            for indicator in resp:
                indicator = indicator.get("Attribute", {})
                event = {
                    'Filename': filename,
                    'Category': indicator.get('category', ''),
                    'Fpid': indicator.get('fpid', ''),
                    'Href': indicator.get('href', ''),
                    'Timestamp': indicator.get('timestamp', ''),
                    'Type': indicator.get('type'),
                    'Uuid': indicator.get('uuid', ''),
                    'EventDetails': indicator.get('Event', []),
                    'Comment': indicator['value'].get('comment', '')
                }
                flashpoint_filename_context.append(event)

            ec = {
                'DBotScore': dbot_context,
                'Filename(val.Name == obj.Name)': filename_context,
                FLASHPOINT_PATHS['Filename']: flashpoint_filename_context
            }

            return hr, ec, resp

        else:
            hr = '### Flashpoint Filename reputation for ' + filename + '\n'
            hr += REPUTATION_UNKNOWN
            ec = {
                'DBotScore': {
                    'Indicator': filename,
                    'Type': 'filename',
                    'Vendor': 'Flashpoint',
                    'Score': 0
                }
            }

            return hr, ec, resp


    def url_lookup_command(client, url):
        """
        Lookup a particular url.

        :param client: object of client class
        :param url: url as indicator
        :return: command output
        """
        encoded_url = urllib.parse.quote(url.encode('utf8'))

        query = r'+type:("url") +value.\*:"' + url + '"'
        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        if isinstance(resp, list):
            indicators = resp
        else:
            indicators = []

        if len(indicators) > 0:

            hr = '### Flashpoint URL reputation for ' + url + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            fp_link = client.url + '/home/search/iocs?query_i18n=en&query=%22' + encoded_url + '%22'
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            dbot_score = Common.DBotScore(
                indicator=url,
                indicator_type=DBotScoreType.URL,
                integration_name=BRAND,
                score=3,
                malicious_description=MALICIOUS_DESCRIPTION
            )

            relationships = []
            if client.create_relationships:
                if events_details.get('attack_ids'):
                    for attack_id in events_details.get('attack_ids'):
                        relationships.append(
                            EntityRelationship(name='indicator-of',
                                               entity_a=url,
                                               entity_a_type=FeedIndicatorType.URL,
                                               entity_b=attack_id,
                                               entity_b_type=FeedIndicatorType.indicator_type_by_server_version(
                                                   STIX_ATTACK_PATTERN),
                                               brand=BRAND))

            url_ioc = Common.URL(url=url, dbot_score=dbot_score, relationships=relationships)

            flashpoint_url_context = []
            for indicator in resp:
                indicator = indicator.get("Attribute", {})
                event = {
                    'Fpid': indicator.get('fpid', ''),
                    'EventDetails': indicator['Event'],
                    'Category': indicator.get('category', ''),
                    'Href': indicator.get('href', ''),
                    'Timestamp': indicator.get('timestamp', ''),
                    'Type': indicator.get('type', ''),
                    'Uuid': indicator.get('uuid', ''),
                    'Comment': indicator['value'].get('comment', ''),
                    'Url': indicator['value']['url']
                }
                flashpoint_url_context.append(event)

            command_results = CommandResults(
                outputs_prefix='Flashpoint.URL.Event',
                outputs_key_field='Fpid',
                outputs=flashpoint_url_context,
                readable_output=hr,
                indicator=url_ioc,
                raw_response=resp,
                relationships=relationships
            )
            return command_results

        else:
            hr = '### Flashpoint URL reputation for ' + url + '\n'
            hr += REPUTATION_UNKNOWN
            ec = {
                'DBotScore': {
                    'Indicator': url,
                    'Type': 'url',
                    'Vendor': 'Flashpoint',
                    'Score': 0
                }
            }
            command_results = CommandResults(
                outputs=ec,
                readable_output=hr,
                raw_response=resp,
            )

            return command_results


    def file_lookup_command(client, file):
        """
        Lookup a particular file hash (md5, sha1, sha256, sha512).

        :param client: object of client class
        :param file: file as indicator
        :return: command output
        """
        query = r'+type:("md5", "sha1", "sha256", "sha512") +value.\*.keyword:"' + file + '"'
        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        indicators = []
        if isinstance(resp, list):
            indicators = resp

        if len(indicators) > 0:
            indicator_type = (indicators[0].get('Attribute', {}).get('type')).upper()
            hr = '### Flashpoint File reputation for ' + file + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            fp_link = client.url + '/home/search/iocs?group=indicator&ioc_type=md5%2Csha1%2Csha256%2Csha512' \
                                   '&ioc_value=' + urllib.parse.quote(file.encode('utf8'))

            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            dbot_score = Common.DBotScore(
                indicator=file,
                indicator_type=DBotScoreType.FILE,
                integration_name=BRAND,
                score=3,
                malicious_description=MALICIOUS_DESCRIPTION
            )

            relationships = []
            if client.create_relationships and events_details.get('attack_ids'):
                for attack_id in events_details.get('attack_ids'):
                    relationships.append(
                        EntityRelationship(name='indicator-of',
                                           entity_a=file,
                                           entity_a_type=DBotScoreType.FILE,
                                           entity_b=attack_id,
                                           entity_b_type=FeedIndicatorType.indicator_type_by_server_version(
                                               STIX_ATTACK_PATTERN),
                                           brand=BRAND))

            hash_type = get_hash_type(file)  # if file_hash found, has to be md5, sha1 or sha256
            if hash_type == 'md5':
                file_ioc = Common.File(md5=file, dbot_score=dbot_score, relationships=relationships)
            elif hash_type == 'sha1':
                file_ioc = Common.File(sha1=file, dbot_score=dbot_score, relationships=relationships)
            else:
                file_ioc = Common.File(sha256=file, dbot_score=dbot_score, relationships=relationships)

            flashpoint_file_context = []
            for indicator in resp:
                indicator = indicator.get("Attribute", {})
                event = {
                    str(indicator_type).upper(): file,
                    'EventDetails': indicator.get('Event'),
                    'Category': indicator.get('category', ''),
                    'Fpid': indicator.get('fpid', ''),
                    'Href': indicator.get('href', ''),
                    'Timestamp': indicator.get('timestamp', ''),
                    'Type': indicator.get('type', ''),
                    'Uuid': indicator.get('uuid', ''),
                    'Comment': indicator['value'].get('comment', '')
                }
                flashpoint_file_context.append(event)

            command_results = CommandResults(
                outputs_prefix='Flashpoint.File.Event',
                outputs_key_field='Fpid',
                outputs=flashpoint_file_context,
                readable_output=hr,
                indicator=file_ioc,
                raw_response=resp,
                relationships=relationships
            )
            return command_results

        else:
            hr = '### Flashpoint File reputation for ' + file + '\n'
            hr += REPUTATION_UNKNOWN
            ec = {
                'DBotScore':
                    [
                        {
                            'Indicator': file,
                            'Type': 'file',
                            'Vendor': 'Flashpoint',
                            'Score': 0
                        },
                        {
                            'Indicator': file,
                            'Type': 'hash',
                            'Vendor': 'Flashpoint',
                            'Score': 0
                        }

                    ]
            }
            command_results = CommandResults(
                outputs=ec,
                readable_output=hr,
                raw_response=resp,
            )
            return command_results


    def email_lookup_command(client, email):
        """
        Lookup a particular email address or subject.

        :param client: object of client class
        :param email: email address or subject
        :return: command output
        """
        query = r'+type:("email-dst", "email-src", "email-src-display-name", "email-subject", "email") +value.\*.keyword:"' \
                + email + '" '
        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        if isinstance(resp, list):
            indicators = resp
        else:
            indicators = []

        if len(indicators) > 0:

            hr = '### Flashpoint Email reputation for ' + email + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            fp_link = \
                client.url + '/home/search/iocs?query_i18n=en&query=%22' + urllib.parse.quote(email.encode('utf8')) + '%22'
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            email_context = {
                'Name': email,
                'Malicious': {
                    'Vendor': 'Flashpoint',
                    'Description': MALICIOUS_DESCRIPTION
                }
            }

            dbot_context = {
                'Indicator': email,
                'Type': 'email',
                'Vendor': 'Flashpoint',
                'Score': 3
            }

            flashpoint_email_context = []
            for indicator in resp:
                indicator = indicator.get("Attribute", {})
                event = {
                    'EventDetails': indicator.get('Event', ''),
                    'Category': indicator.get('category', ''),
                    'Fpid': indicator.get('fpid', ''),
                    'Href': indicator.get('href', ''),
                    'Timestamp': indicator.get('timestamp', ''),
                    'Type': indicator.get('type', ''),
                    'Uuid': indicator.get('uuid', ''),
                    'Comment': indicator['value'].get('comment', '')
                }
                flashpoint_email_context.append(event)

            ec = {
                'DBotScore': dbot_context,
                outputPaths['email']: email_context,
                FLASHPOINT_PATHS['Email']: flashpoint_email_context
            }

            return hr, ec, resp

        else:
            hr = '### Flashpoint Email reputation for ' + email + '\n'
            hr += REPUTATION_UNKNOWN
            ec = {
                'DBotScore': {
                    'Indicator': email,
                    'Type': 'email',
                    'Vendor': 'Flashpoint',
                    'Score': 0
                }
            }

            return hr, ec, resp


    def common_lookup_command(client, indicator_value):
        """
        Lookup all types of the indicators.

        :param client: object of client class
        :param indicator_value: value of the indicator to lookup
        :return: command output
        """
        encoded_value = urllib.parse.quote(indicator_value.encode('utf8'))

        try:
            ipaddress.ip_address(indicator_value)
            query = QUERY + indicator_value + '"'
        except ValueError:
            try:
                ipaddress.IPv6Address(indicator_value)
                query = QUERY + indicator_value + '"'
            except ValueError:
                query = r'+value.\*.keyword:"' + indicator_value + '"'

        resp = client.http_request("GET", url_suffix=get_url_suffix(query))

        if isinstance(resp, list):
            indicators = resp
        else:
            indicators = []

        if len(indicators) > 0:

            indicator_type = indicators[0].get('Attribute', {}).get('type')

            hr = '### Flashpoint reputation for ' + indicator_value + '\n'
            hr += REPUTATION_MALICIOUS

            events_details = parse_indicator_response(indicators)

            hr += tableToMarkdown(TABLE_TITLE, events_details['events'],
                                  [DATE_OBSERVED, 'Name', 'Tags'])

            fp_link = client.url + '/home/search/iocs?query_i18n=en&query=%22' + encoded_value + '%22'
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            ec = {'DBotScore': {
                'Indicator': indicator_value,
                'Type': indicator_type,
                'Vendor': 'Flashpoint',
                'Score': 3
            }}

            return hr, ec, resp

        else:
            hr = '### Flashpoint reputation for ' + indicator_value + '\n'
            hr += REPUTATION_UNKNOWN
            ec = {}

            return hr, ec, resp


    def get_reports_command(client, args):
        """
        Get reports matching the given search term or query.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        report_search = args.get('report_search')
        url_suffix = '/reports/?query=' + urllib.parse.quote(report_search) + '&limit=5'
        resp = client.http_request("GET", url_suffix=url_suffix)
        reports = resp.get("data", [])

        hr = '### Flashpoint Intelligence reports related to search: ' + report_search + '\n'
        ec: Dict[Any, Any] = {}

        if reports:
            hr += 'Top 5 reports:\n\n'
            report_details = []
            index = 0
            for report in reports:
                title = report.get('title', 'N/A')
                platform_url = report.get('platform_url', '')
                summary = report.get('summary', 'N/A')
                index += 1
                hr += '' + str(index) + ') [{}]({})'.format(title, platform_url) + '\n'
                if report.get('summary'):
                    hr += '   Summary: ' + str(summary) + '\n\n\n'
                else:
                    hr += '   Summary: N/A\n\n\n'

                report_detail = {
                    'ReportId': report.get('id', 'N/A'),
                    'UpdatedAt': report.get('updated_at', ''),
                    'PostedAt': report.get('posted_at', ''),
                    'NotifiedAt': report.get('notified_at', ''),
                    'PlatformUrl': platform_url,
                    'Title': title,
                    'Summary': summary
                }
                report_details.append(report_detail)

            fp_url = client.url + '/home/search/reports?query=' + urllib.parse.quote(report_search)
            hr += 'Link to Report-search on Flashpoint platform: [{}]({})\n'.format(fp_url, fp_url)

            ec[FLASHPOINT_PATHS['Report']] = report_details

        else:
            hr += 'No reports found for the search.'

        return hr, ec, resp


    def get_report_by_id_command(client, args):
        """
        Get specific report using its fpid.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        report_id = args.get('report_id')
        url_suffix = '/reports/' + urllib.parse.quote(report_id.encode('utf-8'))
        resp = client.http_request("GET", url_suffix=url_suffix)
        report = resp

        hr = '### Flashpoint Intelligence Report details\n'
        ec: Dict[Any, Any] = {}

        if report:

            if report.get('tags') is None:
                raise ValueError("No record found for given argument(s): Not Found")

            timestamp = None
            try:
                time_str = report.get('posted_at', '')[:-10] + 'UTC'
                timestamp = time.strptime(time_str, '%Y-%m-%dT%H:%M:%S%Z')
            except TypeError:
                pass
            except ValueError:
                pass

            tags = report.get('tags', [])
            tag_string = ""
            for tag in tags:
                tag_string += ", " + str(tag)
            if tag_string:
                tag_string = tag_string[2:]

            if timestamp:
                timestamp_str = time.strftime(READABLE_DATE_FORMAT, timestamp)
            else:
                timestamp_str = 'N/A'

            report_details = [{
                'Title': STRING_FORMAT.format(report.get('title', 'N/A'), report.get('platform_url', '')),
                'Date Published (UTC)': timestamp_str,
                'Summary': report.get('summary', 'N/A'),
                'Tags': tag_string
            }]

            hr += tableToMarkdown('Below are the details found:', report_details,
                                  ['Title', 'Date Published (UTC)', 'Summary', 'Tags'])
            hr += '\n'
            ec[FLASHPOINT_PATHS['Report']] = {
                'ReportId': report.get('id', ''),
                'UpdatedAt': report.get('updated_at', ''),
                'PostedAt': report.get('posted_at', ''),
                'NotifiedAt': report.get('notified_at', ''),
                'PlatformUrl': report.get('platform_url', ''),
                'Title': report.get('title', ''),
                'Summary': report.get('summary', '')
            }

        else:
            hr += 'No report found for the given ID.'

        return hr, ec, resp


    def get_related_reports_command(client, args):
        """
        Get reports related to given report.

        :param args: demisto args
        :param client: object of client class
        :return: command output
        """
        report_id = args.get('report_id')
        url_suffix = '/reports/' + urllib.parse.quote(report_id.encode('utf-8')) + '/related?limit=5'
        resp = client.http_request("GET", url_suffix=url_suffix)
        reports = resp.get("data", [])

        hr = '### Flashpoint Intelligence related reports:\n'
        ec: Dict[Any, Any] = {}

        if reports:
            hr += 'Top 5 related reports:\n\n'
            report_details = []
            index = 0
            for report in reports:
                title = report.get('title', 'N/A')
                platform_url = report.get('platform_url', '')
                summary = report.get('summary', 'N/A')
                index += 1
                hr += '' + str(index) + ') [{}]({})'.format(title, platform_url) + '\n'
                hr += '   Summary: ' + str(summary) + '\n\n\n'
                report_detail = {
                    'ReportId': report.get('id', 'N/A'),
                    'UpdatedAt': report.get('updated_at', ''),
                    'PostedAt': report.get('posted_at', ''),
                    'NotifiedAt': report.get('notified_at', ''),
                    'PlatformUrl': platform_url,
                    'Title': title,
                    'Summary': summary
                }
                report_details.append(report_detail)

            fp_url = client.url + '/home/intelligence/reports/report/' + report_id + '#detail'
            hr += 'Link to the given Report on Flashpoint platform: [{}]({})\n'.format(fp_url, fp_url)
            ec[FLASHPOINT_PATHS['Report']] = report_details

        else:
            hr += 'No related reports found for the search.'

        return hr, ec, resp


    def get_event_by_id_command(client, args):
        """
        Get specific event using its event id.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        event_id = args.get('event_id')
        url_suffix = '/indicators/event/' + urllib.parse.quote(event_id.encode('utf-8'))
        resp = client.http_request("GET", url_suffix=url_suffix)

        hr = '### Flashpoint Event details\n'
        ec: Dict[Any, Any] = {}

        if len(resp) <= 0:
            hr += 'No event found for the given ID.'
            return hr, ec, resp

        event = resp[0].get('Event', '')
        fpid = resp[0].get('fpid', '')
        href = resp[0].get('href', '')

        events = []
        if event:
            event = parse_event_response(client, event, fpid, href)
            if resp[0].get('malware_description'):
                event['Malware Description'] = resp[0].get('malware_description', '')
            events.append(event)
            hr += tableToMarkdown('Below are the detail found:', events,
                                  [TIME_OBSERVED, 'Name', 'Tags', 'Malware Description'])

            ec[FLASHPOINT_PATHS['Event']] = {
                'EventId': events[0]['EventId'],
                'Name': events[0]['Name'],
                'Tags': events[0]['Tags'],
                'ObservedTime': events[0][TIME_OBSERVED],
                'EventCreatorEmail': event['EventCreatorEmail'],
                'Href': href
            }
            # if no key `malware_description` is present, it should not be included in context data
            if event.get('Malware Description'):
                ec[FLASHPOINT_PATHS['Event']]['MalwareDescription'] = event['Malware Description']

        return hr, ec, resp


    def get_events_command(client, args):
        """
        Get events matching the given parameters.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        limit = args.get('limit', 10)
        report_fpid = args.get('report_fpid')
        attack_ids = args.get('attack_ids')
        time_period = args.get('time_period')
        url_suffix = '/indicators/event?sort_timestamp=desc&'
        getvars = {}
        if limit:
            getvars['limit'] = limit

        if report_fpid:
            getvars['report'] = report_fpid

        if attack_ids:
            getvars['attack_ids'] = attack_ids

        if time_period:
            getvars['time_period'] = time_period

        url_suffix = url_suffix + urllib.parse.urlencode(getvars)

        resp = client.http_request("GET", url_suffix=url_suffix)
        indicators = resp
        hr = ''
        ec: Dict[Any, Any] = {}
        if len(indicators) > 0:
            hr += '### Flashpoint Events\n\n'

            events = []
            for indicator in indicators:
                href = indicator.get('href', '')
                event = indicator.get('Event', {})
                fpid = indicator.get('fpid', '')
                event = parse_event_response(client, event, fpid, href)
                if indicator.get('malware_description'):
                    event['Malware Description'] = indicator.get('malware_description')
                events.append(event)

            hr += tableToMarkdown('Below are the detail found:', events,
                                  [TIME_OBSERVED, 'Name', 'Tags', 'Malware Description'])

            fp_link = client.url + '/home/search/iocs'
            if attack_ids:
                fp_link = fp_link + '?attack_ids=' + urllib.parse.quote(attack_ids)
            hr += ALL_DETAILS_LINK.format(fp_link, fp_link)

            # Replacing the dict keys for ec  to strip any white spaces and special charcters
            for event in events:
                replace_key(event, 'ObservedTime', TIME_OBSERVED)
                replace_key(event, 'MalwareDescription', 'Malware Description')

            ec[FLASHPOINT_PATHS['Event']] = events

        else:
            hr += 'No event found for the argument.'

        return hr, ec, resp


    def get_forum_details_by_id_command(client, args):
        """
        Get specific forum details by its fpid.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        forum_id = args.get('forum_id')
        url_suffix = '/forums/sites/' + urllib.parse.quote(forum_id.encode('utf-8'))
        resp = client.http_request("GET", url_suffix=url_suffix)

        hr = '### Flashpoint Forum details\n'
        ec = {}

        if resp:
            forum_details = parse_forum_response(resp)
            hr += tableToMarkdown('Below are the details found:', forum_details, ['Name', 'Hostname', 'Tags'])
            hr += '\n'

            ec[FLASHPOINT_PATHS['Forum']] = {
                'ForumId': resp['id'],
                'Hostname': resp['hostname'],
                'Description': resp['description'],
                'Name': resp['name'],
                'Stats': resp['stats'],
                'Tags': resp['tags']
            }

        else:
            hr += 'No forum detail found for given forum id.'

        return hr, ec, resp


    def get_room_details_by_id_command(client, args):
        """
        Get room details by its room id.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        room_id = args.get('room_id')
        url_suffix = '/forums/rooms/' + urllib.parse.quote(room_id.encode('utf-8')) + '?embed=forum'
        resp = client.http_request("GET", url_suffix=url_suffix)

        hr = '### Flashpoint Room details\n'
        ec = {}

        if resp:
            forum_name = resp['embed']['forum']['name']
            url = resp.get('url', '')
            title = resp.get('title', '')

            room_details = {
                FORUM_NAME: forum_name,
                'Title': title,
                'URL': url
            }

            hr += tableToMarkdown('Below are the detail found:', room_details, [FORUM_NAME, 'Title', 'URL'])
            hr += '\n'

            ec[FLASHPOINT_PATHS['Room']] = {
                'RoomId': resp['id'],
                'Title': title,
                'Url': url,
                'Forum': resp['embed']['forum']
            }

        else:
            hr += 'No room details found for given room id'

        return hr, ec, resp


    def get_user_details_by_id_command(client, args):
        """
        Get user details by user's fpid.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        user_id = args.get('user_id')
        url_suffix = '/forums/users/' + urllib.parse.quote(user_id.encode('utf-8')) + '?embed=forum'
        resp = client.http_request("GET", url_suffix=url_suffix)

        hr = '### Flashpoint User details\n'
        ec = {}

        if resp:
            forum_name = resp['embed']['forum']['name']
            url = resp.get('url', '')
            name = resp.get('name', '')

            user_details = {
                FORUM_NAME: forum_name,
                'Name': name,
                'URL': url
            }

            hr += tableToMarkdown('Below are the detail found:', user_details, [FORUM_NAME, 'Name', 'URL'])
            hr += '\n'

            ec[FLASHPOINT_PATHS['User']] = {
                'UserId': resp['id'],
                'Name': name,
                'Url': url,
                'PlatformUrl': resp.get('platform_url', ''),
                'Forum': resp['embed']['forum']
            }

        else:
            hr += 'No user details found for given user id'

        return hr, ec, resp


    def get_post_details_by_id_command(client, args):
        """
        Get forum post details by post's fpid.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        post_id = args.get('post_id')
        url_suffix = '/forums/posts/' + urllib.parse.quote(
            post_id.encode('utf-8')) + '?body_html=stripped&embed=author,room,forum,thread'
        resp = client.http_request("GET", url_suffix=url_suffix)

        hr = '### Flashpoint Post details\n'
        ec = {}

        if resp:
            published_at = resp.get('published_at', '')
            url = resp.get('url', '')
            platform_url = resp.get('platform_url', '')
            forum_name = resp['embed']['forum']['name']
            room_title = resp['embed']['room']['title']
            author_name = resp['embed']['author']['name']
            thread_title = resp['embed']['thread']['title']

            post_details = {
                'Published at': published_at,
                FORUM_NAME: forum_name,
                ROOM_TITLE: room_title,
                AUTHOR_NAME: author_name,
                THREAD_TITLE: thread_title,
                'URL': url,
                'Platform url': "[{}]({})".format(platform_url, platform_url)
            }

            hr += tableToMarkdown('Below are the detail found:', post_details,
                                  ['Published at', FORUM_NAME, ROOM_TITLE, AUTHOR_NAME, THREAD_TITLE, 'URL',
                                   'Platform url'])
            hr += '\n'
            post_ec = get_post_context(resp)
            ec[FLASHPOINT_PATHS['Post']] = post_ec

        else:
            hr += 'No post details found for given post id'

        return hr, ec, resp


    def get_forum_sites_command(client, args):
        """
        Get forum sites matching search keyword or query.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        site_search = args.get('site_search')
        url_suffix = '/forums/sites/?query=' + urllib.parse.quote(site_search.encode('utf8')) + '&limit=10'
        resp = client.http_request("GET", url_suffix=url_suffix)
        sites = resp.get("data", [])

        hr = '### Flashpoint Forum sites related to search: ' + site_search + '\n'
        ec: Dict[Any, Any] = {}

        if sites:
            hr += 'Top 10 sites:\n\n'
            site_details = []
            for site in sites:
                site_detail = {
                    'SiteId': site.get('id', ''),
                    'Name': site.get('name', 'N/A'),
                    'Hostname': site.get('hostname', 'N/A'),
                    'Description': site.get('description', 'N/A'),
                    'PlatformUrl': site.get('platform_url', ''),
                    'Tags': site.get('tags', [])
                }

                site_details.append(site_detail)

            hr += tableToMarkdown('Below are the detail found:', site_details, ['Name', 'Hostname', 'Description'])
            hr += '\n'

            ec = {
                FLASHPOINT_PATHS['Site']: site_details
            }

        else:
            hr += 'No forum sites found for the search'

        return hr, ec, resp


    def get_forum_posts_command(client, args):
        """
        Get forum posts details matching given keyword or query.

        :param client: object of client class
        :param args: demisto args
        :return: command output
        """
        post_search = args.get('post_search')
        url_suffix = '/forums/posts/?query=' + urllib.parse.quote(
            post_search.encode('utf8')) + '&limit=10&embed=forum,room,author,thread'
        resp = client.http_request("GET", url_suffix=url_suffix)
        posts = resp.get("data", [])

        hr = '### Flashpoint Forum posts related to search: ' + post_search + '\n'
        ec: Dict[Any, Any] = {}

        if posts:
            hr += 'Top 10 posts:\n\n'
            post_details = []
            post_entry_context = []
            for post in posts:
                platform_url = post.get('platform_url', '')
                thread_title = post['embed']['thread']['title']
                post_ec = get_post_context(post)
                post_entry_context.append(post_ec)
                post_detail = {
                    FORUM_NAME: post['embed']['forum']['name'],
                    THREAD_TITLE: thread_title[:30] + '....',
                    ROOM_TITLE: post['embed']['room']['title'],
                    AUTHOR_NAME: post['embed']['author']['name'],
                    'Platform URL': STRING_FORMAT.format(platform_url[:30] + '...', platform_url)
                }
                post_details.append(post_detail)

            hr += tableToMarkdown('Below are the detail found:', post_details,
                                  [FORUM_NAME, THREAD_TITLE, ROOM_TITLE, AUTHOR_NAME, 'Platform URL'])
            hr += '\n'

            fp_url = client.url + '/home/search/forums?query=' + urllib.parse.quote(post_search.encode('utf8'))
            hr += 'Link to forum post-search on Flashpoint platform: [{}]({})\n'.format(fp_url, fp_url)

            ec[FLASHPOINT_PATHS['Post']] = post_entry_context

        else:
            hr += 'No forum posts found for the search'

        return hr, ec, resp


    def flashpoint_alert_list_command(client: Client, args: dict) -> CommandResults:
        """
        List alerts from Flashpoint.

        :param client: Client object
        :param args: The command arguments
        :return: Standard command result or no records found message.
        """
        args = validate_alert_list_args(args)
        response = client.http_request("GET", url_suffix=URL_SUFFIX_V1['ALERTS'], params=args)

        alerts = response.get('data', [])
        if not alerts:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('alerts'))

        readable_output = prepare_hr_for_alerts(alerts)

        token_context = {
            'since': 'N/A',
            'until': 'N/A',
            'size': 'N/A',
            'scroll_id': 'N/A',
            'name': 'flashpoint-alert-list'
        }

        links = response.get('links', {}).get('next', {}).get('href')
        if links:
            token_hr = "To retrieve the next set of result use,"
            context = prepare_context_from_next_href(links)
            for con in context:
                token_context[con] = context[con][0]
                token_hr += "\n" + con + " = " + context[con][0]
            readable_output += token_hr

        for alert in alerts:
            tags = alert.get('tags', {})
            if 'archived' in tags.keys():
                alert['tags']['archived'] = True
            else:
                alert['tags']['archived'] = False

            if 'flagged' in tags.keys():
                alert['tags']['flagged'] = True
            else:
                alert['tags']['flagged'] = False

        outputs = {
            FLASHPOINT_PATHS['ALERT']: alerts,
            FLASHPOINT_PATHS['TOKEN']: token_context
        }

        outputs = remove_empty_elements(outputs)

        return CommandResults(
            outputs=outputs,
            readable_output=readable_output,
            raw_response=response
        )


    def flashpoint_compromised_credentials_list_command(client: Client, args: dict) -> CommandResults:
        """
        List compromised credentials from Flashpoint.

        :param client: Client object
        :param args: The command arguments
        :return: Standard command result or no records found message.
        """
        args = validate_compromised_credentials_list_args(args)
        response = client.http_request("GET", url_suffix=URL_SUFFIX['COMPROMISED_CREDENTIALS'], params=args)

        hits = response.get('hits', {}).get('hits', [])
        if not hits:
            return CommandResults(readable_output=MESSAGES['NO_RECORDS_FOUND'].format('compromised credentials'))

        readable_output = ''

        total_records = response.get('hits', {}).get('total')
        if total_records:
            readable_output += f'#### Total number of records found: {total_records}\n\n'

        readable_output += prepare_hr_for_compromised_credentials(hits)

        outputs = remove_empty_elements(hits)

        return CommandResults(
            outputs_prefix="Flashpoint.CompromisedCredential",
            outputs_key_field="_id",
            outputs=outputs,
            readable_output=readable_output,
            raw_response=response
        )


    def fetch_incidents(client: Client, last_run: dict, params: dict) -> Tuple[dict, list]:
        """
        Fetch incidents from Flashpoint.

        :param client: Client object
        :param last_run: Last run returned by function demisto.getLastRun
        :param params: Dictionary of parameters

        :return: Tuple of dictionary of next run and list of fetched incidents
        """
        fetch_params = validate_fetch_incidents_params(params, last_run)
        fetch_type = fetch_params['fetch_type']

        url_suffix = ''
        if fetch_type == 'Alerts':
            url_suffix = URL_SUFFIX_V1['ALERTS']
        elif fetch_type == DEFAULT_FETCH_TYPE:
            url_suffix = URL_SUFFIX['COMPROMISED_CREDENTIALS']

        response = client.http_request("GET", url_suffix=url_suffix, params=fetch_params['fetch_params'])

        incidents: List[Dict[str, Any]] = []
        next_run = last_run
        start_time = fetch_params['start_time']

        if fetch_type == "Alerts":
            next_run, incidents = prepare_incidents_from_alerts_data(response, next_run, start_time)

        elif fetch_type == DEFAULT_FETCH_TYPE:
            next_run, incidents = prepare_incidents_from_compromised_credentials_data(response, next_run, start_time)

        return next_run, incidents


    def main():
        """Parse and validate integration params."""
        params = demisto.params()
        api_key = get_apikey()
        url = params["url"]
        verify_certificate = not params.get('insecure', False)
        create_relationships = argToBoolean(params.get('create_relationships', True))
        proxies = handle_proxy()

        args = remove_space_from_args(demisto.args())

        command = demisto.command()
        try:
            client = Client(api_key, url, verify_certificate, proxies, create_relationships)

            COMMAND_TO_FUNCTION = {
                'flashpoint-search-intelligence-reports': get_reports_command,
                'flashpoint-get-single-intelligence-report': get_report_by_id_command,
                'flashpoint-get-related-reports': get_related_reports_command,
                'flashpoint-get-single-event': get_event_by_id_command,
                'flashpoint-get-events': get_events_command,
                'flashpoint-get-forum-details': get_forum_details_by_id_command,
                'flashpoint-get-forum-room-details': get_room_details_by_id_command,
                'flashpoint-get-forum-user-details': get_user_details_by_id_command,
                'flashpoint-get-forum-post-details': get_post_details_by_id_command,
                'flashpoint-search-forum-sites': get_forum_sites_command,
                'flashpoint-search-forum-posts': get_forum_posts_command,
            }

            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration Test button.
                test_module(client, params)  # NOSONAR
                demisto.results('ok')

            elif command == 'fetch-incidents':
                last_run = demisto.getLastRun()
                next_run, incidents = fetch_incidents(client, last_run, params)
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'ip':
                ip = args.get('ip')
                reputation_operation_command(client, ip, ip_lookup_command, True)

            elif demisto.command() == 'domain':
                domain = args.get('domain')
                reputation_operation_command(client, domain, domain_lookup_command, True)

            elif demisto.command() == 'filename':
                filename = args.get('filename')
                reputation_operation_command(client, filename, filename_lookup_command)

            elif demisto.command() == 'url':
                url = args.get('url')
                reputation_operation_command(client, url, url_lookup_command, True)

            elif demisto.command() == 'file':
                file = args.get('file')
                reputation_operation_command(client, file, file_lookup_command, True)

            elif demisto.command() == 'email':
                email = args.get('email')
                reputation_operation_command(client, email, email_lookup_command)

            elif demisto.command() == 'flashpoint-common-lookup':
                indicator_value = args.get('indicator')
                reputation_operation_command(client, indicator_value, common_lookup_command)

            elif command == 'flashpoint-alert-list':
                return_results(flashpoint_alert_list_command(client, args))

            elif command == 'flashpoint-compromised-credentials-list':
                return_results(flashpoint_compromised_credentials_list_command(client, args))

            elif COMMAND_TO_FUNCTION.get(demisto.command()):
                return_outputs(*COMMAND_TO_FUNCTION[demisto.command()](client, args))

            else:
                raise NotImplementedError(f'Command {demisto.command()} is not implemented')

        except requests.exceptions.ConnectionError as c:
            """ Caused mostly when URL is altered."""
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(c)}')

        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('Flashpoint', 'end', __line__())
  subtype: python3
  type: python
system: true
